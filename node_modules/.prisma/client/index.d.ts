
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model produk_item
 * 
 */
export type produk_item = $Result.DefaultSelection<Prisma.$produk_itemPayload>
/**
 * Model produksi
 * 
 */
export type produksi = $Result.DefaultSelection<Prisma.$produksiPayload>
/**
 * Model kategori_produk
 * 
 */
export type kategori_produk = $Result.DefaultSelection<Prisma.$kategori_produkPayload>
/**
 * Model pembuat
 * 
 */
export type pembuat = $Result.DefaultSelection<Prisma.$pembuatPayload>
/**
 * Model bahan_produksi
 * 
 */
export type bahan_produksi = $Result.DefaultSelection<Prisma.$bahan_produksiPayload>
/**
 * Model stok_bahan
 * 
 */
export type stok_bahan = $Result.DefaultSelection<Prisma.$stok_bahanPayload>
/**
 * Model detail_pengecekan_produk
 * 
 */
export type detail_pengecekan_produk = $Result.DefaultSelection<Prisma.$detail_pengecekan_produkPayload>
/**
 * Model pengecekan_produk
 * 
 */
export type pengecekan_produk = $Result.DefaultSelection<Prisma.$pengecekan_produkPayload>
/**
 * Model kondisi_produk
 * 
 */
export type kondisi_produk = $Result.DefaultSelection<Prisma.$kondisi_produkPayload>
/**
 * Model detail_pengecekan_bahan
 * 
 */
export type detail_pengecekan_bahan = $Result.DefaultSelection<Prisma.$detail_pengecekan_bahanPayload>
/**
 * Model pengecekan_bahan
 * 
 */
export type pengecekan_bahan = $Result.DefaultSelection<Prisma.$pengecekan_bahanPayload>
/**
 * Model kondisi_bahan
 * 
 */
export type kondisi_bahan = $Result.DefaultSelection<Prisma.$kondisi_bahanPayload>
/**
 * Model detail_pemesanan_bahan
 * 
 */
export type detail_pemesanan_bahan = $Result.DefaultSelection<Prisma.$detail_pemesanan_bahanPayload>
/**
 * Model pemesanan_bahan
 * 
 */
export type pemesanan_bahan = $Result.DefaultSelection<Prisma.$pemesanan_bahanPayload>
/**
 * Model supplier
 * 
 */
export type supplier = $Result.DefaultSelection<Prisma.$supplierPayload>
/**
 * Model detail_gawangan
 * 
 */
export type detail_gawangan = $Result.DefaultSelection<Prisma.$detail_gawanganPayload>
/**
 * Model gawangan
 * 
 */
export type gawangan = $Result.DefaultSelection<Prisma.$gawanganPayload>
/**
 * Model outlet
 * 
 */
export type outlet = $Result.DefaultSelection<Prisma.$outletPayload>
/**
 * Model pembelian_produk
 * 
 */
export type pembelian_produk = $Result.DefaultSelection<Prisma.$pembelian_produkPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model detail_pembelian_produk
 * 
 */
export type detail_pembelian_produk = $Result.DefaultSelection<Prisma.$detail_pembelian_produkPayload>
/**
 * Model diskon
 * 
 */
export type diskon = $Result.DefaultSelection<Prisma.$diskonPayload>
/**
 * Model detail_diskon
 * 
 */
export type detail_diskon = $Result.DefaultSelection<Prisma.$detail_diskonPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipeDiskon: {
  PERSENTASE: 'PERSENTASE',
  RUPIAH: 'RUPIAH'
};

export type TipeDiskon = (typeof TipeDiskon)[keyof typeof TipeDiskon]

}

export type TipeDiskon = $Enums.TipeDiskon

export const TipeDiskon: typeof $Enums.TipeDiskon

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Produk_items
 * const produk_items = await prisma.produk_item.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Produk_items
   * const produk_items = await prisma.produk_item.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.produk_item`: Exposes CRUD operations for the **produk_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produk_items
    * const produk_items = await prisma.produk_item.findMany()
    * ```
    */
  get produk_item(): Prisma.produk_itemDelegate<ExtArgs>;

  /**
   * `prisma.produksi`: Exposes CRUD operations for the **produksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produksis
    * const produksis = await prisma.produksi.findMany()
    * ```
    */
  get produksi(): Prisma.produksiDelegate<ExtArgs>;

  /**
   * `prisma.kategori_produk`: Exposes CRUD operations for the **kategori_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kategori_produks
    * const kategori_produks = await prisma.kategori_produk.findMany()
    * ```
    */
  get kategori_produk(): Prisma.kategori_produkDelegate<ExtArgs>;

  /**
   * `prisma.pembuat`: Exposes CRUD operations for the **pembuat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pembuats
    * const pembuats = await prisma.pembuat.findMany()
    * ```
    */
  get pembuat(): Prisma.pembuatDelegate<ExtArgs>;

  /**
   * `prisma.bahan_produksi`: Exposes CRUD operations for the **bahan_produksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bahan_produksis
    * const bahan_produksis = await prisma.bahan_produksi.findMany()
    * ```
    */
  get bahan_produksi(): Prisma.bahan_produksiDelegate<ExtArgs>;

  /**
   * `prisma.stok_bahan`: Exposes CRUD operations for the **stok_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stok_bahans
    * const stok_bahans = await prisma.stok_bahan.findMany()
    * ```
    */
  get stok_bahan(): Prisma.stok_bahanDelegate<ExtArgs>;

  /**
   * `prisma.detail_pengecekan_produk`: Exposes CRUD operations for the **detail_pengecekan_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_pengecekan_produks
    * const detail_pengecekan_produks = await prisma.detail_pengecekan_produk.findMany()
    * ```
    */
  get detail_pengecekan_produk(): Prisma.detail_pengecekan_produkDelegate<ExtArgs>;

  /**
   * `prisma.pengecekan_produk`: Exposes CRUD operations for the **pengecekan_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengecekan_produks
    * const pengecekan_produks = await prisma.pengecekan_produk.findMany()
    * ```
    */
  get pengecekan_produk(): Prisma.pengecekan_produkDelegate<ExtArgs>;

  /**
   * `prisma.kondisi_produk`: Exposes CRUD operations for the **kondisi_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kondisi_produks
    * const kondisi_produks = await prisma.kondisi_produk.findMany()
    * ```
    */
  get kondisi_produk(): Prisma.kondisi_produkDelegate<ExtArgs>;

  /**
   * `prisma.detail_pengecekan_bahan`: Exposes CRUD operations for the **detail_pengecekan_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_pengecekan_bahans
    * const detail_pengecekan_bahans = await prisma.detail_pengecekan_bahan.findMany()
    * ```
    */
  get detail_pengecekan_bahan(): Prisma.detail_pengecekan_bahanDelegate<ExtArgs>;

  /**
   * `prisma.pengecekan_bahan`: Exposes CRUD operations for the **pengecekan_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengecekan_bahans
    * const pengecekan_bahans = await prisma.pengecekan_bahan.findMany()
    * ```
    */
  get pengecekan_bahan(): Prisma.pengecekan_bahanDelegate<ExtArgs>;

  /**
   * `prisma.kondisi_bahan`: Exposes CRUD operations for the **kondisi_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kondisi_bahans
    * const kondisi_bahans = await prisma.kondisi_bahan.findMany()
    * ```
    */
  get kondisi_bahan(): Prisma.kondisi_bahanDelegate<ExtArgs>;

  /**
   * `prisma.detail_pemesanan_bahan`: Exposes CRUD operations for the **detail_pemesanan_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_pemesanan_bahans
    * const detail_pemesanan_bahans = await prisma.detail_pemesanan_bahan.findMany()
    * ```
    */
  get detail_pemesanan_bahan(): Prisma.detail_pemesanan_bahanDelegate<ExtArgs>;

  /**
   * `prisma.pemesanan_bahan`: Exposes CRUD operations for the **pemesanan_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pemesanan_bahans
    * const pemesanan_bahans = await prisma.pemesanan_bahan.findMany()
    * ```
    */
  get pemesanan_bahan(): Prisma.pemesanan_bahanDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<ExtArgs>;

  /**
   * `prisma.detail_gawangan`: Exposes CRUD operations for the **detail_gawangan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_gawangans
    * const detail_gawangans = await prisma.detail_gawangan.findMany()
    * ```
    */
  get detail_gawangan(): Prisma.detail_gawanganDelegate<ExtArgs>;

  /**
   * `prisma.gawangan`: Exposes CRUD operations for the **gawangan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gawangans
    * const gawangans = await prisma.gawangan.findMany()
    * ```
    */
  get gawangan(): Prisma.gawanganDelegate<ExtArgs>;

  /**
   * `prisma.outlet`: Exposes CRUD operations for the **outlet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outlets
    * const outlets = await prisma.outlet.findMany()
    * ```
    */
  get outlet(): Prisma.outletDelegate<ExtArgs>;

  /**
   * `prisma.pembelian_produk`: Exposes CRUD operations for the **pembelian_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pembelian_produks
    * const pembelian_produks = await prisma.pembelian_produk.findMany()
    * ```
    */
  get pembelian_produk(): Prisma.pembelian_produkDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.detail_pembelian_produk`: Exposes CRUD operations for the **detail_pembelian_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_pembelian_produks
    * const detail_pembelian_produks = await prisma.detail_pembelian_produk.findMany()
    * ```
    */
  get detail_pembelian_produk(): Prisma.detail_pembelian_produkDelegate<ExtArgs>;

  /**
   * `prisma.diskon`: Exposes CRUD operations for the **diskon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diskons
    * const diskons = await prisma.diskon.findMany()
    * ```
    */
  get diskon(): Prisma.diskonDelegate<ExtArgs>;

  /**
   * `prisma.detail_diskon`: Exposes CRUD operations for the **detail_diskon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_diskons
    * const detail_diskons = await prisma.detail_diskon.findMany()
    * ```
    */
  get detail_diskon(): Prisma.detail_diskonDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    produk_item: 'produk_item',
    produksi: 'produksi',
    kategori_produk: 'kategori_produk',
    pembuat: 'pembuat',
    bahan_produksi: 'bahan_produksi',
    stok_bahan: 'stok_bahan',
    detail_pengecekan_produk: 'detail_pengecekan_produk',
    pengecekan_produk: 'pengecekan_produk',
    kondisi_produk: 'kondisi_produk',
    detail_pengecekan_bahan: 'detail_pengecekan_bahan',
    pengecekan_bahan: 'pengecekan_bahan',
    kondisi_bahan: 'kondisi_bahan',
    detail_pemesanan_bahan: 'detail_pemesanan_bahan',
    pemesanan_bahan: 'pemesanan_bahan',
    supplier: 'supplier',
    detail_gawangan: 'detail_gawangan',
    gawangan: 'gawangan',
    outlet: 'outlet',
    pembelian_produk: 'pembelian_produk',
    user: 'user',
    detail_pembelian_produk: 'detail_pembelian_produk',
    diskon: 'diskon',
    detail_diskon: 'detail_diskon'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'produk_item' | 'produksi' | 'kategori_produk' | 'pembuat' | 'bahan_produksi' | 'stok_bahan' | 'detail_pengecekan_produk' | 'pengecekan_produk' | 'kondisi_produk' | 'detail_pengecekan_bahan' | 'pengecekan_bahan' | 'kondisi_bahan' | 'detail_pemesanan_bahan' | 'pemesanan_bahan' | 'supplier' | 'detail_gawangan' | 'gawangan' | 'outlet' | 'pembelian_produk' | 'user' | 'detail_pembelian_produk' | 'diskon' | 'detail_diskon'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      produk_item: {
        payload: Prisma.$produk_itemPayload<ExtArgs>
        fields: Prisma.produk_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produk_itemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produk_itemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          findFirst: {
            args: Prisma.produk_itemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produk_itemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          findMany: {
            args: Prisma.produk_itemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>[]
          }
          create: {
            args: Prisma.produk_itemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          createMany: {
            args: Prisma.produk_itemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.produk_itemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          update: {
            args: Prisma.produk_itemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          deleteMany: {
            args: Prisma.produk_itemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.produk_itemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.produk_itemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produk_itemPayload>
          }
          aggregate: {
            args: Prisma.Produk_itemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduk_item>
          }
          groupBy: {
            args: Prisma.produk_itemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Produk_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.produk_itemCountArgs<ExtArgs>,
            result: $Utils.Optional<Produk_itemCountAggregateOutputType> | number
          }
        }
      }
      produksi: {
        payload: Prisma.$produksiPayload<ExtArgs>
        fields: Prisma.produksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produksiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produksiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          findFirst: {
            args: Prisma.produksiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produksiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          findMany: {
            args: Prisma.produksiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>[]
          }
          create: {
            args: Prisma.produksiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          createMany: {
            args: Prisma.produksiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.produksiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          update: {
            args: Prisma.produksiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          deleteMany: {
            args: Prisma.produksiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.produksiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.produksiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          aggregate: {
            args: Prisma.ProduksiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduksi>
          }
          groupBy: {
            args: Prisma.produksiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProduksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.produksiCountArgs<ExtArgs>,
            result: $Utils.Optional<ProduksiCountAggregateOutputType> | number
          }
        }
      }
      kategori_produk: {
        payload: Prisma.$kategori_produkPayload<ExtArgs>
        fields: Prisma.kategori_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategori_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategori_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          findFirst: {
            args: Prisma.kategori_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategori_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          findMany: {
            args: Prisma.kategori_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>[]
          }
          create: {
            args: Prisma.kategori_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          createMany: {
            args: Prisma.kategori_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.kategori_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          update: {
            args: Prisma.kategori_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          deleteMany: {
            args: Prisma.kategori_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.kategori_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.kategori_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          aggregate: {
            args: Prisma.Kategori_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKategori_produk>
          }
          groupBy: {
            args: Prisma.kategori_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Kategori_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategori_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Kategori_produkCountAggregateOutputType> | number
          }
        }
      }
      pembuat: {
        payload: Prisma.$pembuatPayload<ExtArgs>
        fields: Prisma.pembuatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pembuatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pembuatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          findFirst: {
            args: Prisma.pembuatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pembuatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          findMany: {
            args: Prisma.pembuatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>[]
          }
          create: {
            args: Prisma.pembuatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          createMany: {
            args: Prisma.pembuatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pembuatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          update: {
            args: Prisma.pembuatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          deleteMany: {
            args: Prisma.pembuatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pembuatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pembuatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembuatPayload>
          }
          aggregate: {
            args: Prisma.PembuatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePembuat>
          }
          groupBy: {
            args: Prisma.pembuatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PembuatGroupByOutputType>[]
          }
          count: {
            args: Prisma.pembuatCountArgs<ExtArgs>,
            result: $Utils.Optional<PembuatCountAggregateOutputType> | number
          }
        }
      }
      bahan_produksi: {
        payload: Prisma.$bahan_produksiPayload<ExtArgs>
        fields: Prisma.bahan_produksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bahan_produksiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bahan_produksiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          findFirst: {
            args: Prisma.bahan_produksiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bahan_produksiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          findMany: {
            args: Prisma.bahan_produksiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>[]
          }
          create: {
            args: Prisma.bahan_produksiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          createMany: {
            args: Prisma.bahan_produksiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bahan_produksiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          update: {
            args: Prisma.bahan_produksiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          deleteMany: {
            args: Prisma.bahan_produksiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bahan_produksiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bahan_produksiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produksiPayload>
          }
          aggregate: {
            args: Prisma.Bahan_produksiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBahan_produksi>
          }
          groupBy: {
            args: Prisma.bahan_produksiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bahan_produksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.bahan_produksiCountArgs<ExtArgs>,
            result: $Utils.Optional<Bahan_produksiCountAggregateOutputType> | number
          }
        }
      }
      stok_bahan: {
        payload: Prisma.$stok_bahanPayload<ExtArgs>
        fields: Prisma.stok_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stok_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stok_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          findFirst: {
            args: Prisma.stok_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stok_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          findMany: {
            args: Prisma.stok_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>[]
          }
          create: {
            args: Prisma.stok_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          createMany: {
            args: Prisma.stok_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.stok_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          update: {
            args: Prisma.stok_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          deleteMany: {
            args: Prisma.stok_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.stok_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.stok_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$stok_bahanPayload>
          }
          aggregate: {
            args: Prisma.Stok_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStok_bahan>
          }
          groupBy: {
            args: Prisma.stok_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Stok_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.stok_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Stok_bahanCountAggregateOutputType> | number
          }
        }
      }
      detail_pengecekan_produk: {
        payload: Prisma.$detail_pengecekan_produkPayload<ExtArgs>
        fields: Prisma.detail_pengecekan_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_pengecekan_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          findFirst: {
            args: Prisma.detail_pengecekan_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_pengecekan_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          findMany: {
            args: Prisma.detail_pengecekan_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>[]
          }
          create: {
            args: Prisma.detail_pengecekan_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          createMany: {
            args: Prisma.detail_pengecekan_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_pengecekan_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          update: {
            args: Prisma.detail_pengecekan_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          deleteMany: {
            args: Prisma.detail_pengecekan_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_pengecekan_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_pengecekan_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_produkPayload>
          }
          aggregate: {
            args: Prisma.Detail_pengecekan_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_pengecekan_produk>
          }
          groupBy: {
            args: Prisma.detail_pengecekan_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pengecekan_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_pengecekan_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pengecekan_produkCountAggregateOutputType> | number
          }
        }
      }
      pengecekan_produk: {
        payload: Prisma.$pengecekan_produkPayload<ExtArgs>
        fields: Prisma.pengecekan_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pengecekan_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          findFirst: {
            args: Prisma.pengecekan_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pengecekan_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          findMany: {
            args: Prisma.pengecekan_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>[]
          }
          create: {
            args: Prisma.pengecekan_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          createMany: {
            args: Prisma.pengecekan_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pengecekan_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          update: {
            args: Prisma.pengecekan_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          deleteMany: {
            args: Prisma.pengecekan_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pengecekan_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pengecekan_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_produkPayload>
          }
          aggregate: {
            args: Prisma.Pengecekan_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePengecekan_produk>
          }
          groupBy: {
            args: Prisma.pengecekan_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Pengecekan_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.pengecekan_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Pengecekan_produkCountAggregateOutputType> | number
          }
        }
      }
      kondisi_produk: {
        payload: Prisma.$kondisi_produkPayload<ExtArgs>
        fields: Prisma.kondisi_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kondisi_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kondisi_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          findFirst: {
            args: Prisma.kondisi_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kondisi_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          findMany: {
            args: Prisma.kondisi_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>[]
          }
          create: {
            args: Prisma.kondisi_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          createMany: {
            args: Prisma.kondisi_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.kondisi_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          update: {
            args: Prisma.kondisi_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          deleteMany: {
            args: Prisma.kondisi_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.kondisi_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.kondisi_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_produkPayload>
          }
          aggregate: {
            args: Prisma.Kondisi_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKondisi_produk>
          }
          groupBy: {
            args: Prisma.kondisi_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Kondisi_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.kondisi_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Kondisi_produkCountAggregateOutputType> | number
          }
        }
      }
      detail_pengecekan_bahan: {
        payload: Prisma.$detail_pengecekan_bahanPayload<ExtArgs>
        fields: Prisma.detail_pengecekan_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_pengecekan_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          findFirst: {
            args: Prisma.detail_pengecekan_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          findMany: {
            args: Prisma.detail_pengecekan_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>[]
          }
          create: {
            args: Prisma.detail_pengecekan_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          createMany: {
            args: Prisma.detail_pengecekan_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_pengecekan_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          update: {
            args: Prisma.detail_pengecekan_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          deleteMany: {
            args: Prisma.detail_pengecekan_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_pengecekan_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_pengecekan_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pengecekan_bahanPayload>
          }
          aggregate: {
            args: Prisma.Detail_pengecekan_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_pengecekan_bahan>
          }
          groupBy: {
            args: Prisma.detail_pengecekan_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pengecekan_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_pengecekan_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pengecekan_bahanCountAggregateOutputType> | number
          }
        }
      }
      pengecekan_bahan: {
        payload: Prisma.$pengecekan_bahanPayload<ExtArgs>
        fields: Prisma.pengecekan_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pengecekan_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          findFirst: {
            args: Prisma.pengecekan_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          findMany: {
            args: Prisma.pengecekan_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>[]
          }
          create: {
            args: Prisma.pengecekan_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          createMany: {
            args: Prisma.pengecekan_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pengecekan_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          update: {
            args: Prisma.pengecekan_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          deleteMany: {
            args: Prisma.pengecekan_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pengecekan_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pengecekan_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pengecekan_bahanPayload>
          }
          aggregate: {
            args: Prisma.Pengecekan_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePengecekan_bahan>
          }
          groupBy: {
            args: Prisma.pengecekan_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Pengecekan_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pengecekan_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Pengecekan_bahanCountAggregateOutputType> | number
          }
        }
      }
      kondisi_bahan: {
        payload: Prisma.$kondisi_bahanPayload<ExtArgs>
        fields: Prisma.kondisi_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kondisi_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kondisi_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          findFirst: {
            args: Prisma.kondisi_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kondisi_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          findMany: {
            args: Prisma.kondisi_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>[]
          }
          create: {
            args: Prisma.kondisi_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          createMany: {
            args: Prisma.kondisi_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.kondisi_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          update: {
            args: Prisma.kondisi_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          deleteMany: {
            args: Prisma.kondisi_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.kondisi_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.kondisi_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kondisi_bahanPayload>
          }
          aggregate: {
            args: Prisma.Kondisi_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKondisi_bahan>
          }
          groupBy: {
            args: Prisma.kondisi_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Kondisi_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.kondisi_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Kondisi_bahanCountAggregateOutputType> | number
          }
        }
      }
      detail_pemesanan_bahan: {
        payload: Prisma.$detail_pemesanan_bahanPayload<ExtArgs>
        fields: Prisma.detail_pemesanan_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_pemesanan_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          findFirst: {
            args: Prisma.detail_pemesanan_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          findMany: {
            args: Prisma.detail_pemesanan_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>[]
          }
          create: {
            args: Prisma.detail_pemesanan_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          createMany: {
            args: Prisma.detail_pemesanan_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_pemesanan_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          update: {
            args: Prisma.detail_pemesanan_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          deleteMany: {
            args: Prisma.detail_pemesanan_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_pemesanan_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_pemesanan_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pemesanan_bahanPayload>
          }
          aggregate: {
            args: Prisma.Detail_pemesanan_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_pemesanan_bahan>
          }
          groupBy: {
            args: Prisma.detail_pemesanan_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pemesanan_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_pemesanan_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pemesanan_bahanCountAggregateOutputType> | number
          }
        }
      }
      pemesanan_bahan: {
        payload: Prisma.$pemesanan_bahanPayload<ExtArgs>
        fields: Prisma.pemesanan_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pemesanan_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          findFirst: {
            args: Prisma.pemesanan_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          findMany: {
            args: Prisma.pemesanan_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>[]
          }
          create: {
            args: Prisma.pemesanan_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          createMany: {
            args: Prisma.pemesanan_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pemesanan_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          update: {
            args: Prisma.pemesanan_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          deleteMany: {
            args: Prisma.pemesanan_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pemesanan_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pemesanan_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pemesanan_bahanPayload>
          }
          aggregate: {
            args: Prisma.Pemesanan_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePemesanan_bahan>
          }
          groupBy: {
            args: Prisma.pemesanan_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Pemesanan_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pemesanan_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Pemesanan_bahanCountAggregateOutputType> | number
          }
        }
      }
      supplier: {
        payload: Prisma.$supplierPayload<ExtArgs>
        fields: Prisma.supplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findFirst: {
            args: Prisma.supplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findMany: {
            args: Prisma.supplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          create: {
            args: Prisma.supplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          createMany: {
            args: Prisma.supplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.supplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          update: {
            args: Prisma.supplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          deleteMany: {
            args: Prisma.supplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.supplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.supplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.supplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      detail_gawangan: {
        payload: Prisma.$detail_gawanganPayload<ExtArgs>
        fields: Prisma.detail_gawanganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_gawanganFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_gawanganFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          findFirst: {
            args: Prisma.detail_gawanganFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_gawanganFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          findMany: {
            args: Prisma.detail_gawanganFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>[]
          }
          create: {
            args: Prisma.detail_gawanganCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          createMany: {
            args: Prisma.detail_gawanganCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_gawanganDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          update: {
            args: Prisma.detail_gawanganUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          deleteMany: {
            args: Prisma.detail_gawanganDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_gawanganUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_gawanganUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_gawanganPayload>
          }
          aggregate: {
            args: Prisma.Detail_gawanganAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_gawangan>
          }
          groupBy: {
            args: Prisma.detail_gawanganGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_gawanganGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_gawanganCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_gawanganCountAggregateOutputType> | number
          }
        }
      }
      gawangan: {
        payload: Prisma.$gawanganPayload<ExtArgs>
        fields: Prisma.gawanganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gawanganFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gawanganFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          findFirst: {
            args: Prisma.gawanganFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gawanganFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          findMany: {
            args: Prisma.gawanganFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>[]
          }
          create: {
            args: Prisma.gawanganCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          createMany: {
            args: Prisma.gawanganCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.gawanganDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          update: {
            args: Prisma.gawanganUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          deleteMany: {
            args: Prisma.gawanganDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.gawanganUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.gawanganUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gawanganPayload>
          }
          aggregate: {
            args: Prisma.GawanganAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGawangan>
          }
          groupBy: {
            args: Prisma.gawanganGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GawanganGroupByOutputType>[]
          }
          count: {
            args: Prisma.gawanganCountArgs<ExtArgs>,
            result: $Utils.Optional<GawanganCountAggregateOutputType> | number
          }
        }
      }
      outlet: {
        payload: Prisma.$outletPayload<ExtArgs>
        fields: Prisma.outletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.outletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.outletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          findFirst: {
            args: Prisma.outletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.outletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          findMany: {
            args: Prisma.outletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>[]
          }
          create: {
            args: Prisma.outletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          createMany: {
            args: Prisma.outletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.outletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          update: {
            args: Prisma.outletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          deleteMany: {
            args: Prisma.outletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.outletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.outletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$outletPayload>
          }
          aggregate: {
            args: Prisma.OutletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOutlet>
          }
          groupBy: {
            args: Prisma.outletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OutletGroupByOutputType>[]
          }
          count: {
            args: Prisma.outletCountArgs<ExtArgs>,
            result: $Utils.Optional<OutletCountAggregateOutputType> | number
          }
        }
      }
      pembelian_produk: {
        payload: Prisma.$pembelian_produkPayload<ExtArgs>
        fields: Prisma.pembelian_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pembelian_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pembelian_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          findFirst: {
            args: Prisma.pembelian_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pembelian_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          findMany: {
            args: Prisma.pembelian_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>[]
          }
          create: {
            args: Prisma.pembelian_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          createMany: {
            args: Prisma.pembelian_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pembelian_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          update: {
            args: Prisma.pembelian_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          deleteMany: {
            args: Prisma.pembelian_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pembelian_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pembelian_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pembelian_produkPayload>
          }
          aggregate: {
            args: Prisma.Pembelian_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePembelian_produk>
          }
          groupBy: {
            args: Prisma.pembelian_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Pembelian_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.pembelian_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Pembelian_produkCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      detail_pembelian_produk: {
        payload: Prisma.$detail_pembelian_produkPayload<ExtArgs>
        fields: Prisma.detail_pembelian_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_pembelian_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_pembelian_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          findFirst: {
            args: Prisma.detail_pembelian_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_pembelian_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          findMany: {
            args: Prisma.detail_pembelian_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>[]
          }
          create: {
            args: Prisma.detail_pembelian_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          createMany: {
            args: Prisma.detail_pembelian_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_pembelian_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          update: {
            args: Prisma.detail_pembelian_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          deleteMany: {
            args: Prisma.detail_pembelian_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_pembelian_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_pembelian_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_pembelian_produkPayload>
          }
          aggregate: {
            args: Prisma.Detail_pembelian_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_pembelian_produk>
          }
          groupBy: {
            args: Prisma.detail_pembelian_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pembelian_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_pembelian_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_pembelian_produkCountAggregateOutputType> | number
          }
        }
      }
      diskon: {
        payload: Prisma.$diskonPayload<ExtArgs>
        fields: Prisma.diskonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diskonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diskonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          findFirst: {
            args: Prisma.diskonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diskonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          findMany: {
            args: Prisma.diskonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>[]
          }
          create: {
            args: Prisma.diskonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          createMany: {
            args: Prisma.diskonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.diskonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          update: {
            args: Prisma.diskonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          deleteMany: {
            args: Prisma.diskonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.diskonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.diskonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$diskonPayload>
          }
          aggregate: {
            args: Prisma.DiskonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiskon>
          }
          groupBy: {
            args: Prisma.diskonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiskonGroupByOutputType>[]
          }
          count: {
            args: Prisma.diskonCountArgs<ExtArgs>,
            result: $Utils.Optional<DiskonCountAggregateOutputType> | number
          }
        }
      }
      detail_diskon: {
        payload: Prisma.$detail_diskonPayload<ExtArgs>
        fields: Prisma.detail_diskonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_diskonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_diskonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          findFirst: {
            args: Prisma.detail_diskonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_diskonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          findMany: {
            args: Prisma.detail_diskonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>[]
          }
          create: {
            args: Prisma.detail_diskonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          createMany: {
            args: Prisma.detail_diskonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_diskonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          update: {
            args: Prisma.detail_diskonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          deleteMany: {
            args: Prisma.detail_diskonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_diskonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_diskonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_diskonPayload>
          }
          aggregate: {
            args: Prisma.Detail_diskonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_diskon>
          }
          groupBy: {
            args: Prisma.detail_diskonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_diskonGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_diskonCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_diskonCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Produk_itemCountOutputType
   */

  export type Produk_itemCountOutputType = {
    detail_diskon: number
    detail_pengecekan_produk: number
    detail_gawangan: number
    detail_pembelian_produk: number
  }

  export type Produk_itemCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_diskon?: boolean | Produk_itemCountOutputTypeCountDetail_diskonArgs
    detail_pengecekan_produk?: boolean | Produk_itemCountOutputTypeCountDetail_pengecekan_produkArgs
    detail_gawangan?: boolean | Produk_itemCountOutputTypeCountDetail_gawanganArgs
    detail_pembelian_produk?: boolean | Produk_itemCountOutputTypeCountDetail_pembelian_produkArgs
  }

  // Custom InputTypes

  /**
   * Produk_itemCountOutputType without action
   */
  export type Produk_itemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produk_itemCountOutputType
     */
    select?: Produk_itemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Produk_itemCountOutputType without action
   */
  export type Produk_itemCountOutputTypeCountDetail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_diskonWhereInput
  }


  /**
   * Produk_itemCountOutputType without action
   */
  export type Produk_itemCountOutputTypeCountDetail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_produkWhereInput
  }


  /**
   * Produk_itemCountOutputType without action
   */
  export type Produk_itemCountOutputTypeCountDetail_gawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_gawanganWhereInput
  }


  /**
   * Produk_itemCountOutputType without action
   */
  export type Produk_itemCountOutputTypeCountDetail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pembelian_produkWhereInput
  }



  /**
   * Count Type ProduksiCountOutputType
   */

  export type ProduksiCountOutputType = {
    produk_item: number
    bahan_produksi: number
  }

  export type ProduksiCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produk_item?: boolean | ProduksiCountOutputTypeCountProduk_itemArgs
    bahan_produksi?: boolean | ProduksiCountOutputTypeCountBahan_produksiArgs
  }

  // Custom InputTypes

  /**
   * ProduksiCountOutputType without action
   */
  export type ProduksiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProduksiCountOutputType
     */
    select?: ProduksiCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProduksiCountOutputType without action
   */
  export type ProduksiCountOutputTypeCountProduk_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produk_itemWhereInput
  }


  /**
   * ProduksiCountOutputType without action
   */
  export type ProduksiCountOutputTypeCountBahan_produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bahan_produksiWhereInput
  }



  /**
   * Count Type Kategori_produkCountOutputType
   */

  export type Kategori_produkCountOutputType = {
    produksi: number
  }

  export type Kategori_produkCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | Kategori_produkCountOutputTypeCountProduksiArgs
  }

  // Custom InputTypes

  /**
   * Kategori_produkCountOutputType without action
   */
  export type Kategori_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kategori_produkCountOutputType
     */
    select?: Kategori_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Kategori_produkCountOutputType without action
   */
  export type Kategori_produkCountOutputTypeCountProduksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
  }



  /**
   * Count Type PembuatCountOutputType
   */

  export type PembuatCountOutputType = {
    produksi: number
  }

  export type PembuatCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | PembuatCountOutputTypeCountProduksiArgs
  }

  // Custom InputTypes

  /**
   * PembuatCountOutputType without action
   */
  export type PembuatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PembuatCountOutputType
     */
    select?: PembuatCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PembuatCountOutputType without action
   */
  export type PembuatCountOutputTypeCountProduksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
  }



  /**
   * Count Type Stok_bahanCountOutputType
   */

  export type Stok_bahanCountOutputType = {
    bahan_produksi: number
    detail_pengecekan_bahan: number
    detail_pemesanan_bahan: number
  }

  export type Stok_bahanCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bahan_produksi?: boolean | Stok_bahanCountOutputTypeCountBahan_produksiArgs
    detail_pengecekan_bahan?: boolean | Stok_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs
    detail_pemesanan_bahan?: boolean | Stok_bahanCountOutputTypeCountDetail_pemesanan_bahanArgs
  }

  // Custom InputTypes

  /**
   * Stok_bahanCountOutputType without action
   */
  export type Stok_bahanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stok_bahanCountOutputType
     */
    select?: Stok_bahanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Stok_bahanCountOutputType without action
   */
  export type Stok_bahanCountOutputTypeCountBahan_produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bahan_produksiWhereInput
  }


  /**
   * Stok_bahanCountOutputType without action
   */
  export type Stok_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_bahanWhereInput
  }


  /**
   * Stok_bahanCountOutputType without action
   */
  export type Stok_bahanCountOutputTypeCountDetail_pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pemesanan_bahanWhereInput
  }



  /**
   * Count Type Pengecekan_produkCountOutputType
   */

  export type Pengecekan_produkCountOutputType = {
    detail_pengecekan_produk: number
  }

  export type Pengecekan_produkCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_produk?: boolean | Pengecekan_produkCountOutputTypeCountDetail_pengecekan_produkArgs
  }

  // Custom InputTypes

  /**
   * Pengecekan_produkCountOutputType without action
   */
  export type Pengecekan_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengecekan_produkCountOutputType
     */
    select?: Pengecekan_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Pengecekan_produkCountOutputType without action
   */
  export type Pengecekan_produkCountOutputTypeCountDetail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_produkWhereInput
  }



  /**
   * Count Type Kondisi_produkCountOutputType
   */

  export type Kondisi_produkCountOutputType = {
    detail_pengecekan_produk: number
  }

  export type Kondisi_produkCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_produk?: boolean | Kondisi_produkCountOutputTypeCountDetail_pengecekan_produkArgs
  }

  // Custom InputTypes

  /**
   * Kondisi_produkCountOutputType without action
   */
  export type Kondisi_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kondisi_produkCountOutputType
     */
    select?: Kondisi_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Kondisi_produkCountOutputType without action
   */
  export type Kondisi_produkCountOutputTypeCountDetail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_produkWhereInput
  }



  /**
   * Count Type Pengecekan_bahanCountOutputType
   */

  export type Pengecekan_bahanCountOutputType = {
    detail_pengecekan_bahan: number
  }

  export type Pengecekan_bahanCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_bahan?: boolean | Pengecekan_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs
  }

  // Custom InputTypes

  /**
   * Pengecekan_bahanCountOutputType without action
   */
  export type Pengecekan_bahanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengecekan_bahanCountOutputType
     */
    select?: Pengecekan_bahanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Pengecekan_bahanCountOutputType without action
   */
  export type Pengecekan_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_bahanWhereInput
  }



  /**
   * Count Type Kondisi_bahanCountOutputType
   */

  export type Kondisi_bahanCountOutputType = {
    detail_pengecekan_bahan: number
  }

  export type Kondisi_bahanCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_bahan?: boolean | Kondisi_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs
  }

  // Custom InputTypes

  /**
   * Kondisi_bahanCountOutputType without action
   */
  export type Kondisi_bahanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kondisi_bahanCountOutputType
     */
    select?: Kondisi_bahanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Kondisi_bahanCountOutputType without action
   */
  export type Kondisi_bahanCountOutputTypeCountDetail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_bahanWhereInput
  }



  /**
   * Count Type Pemesanan_bahanCountOutputType
   */

  export type Pemesanan_bahanCountOutputType = {
    detail_pemesanan_bahan: number
  }

  export type Pemesanan_bahanCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pemesanan_bahan?: boolean | Pemesanan_bahanCountOutputTypeCountDetail_pemesanan_bahanArgs
  }

  // Custom InputTypes

  /**
   * Pemesanan_bahanCountOutputType without action
   */
  export type Pemesanan_bahanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemesanan_bahanCountOutputType
     */
    select?: Pemesanan_bahanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Pemesanan_bahanCountOutputType without action
   */
  export type Pemesanan_bahanCountOutputTypeCountDetail_pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pemesanan_bahanWhereInput
  }



  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    pemesanan_bahan: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pemesanan_bahan?: boolean | SupplierCountOutputTypeCountPemesanan_bahanArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pemesanan_bahanWhereInput
  }



  /**
   * Count Type GawanganCountOutputType
   */

  export type GawanganCountOutputType = {
    detail_gawangans: number
    detail_pembelian_produk: number
  }

  export type GawanganCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_gawangans?: boolean | GawanganCountOutputTypeCountDetail_gawangansArgs
    detail_pembelian_produk?: boolean | GawanganCountOutputTypeCountDetail_pembelian_produkArgs
  }

  // Custom InputTypes

  /**
   * GawanganCountOutputType without action
   */
  export type GawanganCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GawanganCountOutputType
     */
    select?: GawanganCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GawanganCountOutputType without action
   */
  export type GawanganCountOutputTypeCountDetail_gawangansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_gawanganWhereInput
  }


  /**
   * GawanganCountOutputType without action
   */
  export type GawanganCountOutputTypeCountDetail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pembelian_produkWhereInput
  }



  /**
   * Count Type OutletCountOutputType
   */

  export type OutletCountOutputType = {
    gawangan: number
  }

  export type OutletCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gawangan?: boolean | OutletCountOutputTypeCountGawanganArgs
  }

  // Custom InputTypes

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletCountOutputType
     */
    select?: OutletCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountGawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gawanganWhereInput
  }



  /**
   * Count Type Pembelian_produkCountOutputType
   */

  export type Pembelian_produkCountOutputType = {
    detail_diskon: number
    detail_pembelian_produk: number
  }

  export type Pembelian_produkCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_diskon?: boolean | Pembelian_produkCountOutputTypeCountDetail_diskonArgs
    detail_pembelian_produk?: boolean | Pembelian_produkCountOutputTypeCountDetail_pembelian_produkArgs
  }

  // Custom InputTypes

  /**
   * Pembelian_produkCountOutputType without action
   */
  export type Pembelian_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian_produkCountOutputType
     */
    select?: Pembelian_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Pembelian_produkCountOutputType without action
   */
  export type Pembelian_produkCountOutputTypeCountDetail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_diskonWhereInput
  }


  /**
   * Pembelian_produkCountOutputType without action
   */
  export type Pembelian_produkCountOutputTypeCountDetail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pembelian_produkWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    pembelian_produk: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembelian_produk?: boolean | UserCountOutputTypeCountPembelian_produkArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pembelian_produkWhereInput
  }



  /**
   * Count Type DiskonCountOutputType
   */

  export type DiskonCountOutputType = {
    detail_pembelian_produk: number
    detail_diskon: number
  }

  export type DiskonCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pembelian_produk?: boolean | DiskonCountOutputTypeCountDetail_pembelian_produkArgs
    detail_diskon?: boolean | DiskonCountOutputTypeCountDetail_diskonArgs
  }

  // Custom InputTypes

  /**
   * DiskonCountOutputType without action
   */
  export type DiskonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiskonCountOutputType
     */
    select?: DiskonCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DiskonCountOutputType without action
   */
  export type DiskonCountOutputTypeCountDetail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pembelian_produkWhereInput
  }


  /**
   * DiskonCountOutputType without action
   */
  export type DiskonCountOutputTypeCountDetail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_diskonWhereInput
  }



  /**
   * Models
   */

  /**
   * Model produk_item
   */

  export type AggregateProduk_item = {
    _count: Produk_itemCountAggregateOutputType | null
    _avg: Produk_itemAvgAggregateOutputType | null
    _sum: Produk_itemSumAggregateOutputType | null
    _min: Produk_itemMinAggregateOutputType | null
    _max: Produk_itemMaxAggregateOutputType | null
  }

  export type Produk_itemAvgAggregateOutputType = {
    id: number | null
    stok: number | null
    harga_jual: number | null
    produksi_id: number | null
  }

  export type Produk_itemSumAggregateOutputType = {
    id: number | null
    stok: number | null
    harga_jual: number | null
    produksi_id: number | null
  }

  export type Produk_itemMinAggregateOutputType = {
    id: number | null
    kode_produk: string | null
    sku: string | null
    nama_produk: string | null
    stok: number | null
    harga_jual: number | null
    produksi_id: number | null
  }

  export type Produk_itemMaxAggregateOutputType = {
    id: number | null
    kode_produk: string | null
    sku: string | null
    nama_produk: string | null
    stok: number | null
    harga_jual: number | null
    produksi_id: number | null
  }

  export type Produk_itemCountAggregateOutputType = {
    id: number
    kode_produk: number
    sku: number
    nama_produk: number
    stok: number
    harga_jual: number
    produksi_id: number
    _all: number
  }


  export type Produk_itemAvgAggregateInputType = {
    id?: true
    stok?: true
    harga_jual?: true
    produksi_id?: true
  }

  export type Produk_itemSumAggregateInputType = {
    id?: true
    stok?: true
    harga_jual?: true
    produksi_id?: true
  }

  export type Produk_itemMinAggregateInputType = {
    id?: true
    kode_produk?: true
    sku?: true
    nama_produk?: true
    stok?: true
    harga_jual?: true
    produksi_id?: true
  }

  export type Produk_itemMaxAggregateInputType = {
    id?: true
    kode_produk?: true
    sku?: true
    nama_produk?: true
    stok?: true
    harga_jual?: true
    produksi_id?: true
  }

  export type Produk_itemCountAggregateInputType = {
    id?: true
    kode_produk?: true
    sku?: true
    nama_produk?: true
    stok?: true
    harga_jual?: true
    produksi_id?: true
    _all?: true
  }

  export type Produk_itemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produk_item to aggregate.
     */
    where?: produk_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_items to fetch.
     */
    orderBy?: produk_itemOrderByWithRelationInput | produk_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produk_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produk_items
    **/
    _count?: true | Produk_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Produk_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Produk_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Produk_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Produk_itemMaxAggregateInputType
  }

  export type GetProduk_itemAggregateType<T extends Produk_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateProduk_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduk_item[P]>
      : GetScalarType<T[P], AggregateProduk_item[P]>
  }




  export type produk_itemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produk_itemWhereInput
    orderBy?: produk_itemOrderByWithAggregationInput | produk_itemOrderByWithAggregationInput[]
    by: Produk_itemScalarFieldEnum[] | Produk_itemScalarFieldEnum
    having?: produk_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Produk_itemCountAggregateInputType | true
    _avg?: Produk_itemAvgAggregateInputType
    _sum?: Produk_itemSumAggregateInputType
    _min?: Produk_itemMinAggregateInputType
    _max?: Produk_itemMaxAggregateInputType
  }

  export type Produk_itemGroupByOutputType = {
    id: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    _count: Produk_itemCountAggregateOutputType | null
    _avg: Produk_itemAvgAggregateOutputType | null
    _sum: Produk_itemSumAggregateOutputType | null
    _min: Produk_itemMinAggregateOutputType | null
    _max: Produk_itemMaxAggregateOutputType | null
  }

  type GetProduk_itemGroupByPayload<T extends produk_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Produk_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Produk_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Produk_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Produk_itemGroupByOutputType[P]>
        }
      >
    >


  export type produk_itemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_produk?: boolean
    sku?: boolean
    nama_produk?: boolean
    stok?: boolean
    harga_jual?: boolean
    produksi_id?: boolean
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
    detail_diskon?: boolean | produk_item$detail_diskonArgs<ExtArgs>
    detail_pengecekan_produk?: boolean | produk_item$detail_pengecekan_produkArgs<ExtArgs>
    detail_gawangan?: boolean | produk_item$detail_gawanganArgs<ExtArgs>
    detail_pembelian_produk?: boolean | produk_item$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | Produk_itemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produk_item"]>

  export type produk_itemSelectScalar = {
    id?: boolean
    kode_produk?: boolean
    sku?: boolean
    nama_produk?: boolean
    stok?: boolean
    harga_jual?: boolean
    produksi_id?: boolean
  }

  export type produk_itemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
    detail_diskon?: boolean | produk_item$detail_diskonArgs<ExtArgs>
    detail_pengecekan_produk?: boolean | produk_item$detail_pengecekan_produkArgs<ExtArgs>
    detail_gawangan?: boolean | produk_item$detail_gawanganArgs<ExtArgs>
    detail_pembelian_produk?: boolean | produk_item$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | Produk_itemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $produk_itemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "produk_item"
    objects: {
      produksi: Prisma.$produksiPayload<ExtArgs>
      detail_diskon: Prisma.$detail_diskonPayload<ExtArgs>[]
      detail_pengecekan_produk: Prisma.$detail_pengecekan_produkPayload<ExtArgs>[]
      detail_gawangan: Prisma.$detail_gawanganPayload<ExtArgs>[]
      detail_pembelian_produk: Prisma.$detail_pembelian_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      kode_produk: string
      sku: string
      nama_produk: string
      stok: number
      harga_jual: number
      produksi_id: number
    }, ExtArgs["result"]["produk_item"]>
    composites: {}
  }


  type produk_itemGetPayload<S extends boolean | null | undefined | produk_itemDefaultArgs> = $Result.GetResult<Prisma.$produk_itemPayload, S>

  type produk_itemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<produk_itemFindManyArgs, 'select' | 'include'> & {
      select?: Produk_itemCountAggregateInputType | true
    }

  export interface produk_itemDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produk_item'], meta: { name: 'produk_item' } }
    /**
     * Find zero or one Produk_item that matches the filter.
     * @param {produk_itemFindUniqueArgs} args - Arguments to find a Produk_item
     * @example
     * // Get one Produk_item
     * const produk_item = await prisma.produk_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends produk_itemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemFindUniqueArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Produk_item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {produk_itemFindUniqueOrThrowArgs} args - Arguments to find a Produk_item
     * @example
     * // Get one Produk_item
     * const produk_item = await prisma.produk_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends produk_itemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Produk_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemFindFirstArgs} args - Arguments to find a Produk_item
     * @example
     * // Get one Produk_item
     * const produk_item = await prisma.produk_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends produk_itemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemFindFirstArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Produk_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemFindFirstOrThrowArgs} args - Arguments to find a Produk_item
     * @example
     * // Get one Produk_item
     * const produk_item = await prisma.produk_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends produk_itemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Produk_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produk_items
     * const produk_items = await prisma.produk_item.findMany()
     * 
     * // Get first 10 Produk_items
     * const produk_items = await prisma.produk_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produk_itemWithIdOnly = await prisma.produk_item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends produk_itemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Produk_item.
     * @param {produk_itemCreateArgs} args - Arguments to create a Produk_item.
     * @example
     * // Create one Produk_item
     * const Produk_item = await prisma.produk_item.create({
     *   data: {
     *     // ... data to create a Produk_item
     *   }
     * })
     * 
    **/
    create<T extends produk_itemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemCreateArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Produk_items.
     *     @param {produk_itemCreateManyArgs} args - Arguments to create many Produk_items.
     *     @example
     *     // Create many Produk_items
     *     const produk_item = await prisma.produk_item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends produk_itemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produk_item.
     * @param {produk_itemDeleteArgs} args - Arguments to delete one Produk_item.
     * @example
     * // Delete one Produk_item
     * const Produk_item = await prisma.produk_item.delete({
     *   where: {
     *     // ... filter to delete one Produk_item
     *   }
     * })
     * 
    **/
    delete<T extends produk_itemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemDeleteArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Produk_item.
     * @param {produk_itemUpdateArgs} args - Arguments to update one Produk_item.
     * @example
     * // Update one Produk_item
     * const produk_item = await prisma.produk_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends produk_itemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemUpdateArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Produk_items.
     * @param {produk_itemDeleteManyArgs} args - Arguments to filter Produk_items to delete.
     * @example
     * // Delete a few Produk_items
     * const { count } = await prisma.produk_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends produk_itemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produk_itemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produk_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produk_items
     * const produk_item = await prisma.produk_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends produk_itemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produk_item.
     * @param {produk_itemUpsertArgs} args - Arguments to update or create a Produk_item.
     * @example
     * // Update or create a Produk_item
     * const produk_item = await prisma.produk_item.upsert({
     *   create: {
     *     // ... data to create a Produk_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produk_item we want to update
     *   }
     * })
    **/
    upsert<T extends produk_itemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, produk_itemUpsertArgs<ExtArgs>>
    ): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Produk_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemCountArgs} args - Arguments to filter Produk_items to count.
     * @example
     * // Count the number of Produk_items
     * const count = await prisma.produk_item.count({
     *   where: {
     *     // ... the filter for the Produk_items we want to count
     *   }
     * })
    **/
    count<T extends produk_itemCountArgs>(
      args?: Subset<T, produk_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Produk_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produk_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Produk_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Produk_itemAggregateArgs>(args: Subset<T, Produk_itemAggregateArgs>): Prisma.PrismaPromise<GetProduk_itemAggregateType<T>>

    /**
     * Group by Produk_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produk_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produk_itemGroupByArgs['orderBy'] }
        : { orderBy?: produk_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produk_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduk_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produk_item model
   */
  readonly fields: produk_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produk_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produk_itemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produksi<T extends produksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produksiDefaultArgs<ExtArgs>>): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detail_diskon<T extends produk_item$detail_diskonArgs<ExtArgs> = {}>(args?: Subset<T, produk_item$detail_diskonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pengecekan_produk<T extends produk_item$detail_pengecekan_produkArgs<ExtArgs> = {}>(args?: Subset<T, produk_item$detail_pengecekan_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_gawangan<T extends produk_item$detail_gawanganArgs<ExtArgs> = {}>(args?: Subset<T, produk_item$detail_gawanganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pembelian_produk<T extends produk_item$detail_pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, produk_item$detail_pembelian_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the produk_item model
   */ 
  interface produk_itemFieldRefs {
    readonly id: FieldRef<"produk_item", 'Int'>
    readonly kode_produk: FieldRef<"produk_item", 'String'>
    readonly sku: FieldRef<"produk_item", 'String'>
    readonly nama_produk: FieldRef<"produk_item", 'String'>
    readonly stok: FieldRef<"produk_item", 'Int'>
    readonly harga_jual: FieldRef<"produk_item", 'Float'>
    readonly produksi_id: FieldRef<"produk_item", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * produk_item findUnique
   */
  export type produk_itemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter, which produk_item to fetch.
     */
    where: produk_itemWhereUniqueInput
  }


  /**
   * produk_item findUniqueOrThrow
   */
  export type produk_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter, which produk_item to fetch.
     */
    where: produk_itemWhereUniqueInput
  }


  /**
   * produk_item findFirst
   */
  export type produk_itemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter, which produk_item to fetch.
     */
    where?: produk_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_items to fetch.
     */
    orderBy?: produk_itemOrderByWithRelationInput | produk_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produk_items.
     */
    cursor?: produk_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produk_items.
     */
    distinct?: Produk_itemScalarFieldEnum | Produk_itemScalarFieldEnum[]
  }


  /**
   * produk_item findFirstOrThrow
   */
  export type produk_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter, which produk_item to fetch.
     */
    where?: produk_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_items to fetch.
     */
    orderBy?: produk_itemOrderByWithRelationInput | produk_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produk_items.
     */
    cursor?: produk_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produk_items.
     */
    distinct?: Produk_itemScalarFieldEnum | Produk_itemScalarFieldEnum[]
  }


  /**
   * produk_item findMany
   */
  export type produk_itemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter, which produk_items to fetch.
     */
    where?: produk_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_items to fetch.
     */
    orderBy?: produk_itemOrderByWithRelationInput | produk_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produk_items.
     */
    cursor?: produk_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_items.
     */
    skip?: number
    distinct?: Produk_itemScalarFieldEnum | Produk_itemScalarFieldEnum[]
  }


  /**
   * produk_item create
   */
  export type produk_itemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a produk_item.
     */
    data: XOR<produk_itemCreateInput, produk_itemUncheckedCreateInput>
  }


  /**
   * produk_item createMany
   */
  export type produk_itemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produk_items.
     */
    data: produk_itemCreateManyInput | produk_itemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * produk_item update
   */
  export type produk_itemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a produk_item.
     */
    data: XOR<produk_itemUpdateInput, produk_itemUncheckedUpdateInput>
    /**
     * Choose, which produk_item to update.
     */
    where: produk_itemWhereUniqueInput
  }


  /**
   * produk_item updateMany
   */
  export type produk_itemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produk_items.
     */
    data: XOR<produk_itemUpdateManyMutationInput, produk_itemUncheckedUpdateManyInput>
    /**
     * Filter which produk_items to update
     */
    where?: produk_itemWhereInput
  }


  /**
   * produk_item upsert
   */
  export type produk_itemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the produk_item to update in case it exists.
     */
    where: produk_itemWhereUniqueInput
    /**
     * In case the produk_item found by the `where` argument doesn't exist, create a new produk_item with this data.
     */
    create: XOR<produk_itemCreateInput, produk_itemUncheckedCreateInput>
    /**
     * In case the produk_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produk_itemUpdateInput, produk_itemUncheckedUpdateInput>
  }


  /**
   * produk_item delete
   */
  export type produk_itemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    /**
     * Filter which produk_item to delete.
     */
    where: produk_itemWhereUniqueInput
  }


  /**
   * produk_item deleteMany
   */
  export type produk_itemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produk_items to delete
     */
    where?: produk_itemWhereInput
  }


  /**
   * produk_item.detail_diskon
   */
  export type produk_item$detail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    where?: detail_diskonWhereInput
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    cursor?: detail_diskonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * produk_item.detail_pengecekan_produk
   */
  export type produk_item$detail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    where?: detail_pengecekan_produkWhereInput
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    cursor?: detail_pengecekan_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * produk_item.detail_gawangan
   */
  export type produk_item$detail_gawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    where?: detail_gawanganWhereInput
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    cursor?: detail_gawanganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_gawanganScalarFieldEnum | Detail_gawanganScalarFieldEnum[]
  }


  /**
   * produk_item.detail_pembelian_produk
   */
  export type produk_item$detail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    where?: detail_pembelian_produkWhereInput
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    cursor?: detail_pembelian_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * produk_item without action
   */
  export type produk_itemDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
  }



  /**
   * Model produksi
   */

  export type AggregateProduksi = {
    _count: ProduksiCountAggregateOutputType | null
    _avg: ProduksiAvgAggregateOutputType | null
    _sum: ProduksiSumAggregateOutputType | null
    _min: ProduksiMinAggregateOutputType | null
    _max: ProduksiMaxAggregateOutputType | null
  }

  export type ProduksiAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
    biaya: number | null
    pembuat_id: number | null
    kategori_produk_id: number | null
  }

  export type ProduksiSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
    biaya: number | null
    pembuat_id: number | null
    kategori_produk_id: number | null
  }

  export type ProduksiMinAggregateOutputType = {
    id: number | null
    mulai: Date | null
    selesai: Date | null
    kode_produk: string | null
    jumlah: number | null
    ukuran: string | null
    warna: string | null
    biaya: number | null
    pembuat_id: number | null
    kategori_produk_id: number | null
  }

  export type ProduksiMaxAggregateOutputType = {
    id: number | null
    mulai: Date | null
    selesai: Date | null
    kode_produk: string | null
    jumlah: number | null
    ukuran: string | null
    warna: string | null
    biaya: number | null
    pembuat_id: number | null
    kategori_produk_id: number | null
  }

  export type ProduksiCountAggregateOutputType = {
    id: number
    mulai: number
    selesai: number
    kode_produk: number
    jumlah: number
    ukuran: number
    warna: number
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
    _all: number
  }


  export type ProduksiAvgAggregateInputType = {
    id?: true
    jumlah?: true
    biaya?: true
    pembuat_id?: true
    kategori_produk_id?: true
  }

  export type ProduksiSumAggregateInputType = {
    id?: true
    jumlah?: true
    biaya?: true
    pembuat_id?: true
    kategori_produk_id?: true
  }

  export type ProduksiMinAggregateInputType = {
    id?: true
    mulai?: true
    selesai?: true
    kode_produk?: true
    jumlah?: true
    ukuran?: true
    warna?: true
    biaya?: true
    pembuat_id?: true
    kategori_produk_id?: true
  }

  export type ProduksiMaxAggregateInputType = {
    id?: true
    mulai?: true
    selesai?: true
    kode_produk?: true
    jumlah?: true
    ukuran?: true
    warna?: true
    biaya?: true
    pembuat_id?: true
    kategori_produk_id?: true
  }

  export type ProduksiCountAggregateInputType = {
    id?: true
    mulai?: true
    selesai?: true
    kode_produk?: true
    jumlah?: true
    ukuran?: true
    warna?: true
    biaya?: true
    pembuat_id?: true
    kategori_produk_id?: true
    _all?: true
  }

  export type ProduksiAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produksi to aggregate.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produksis
    **/
    _count?: true | ProduksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduksiMaxAggregateInputType
  }

  export type GetProduksiAggregateType<T extends ProduksiAggregateArgs> = {
        [P in keyof T & keyof AggregateProduksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduksi[P]>
      : GetScalarType<T[P], AggregateProduksi[P]>
  }




  export type produksiGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithAggregationInput | produksiOrderByWithAggregationInput[]
    by: ProduksiScalarFieldEnum[] | ProduksiScalarFieldEnum
    having?: produksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduksiCountAggregateInputType | true
    _avg?: ProduksiAvgAggregateInputType
    _sum?: ProduksiSumAggregateInputType
    _min?: ProduksiMinAggregateInputType
    _max?: ProduksiMaxAggregateInputType
  }

  export type ProduksiGroupByOutputType = {
    id: number
    mulai: Date
    selesai: Date
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
    _count: ProduksiCountAggregateOutputType | null
    _avg: ProduksiAvgAggregateOutputType | null
    _sum: ProduksiSumAggregateOutputType | null
    _min: ProduksiMinAggregateOutputType | null
    _max: ProduksiMaxAggregateOutputType | null
  }

  type GetProduksiGroupByPayload<T extends produksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduksiGroupByOutputType[P]>
            : GetScalarType<T[P], ProduksiGroupByOutputType[P]>
        }
      >
    >


  export type produksiSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mulai?: boolean
    selesai?: boolean
    kode_produk?: boolean
    jumlah?: boolean
    ukuran?: boolean
    warna?: boolean
    biaya?: boolean
    pembuat_id?: boolean
    kategori_produk_id?: boolean
    pembuat?: boolean | pembuatDefaultArgs<ExtArgs>
    kategori_produk?: boolean | kategori_produkDefaultArgs<ExtArgs>
    produk_item?: boolean | produksi$produk_itemArgs<ExtArgs>
    bahan_produksi?: boolean | produksi$bahan_produksiArgs<ExtArgs>
    _count?: boolean | ProduksiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produksi"]>

  export type produksiSelectScalar = {
    id?: boolean
    mulai?: boolean
    selesai?: boolean
    kode_produk?: boolean
    jumlah?: boolean
    ukuran?: boolean
    warna?: boolean
    biaya?: boolean
    pembuat_id?: boolean
    kategori_produk_id?: boolean
  }

  export type produksiInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembuat?: boolean | pembuatDefaultArgs<ExtArgs>
    kategori_produk?: boolean | kategori_produkDefaultArgs<ExtArgs>
    produk_item?: boolean | produksi$produk_itemArgs<ExtArgs>
    bahan_produksi?: boolean | produksi$bahan_produksiArgs<ExtArgs>
    _count?: boolean | ProduksiCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $produksiPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "produksi"
    objects: {
      pembuat: Prisma.$pembuatPayload<ExtArgs>
      kategori_produk: Prisma.$kategori_produkPayload<ExtArgs>
      produk_item: Prisma.$produk_itemPayload<ExtArgs>[]
      bahan_produksi: Prisma.$bahan_produksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      mulai: Date
      selesai: Date
      kode_produk: string
      jumlah: number
      ukuran: string
      warna: string
      biaya: number
      pembuat_id: number
      kategori_produk_id: number
    }, ExtArgs["result"]["produksi"]>
    composites: {}
  }


  type produksiGetPayload<S extends boolean | null | undefined | produksiDefaultArgs> = $Result.GetResult<Prisma.$produksiPayload, S>

  type produksiCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<produksiFindManyArgs, 'select' | 'include'> & {
      select?: ProduksiCountAggregateInputType | true
    }

  export interface produksiDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produksi'], meta: { name: 'produksi' } }
    /**
     * Find zero or one Produksi that matches the filter.
     * @param {produksiFindUniqueArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends produksiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, produksiFindUniqueArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Produksi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {produksiFindUniqueOrThrowArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends produksiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Produksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindFirstArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends produksiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindFirstArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Produksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindFirstOrThrowArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends produksiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Produksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produksis
     * const produksis = await prisma.produksi.findMany()
     * 
     * // Get first 10 Produksis
     * const produksis = await prisma.produksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produksiWithIdOnly = await prisma.produksi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends produksiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Produksi.
     * @param {produksiCreateArgs} args - Arguments to create a Produksi.
     * @example
     * // Create one Produksi
     * const Produksi = await prisma.produksi.create({
     *   data: {
     *     // ... data to create a Produksi
     *   }
     * })
     * 
    **/
    create<T extends produksiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, produksiCreateArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Produksis.
     *     @param {produksiCreateManyArgs} args - Arguments to create many Produksis.
     *     @example
     *     // Create many Produksis
     *     const produksi = await prisma.produksi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends produksiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produksi.
     * @param {produksiDeleteArgs} args - Arguments to delete one Produksi.
     * @example
     * // Delete one Produksi
     * const Produksi = await prisma.produksi.delete({
     *   where: {
     *     // ... filter to delete one Produksi
     *   }
     * })
     * 
    **/
    delete<T extends produksiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, produksiDeleteArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Produksi.
     * @param {produksiUpdateArgs} args - Arguments to update one Produksi.
     * @example
     * // Update one Produksi
     * const produksi = await prisma.produksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends produksiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpdateArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Produksis.
     * @param {produksiDeleteManyArgs} args - Arguments to filter Produksis to delete.
     * @example
     * // Delete a few Produksis
     * const { count } = await prisma.produksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends produksiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produksis
     * const produksi = await prisma.produksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends produksiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produksi.
     * @param {produksiUpsertArgs} args - Arguments to update or create a Produksi.
     * @example
     * // Update or create a Produksi
     * const produksi = await prisma.produksi.upsert({
     *   create: {
     *     // ... data to create a Produksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produksi we want to update
     *   }
     * })
    **/
    upsert<T extends produksiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpsertArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiCountArgs} args - Arguments to filter Produksis to count.
     * @example
     * // Count the number of Produksis
     * const count = await prisma.produksi.count({
     *   where: {
     *     // ... the filter for the Produksis we want to count
     *   }
     * })
    **/
    count<T extends produksiCountArgs>(
      args?: Subset<T, produksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduksiAggregateArgs>(args: Subset<T, ProduksiAggregateArgs>): Prisma.PrismaPromise<GetProduksiAggregateType<T>>

    /**
     * Group by Produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produksiGroupByArgs['orderBy'] }
        : { orderBy?: produksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produksi model
   */
  readonly fields: produksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produksiClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pembuat<T extends pembuatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pembuatDefaultArgs<ExtArgs>>): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    kategori_produk<T extends kategori_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategori_produkDefaultArgs<ExtArgs>>): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produk_item<T extends produksi$produk_itemArgs<ExtArgs> = {}>(args?: Subset<T, produksi$produk_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findMany'> | Null>;

    bahan_produksi<T extends produksi$bahan_produksiArgs<ExtArgs> = {}>(args?: Subset<T, produksi$bahan_produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the produksi model
   */ 
  interface produksiFieldRefs {
    readonly id: FieldRef<"produksi", 'Int'>
    readonly mulai: FieldRef<"produksi", 'DateTime'>
    readonly selesai: FieldRef<"produksi", 'DateTime'>
    readonly kode_produk: FieldRef<"produksi", 'String'>
    readonly jumlah: FieldRef<"produksi", 'Int'>
    readonly ukuran: FieldRef<"produksi", 'String'>
    readonly warna: FieldRef<"produksi", 'String'>
    readonly biaya: FieldRef<"produksi", 'Float'>
    readonly pembuat_id: FieldRef<"produksi", 'Int'>
    readonly kategori_produk_id: FieldRef<"produksi", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * produksi findUnique
   */
  export type produksiFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi findUniqueOrThrow
   */
  export type produksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi findFirst
   */
  export type produksiFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produksis.
     */
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi findFirstOrThrow
   */
  export type produksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produksis.
     */
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi findMany
   */
  export type produksiFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksis to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi create
   */
  export type produksiCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The data needed to create a produksi.
     */
    data: XOR<produksiCreateInput, produksiUncheckedCreateInput>
  }


  /**
   * produksi createMany
   */
  export type produksiCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produksis.
     */
    data: produksiCreateManyInput | produksiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * produksi update
   */
  export type produksiUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The data needed to update a produksi.
     */
    data: XOR<produksiUpdateInput, produksiUncheckedUpdateInput>
    /**
     * Choose, which produksi to update.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi updateMany
   */
  export type produksiUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produksis.
     */
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyInput>
    /**
     * Filter which produksis to update
     */
    where?: produksiWhereInput
  }


  /**
   * produksi upsert
   */
  export type produksiUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The filter to search for the produksi to update in case it exists.
     */
    where: produksiWhereUniqueInput
    /**
     * In case the produksi found by the `where` argument doesn't exist, create a new produksi with this data.
     */
    create: XOR<produksiCreateInput, produksiUncheckedCreateInput>
    /**
     * In case the produksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produksiUpdateInput, produksiUncheckedUpdateInput>
  }


  /**
   * produksi delete
   */
  export type produksiDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter which produksi to delete.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi deleteMany
   */
  export type produksiDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produksis to delete
     */
    where?: produksiWhereInput
  }


  /**
   * produksi.produk_item
   */
  export type produksi$produk_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    where?: produk_itemWhereInput
    orderBy?: produk_itemOrderByWithRelationInput | produk_itemOrderByWithRelationInput[]
    cursor?: produk_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Produk_itemScalarFieldEnum | Produk_itemScalarFieldEnum[]
  }


  /**
   * produksi.bahan_produksi
   */
  export type produksi$bahan_produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    where?: bahan_produksiWhereInput
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    cursor?: bahan_produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bahan_produksiScalarFieldEnum | Bahan_produksiScalarFieldEnum[]
  }


  /**
   * produksi without action
   */
  export type produksiDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
  }



  /**
   * Model kategori_produk
   */

  export type AggregateKategori_produk = {
    _count: Kategori_produkCountAggregateOutputType | null
    _avg: Kategori_produkAvgAggregateOutputType | null
    _sum: Kategori_produkSumAggregateOutputType | null
    _min: Kategori_produkMinAggregateOutputType | null
    _max: Kategori_produkMaxAggregateOutputType | null
  }

  export type Kategori_produkAvgAggregateOutputType = {
    id: number | null
  }

  export type Kategori_produkSumAggregateOutputType = {
    id: number | null
  }

  export type Kategori_produkMinAggregateOutputType = {
    id: number | null
    kategori: string | null
  }

  export type Kategori_produkMaxAggregateOutputType = {
    id: number | null
    kategori: string | null
  }

  export type Kategori_produkCountAggregateOutputType = {
    id: number
    kategori: number
    _all: number
  }


  export type Kategori_produkAvgAggregateInputType = {
    id?: true
  }

  export type Kategori_produkSumAggregateInputType = {
    id?: true
  }

  export type Kategori_produkMinAggregateInputType = {
    id?: true
    kategori?: true
  }

  export type Kategori_produkMaxAggregateInputType = {
    id?: true
    kategori?: true
  }

  export type Kategori_produkCountAggregateInputType = {
    id?: true
    kategori?: true
    _all?: true
  }

  export type Kategori_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategori_produk to aggregate.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategori_produks
    **/
    _count?: true | Kategori_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kategori_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kategori_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kategori_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kategori_produkMaxAggregateInputType
  }

  export type GetKategori_produkAggregateType<T extends Kategori_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateKategori_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategori_produk[P]>
      : GetScalarType<T[P], AggregateKategori_produk[P]>
  }




  export type kategori_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: kategori_produkWhereInput
    orderBy?: kategori_produkOrderByWithAggregationInput | kategori_produkOrderByWithAggregationInput[]
    by: Kategori_produkScalarFieldEnum[] | Kategori_produkScalarFieldEnum
    having?: kategori_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kategori_produkCountAggregateInputType | true
    _avg?: Kategori_produkAvgAggregateInputType
    _sum?: Kategori_produkSumAggregateInputType
    _min?: Kategori_produkMinAggregateInputType
    _max?: Kategori_produkMaxAggregateInputType
  }

  export type Kategori_produkGroupByOutputType = {
    id: number
    kategori: string
    _count: Kategori_produkCountAggregateOutputType | null
    _avg: Kategori_produkAvgAggregateOutputType | null
    _sum: Kategori_produkSumAggregateOutputType | null
    _min: Kategori_produkMinAggregateOutputType | null
    _max: Kategori_produkMaxAggregateOutputType | null
  }

  type GetKategori_produkGroupByPayload<T extends kategori_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kategori_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kategori_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kategori_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Kategori_produkGroupByOutputType[P]>
        }
      >
    >


  export type kategori_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kategori?: boolean
    produksi?: boolean | kategori_produk$produksiArgs<ExtArgs>
    _count?: boolean | Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategori_produk"]>

  export type kategori_produkSelectScalar = {
    id?: boolean
    kategori?: boolean
  }

  export type kategori_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | kategori_produk$produksiArgs<ExtArgs>
    _count?: boolean | Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $kategori_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "kategori_produk"
    objects: {
      produksi: Prisma.$produksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      kategori: string
    }, ExtArgs["result"]["kategori_produk"]>
    composites: {}
  }


  type kategori_produkGetPayload<S extends boolean | null | undefined | kategori_produkDefaultArgs> = $Result.GetResult<Prisma.$kategori_produkPayload, S>

  type kategori_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<kategori_produkFindManyArgs, 'select' | 'include'> & {
      select?: Kategori_produkCountAggregateInputType | true
    }

  export interface kategori_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategori_produk'], meta: { name: 'kategori_produk' } }
    /**
     * Find zero or one Kategori_produk that matches the filter.
     * @param {kategori_produkFindUniqueArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kategori_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Kategori_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kategori_produkFindUniqueOrThrowArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kategori_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Kategori_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindFirstArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kategori_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindFirstArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Kategori_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindFirstOrThrowArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kategori_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Kategori_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kategori_produks
     * const kategori_produks = await prisma.kategori_produk.findMany()
     * 
     * // Get first 10 Kategori_produks
     * const kategori_produks = await prisma.kategori_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kategori_produkWithIdOnly = await prisma.kategori_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kategori_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Kategori_produk.
     * @param {kategori_produkCreateArgs} args - Arguments to create a Kategori_produk.
     * @example
     * // Create one Kategori_produk
     * const Kategori_produk = await prisma.kategori_produk.create({
     *   data: {
     *     // ... data to create a Kategori_produk
     *   }
     * })
     * 
    **/
    create<T extends kategori_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkCreateArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Kategori_produks.
     *     @param {kategori_produkCreateManyArgs} args - Arguments to create many Kategori_produks.
     *     @example
     *     // Create many Kategori_produks
     *     const kategori_produk = await prisma.kategori_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kategori_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kategori_produk.
     * @param {kategori_produkDeleteArgs} args - Arguments to delete one Kategori_produk.
     * @example
     * // Delete one Kategori_produk
     * const Kategori_produk = await prisma.kategori_produk.delete({
     *   where: {
     *     // ... filter to delete one Kategori_produk
     *   }
     * })
     * 
    **/
    delete<T extends kategori_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkDeleteArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Kategori_produk.
     * @param {kategori_produkUpdateArgs} args - Arguments to update one Kategori_produk.
     * @example
     * // Update one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kategori_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpdateArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Kategori_produks.
     * @param {kategori_produkDeleteManyArgs} args - Arguments to filter Kategori_produks to delete.
     * @example
     * // Delete a few Kategori_produks
     * const { count } = await prisma.kategori_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kategori_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategori_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kategori_produks
     * const kategori_produk = await prisma.kategori_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kategori_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kategori_produk.
     * @param {kategori_produkUpsertArgs} args - Arguments to update or create a Kategori_produk.
     * @example
     * // Update or create a Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.upsert({
     *   create: {
     *     // ... data to create a Kategori_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kategori_produk we want to update
     *   }
     * })
    **/
    upsert<T extends kategori_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpsertArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Kategori_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkCountArgs} args - Arguments to filter Kategori_produks to count.
     * @example
     * // Count the number of Kategori_produks
     * const count = await prisma.kategori_produk.count({
     *   where: {
     *     // ... the filter for the Kategori_produks we want to count
     *   }
     * })
    **/
    count<T extends kategori_produkCountArgs>(
      args?: Subset<T, kategori_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kategori_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kategori_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kategori_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kategori_produkAggregateArgs>(args: Subset<T, Kategori_produkAggregateArgs>): Prisma.PrismaPromise<GetKategori_produkAggregateType<T>>

    /**
     * Group by Kategori_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategori_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategori_produkGroupByArgs['orderBy'] }
        : { orderBy?: kategori_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategori_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategori_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategori_produk model
   */
  readonly fields: kategori_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategori_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategori_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produksi<T extends kategori_produk$produksiArgs<ExtArgs> = {}>(args?: Subset<T, kategori_produk$produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the kategori_produk model
   */ 
  interface kategori_produkFieldRefs {
    readonly id: FieldRef<"kategori_produk", 'Int'>
    readonly kategori: FieldRef<"kategori_produk", 'String'>
  }
    

  // Custom InputTypes

  /**
   * kategori_produk findUnique
   */
  export type kategori_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk findUniqueOrThrow
   */
  export type kategori_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk findFirst
   */
  export type kategori_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategori_produks.
     */
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk findFirstOrThrow
   */
  export type kategori_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategori_produks.
     */
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk findMany
   */
  export type kategori_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produks to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk create
   */
  export type kategori_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a kategori_produk.
     */
    data: XOR<kategori_produkCreateInput, kategori_produkUncheckedCreateInput>
  }


  /**
   * kategori_produk createMany
   */
  export type kategori_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategori_produks.
     */
    data: kategori_produkCreateManyInput | kategori_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * kategori_produk update
   */
  export type kategori_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a kategori_produk.
     */
    data: XOR<kategori_produkUpdateInput, kategori_produkUncheckedUpdateInput>
    /**
     * Choose, which kategori_produk to update.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk updateMany
   */
  export type kategori_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategori_produks.
     */
    data: XOR<kategori_produkUpdateManyMutationInput, kategori_produkUncheckedUpdateManyInput>
    /**
     * Filter which kategori_produks to update
     */
    where?: kategori_produkWhereInput
  }


  /**
   * kategori_produk upsert
   */
  export type kategori_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the kategori_produk to update in case it exists.
     */
    where: kategori_produkWhereUniqueInput
    /**
     * In case the kategori_produk found by the `where` argument doesn't exist, create a new kategori_produk with this data.
     */
    create: XOR<kategori_produkCreateInput, kategori_produkUncheckedCreateInput>
    /**
     * In case the kategori_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategori_produkUpdateInput, kategori_produkUncheckedUpdateInput>
  }


  /**
   * kategori_produk delete
   */
  export type kategori_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter which kategori_produk to delete.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk deleteMany
   */
  export type kategori_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategori_produks to delete
     */
    where?: kategori_produkWhereInput
  }


  /**
   * kategori_produk.produksi
   */
  export type kategori_produk$produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    cursor?: produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * kategori_produk without action
   */
  export type kategori_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
  }



  /**
   * Model pembuat
   */

  export type AggregatePembuat = {
    _count: PembuatCountAggregateOutputType | null
    _avg: PembuatAvgAggregateOutputType | null
    _sum: PembuatSumAggregateOutputType | null
    _min: PembuatMinAggregateOutputType | null
    _max: PembuatMaxAggregateOutputType | null
  }

  export type PembuatAvgAggregateOutputType = {
    id: number | null
  }

  export type PembuatSumAggregateOutputType = {
    id: number | null
  }

  export type PembuatMinAggregateOutputType = {
    id: number | null
    nama_pembuat: string | null
  }

  export type PembuatMaxAggregateOutputType = {
    id: number | null
    nama_pembuat: string | null
  }

  export type PembuatCountAggregateOutputType = {
    id: number
    nama_pembuat: number
    _all: number
  }


  export type PembuatAvgAggregateInputType = {
    id?: true
  }

  export type PembuatSumAggregateInputType = {
    id?: true
  }

  export type PembuatMinAggregateInputType = {
    id?: true
    nama_pembuat?: true
  }

  export type PembuatMaxAggregateInputType = {
    id?: true
    nama_pembuat?: true
  }

  export type PembuatCountAggregateInputType = {
    id?: true
    nama_pembuat?: true
    _all?: true
  }

  export type PembuatAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pembuat to aggregate.
     */
    where?: pembuatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembuats to fetch.
     */
    orderBy?: pembuatOrderByWithRelationInput | pembuatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pembuatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembuats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembuats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pembuats
    **/
    _count?: true | PembuatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PembuatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PembuatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PembuatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PembuatMaxAggregateInputType
  }

  export type GetPembuatAggregateType<T extends PembuatAggregateArgs> = {
        [P in keyof T & keyof AggregatePembuat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePembuat[P]>
      : GetScalarType<T[P], AggregatePembuat[P]>
  }




  export type pembuatGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pembuatWhereInput
    orderBy?: pembuatOrderByWithAggregationInput | pembuatOrderByWithAggregationInput[]
    by: PembuatScalarFieldEnum[] | PembuatScalarFieldEnum
    having?: pembuatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PembuatCountAggregateInputType | true
    _avg?: PembuatAvgAggregateInputType
    _sum?: PembuatSumAggregateInputType
    _min?: PembuatMinAggregateInputType
    _max?: PembuatMaxAggregateInputType
  }

  export type PembuatGroupByOutputType = {
    id: number
    nama_pembuat: string
    _count: PembuatCountAggregateOutputType | null
    _avg: PembuatAvgAggregateOutputType | null
    _sum: PembuatSumAggregateOutputType | null
    _min: PembuatMinAggregateOutputType | null
    _max: PembuatMaxAggregateOutputType | null
  }

  type GetPembuatGroupByPayload<T extends pembuatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PembuatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PembuatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PembuatGroupByOutputType[P]>
            : GetScalarType<T[P], PembuatGroupByOutputType[P]>
        }
      >
    >


  export type pembuatSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_pembuat?: boolean
    produksi?: boolean | pembuat$produksiArgs<ExtArgs>
    _count?: boolean | PembuatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembuat"]>

  export type pembuatSelectScalar = {
    id?: boolean
    nama_pembuat?: boolean
  }

  export type pembuatInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | pembuat$produksiArgs<ExtArgs>
    _count?: boolean | PembuatCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pembuatPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "pembuat"
    objects: {
      produksi: Prisma.$produksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_pembuat: string
    }, ExtArgs["result"]["pembuat"]>
    composites: {}
  }


  type pembuatGetPayload<S extends boolean | null | undefined | pembuatDefaultArgs> = $Result.GetResult<Prisma.$pembuatPayload, S>

  type pembuatCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<pembuatFindManyArgs, 'select' | 'include'> & {
      select?: PembuatCountAggregateInputType | true
    }

  export interface pembuatDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pembuat'], meta: { name: 'pembuat' } }
    /**
     * Find zero or one Pembuat that matches the filter.
     * @param {pembuatFindUniqueArgs} args - Arguments to find a Pembuat
     * @example
     * // Get one Pembuat
     * const pembuat = await prisma.pembuat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pembuatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatFindUniqueArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pembuat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pembuatFindUniqueOrThrowArgs} args - Arguments to find a Pembuat
     * @example
     * // Get one Pembuat
     * const pembuat = await prisma.pembuat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pembuatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pembuat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatFindFirstArgs} args - Arguments to find a Pembuat
     * @example
     * // Get one Pembuat
     * const pembuat = await prisma.pembuat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pembuatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatFindFirstArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pembuat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatFindFirstOrThrowArgs} args - Arguments to find a Pembuat
     * @example
     * // Get one Pembuat
     * const pembuat = await prisma.pembuat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pembuatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pembuats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pembuats
     * const pembuats = await prisma.pembuat.findMany()
     * 
     * // Get first 10 Pembuats
     * const pembuats = await prisma.pembuat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pembuatWithIdOnly = await prisma.pembuat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pembuatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pembuat.
     * @param {pembuatCreateArgs} args - Arguments to create a Pembuat.
     * @example
     * // Create one Pembuat
     * const Pembuat = await prisma.pembuat.create({
     *   data: {
     *     // ... data to create a Pembuat
     *   }
     * })
     * 
    **/
    create<T extends pembuatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatCreateArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pembuats.
     *     @param {pembuatCreateManyArgs} args - Arguments to create many Pembuats.
     *     @example
     *     // Create many Pembuats
     *     const pembuat = await prisma.pembuat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pembuatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pembuat.
     * @param {pembuatDeleteArgs} args - Arguments to delete one Pembuat.
     * @example
     * // Delete one Pembuat
     * const Pembuat = await prisma.pembuat.delete({
     *   where: {
     *     // ... filter to delete one Pembuat
     *   }
     * })
     * 
    **/
    delete<T extends pembuatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatDeleteArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pembuat.
     * @param {pembuatUpdateArgs} args - Arguments to update one Pembuat.
     * @example
     * // Update one Pembuat
     * const pembuat = await prisma.pembuat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pembuatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatUpdateArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pembuats.
     * @param {pembuatDeleteManyArgs} args - Arguments to filter Pembuats to delete.
     * @example
     * // Delete a few Pembuats
     * const { count } = await prisma.pembuat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pembuatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembuatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pembuats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pembuats
     * const pembuat = await prisma.pembuat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pembuatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pembuat.
     * @param {pembuatUpsertArgs} args - Arguments to update or create a Pembuat.
     * @example
     * // Update or create a Pembuat
     * const pembuat = await prisma.pembuat.upsert({
     *   create: {
     *     // ... data to create a Pembuat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pembuat we want to update
     *   }
     * })
    **/
    upsert<T extends pembuatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pembuatUpsertArgs<ExtArgs>>
    ): Prisma__pembuatClient<$Result.GetResult<Prisma.$pembuatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pembuats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatCountArgs} args - Arguments to filter Pembuats to count.
     * @example
     * // Count the number of Pembuats
     * const count = await prisma.pembuat.count({
     *   where: {
     *     // ... the filter for the Pembuats we want to count
     *   }
     * })
    **/
    count<T extends pembuatCountArgs>(
      args?: Subset<T, pembuatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PembuatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pembuat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembuatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PembuatAggregateArgs>(args: Subset<T, PembuatAggregateArgs>): Prisma.PrismaPromise<GetPembuatAggregateType<T>>

    /**
     * Group by Pembuat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembuatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pembuatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pembuatGroupByArgs['orderBy'] }
        : { orderBy?: pembuatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pembuatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPembuatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pembuat model
   */
  readonly fields: pembuatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pembuat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pembuatClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produksi<T extends pembuat$produksiArgs<ExtArgs> = {}>(args?: Subset<T, pembuat$produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pembuat model
   */ 
  interface pembuatFieldRefs {
    readonly id: FieldRef<"pembuat", 'Int'>
    readonly nama_pembuat: FieldRef<"pembuat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * pembuat findUnique
   */
  export type pembuatFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter, which pembuat to fetch.
     */
    where: pembuatWhereUniqueInput
  }


  /**
   * pembuat findUniqueOrThrow
   */
  export type pembuatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter, which pembuat to fetch.
     */
    where: pembuatWhereUniqueInput
  }


  /**
   * pembuat findFirst
   */
  export type pembuatFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter, which pembuat to fetch.
     */
    where?: pembuatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembuats to fetch.
     */
    orderBy?: pembuatOrderByWithRelationInput | pembuatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pembuats.
     */
    cursor?: pembuatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembuats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembuats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pembuats.
     */
    distinct?: PembuatScalarFieldEnum | PembuatScalarFieldEnum[]
  }


  /**
   * pembuat findFirstOrThrow
   */
  export type pembuatFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter, which pembuat to fetch.
     */
    where?: pembuatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembuats to fetch.
     */
    orderBy?: pembuatOrderByWithRelationInput | pembuatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pembuats.
     */
    cursor?: pembuatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembuats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembuats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pembuats.
     */
    distinct?: PembuatScalarFieldEnum | PembuatScalarFieldEnum[]
  }


  /**
   * pembuat findMany
   */
  export type pembuatFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter, which pembuats to fetch.
     */
    where?: pembuatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembuats to fetch.
     */
    orderBy?: pembuatOrderByWithRelationInput | pembuatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pembuats.
     */
    cursor?: pembuatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembuats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembuats.
     */
    skip?: number
    distinct?: PembuatScalarFieldEnum | PembuatScalarFieldEnum[]
  }


  /**
   * pembuat create
   */
  export type pembuatCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * The data needed to create a pembuat.
     */
    data: XOR<pembuatCreateInput, pembuatUncheckedCreateInput>
  }


  /**
   * pembuat createMany
   */
  export type pembuatCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pembuats.
     */
    data: pembuatCreateManyInput | pembuatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pembuat update
   */
  export type pembuatUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * The data needed to update a pembuat.
     */
    data: XOR<pembuatUpdateInput, pembuatUncheckedUpdateInput>
    /**
     * Choose, which pembuat to update.
     */
    where: pembuatWhereUniqueInput
  }


  /**
   * pembuat updateMany
   */
  export type pembuatUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pembuats.
     */
    data: XOR<pembuatUpdateManyMutationInput, pembuatUncheckedUpdateManyInput>
    /**
     * Filter which pembuats to update
     */
    where?: pembuatWhereInput
  }


  /**
   * pembuat upsert
   */
  export type pembuatUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * The filter to search for the pembuat to update in case it exists.
     */
    where: pembuatWhereUniqueInput
    /**
     * In case the pembuat found by the `where` argument doesn't exist, create a new pembuat with this data.
     */
    create: XOR<pembuatCreateInput, pembuatUncheckedCreateInput>
    /**
     * In case the pembuat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pembuatUpdateInput, pembuatUncheckedUpdateInput>
  }


  /**
   * pembuat delete
   */
  export type pembuatDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
    /**
     * Filter which pembuat to delete.
     */
    where: pembuatWhereUniqueInput
  }


  /**
   * pembuat deleteMany
   */
  export type pembuatDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pembuats to delete
     */
    where?: pembuatWhereInput
  }


  /**
   * pembuat.produksi
   */
  export type pembuat$produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    cursor?: produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * pembuat without action
   */
  export type pembuatDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembuat
     */
    select?: pembuatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembuatInclude<ExtArgs> | null
  }



  /**
   * Model bahan_produksi
   */

  export type AggregateBahan_produksi = {
    _count: Bahan_produksiCountAggregateOutputType | null
    _avg: Bahan_produksiAvgAggregateOutputType | null
    _sum: Bahan_produksiSumAggregateOutputType | null
    _min: Bahan_produksiMinAggregateOutputType | null
    _max: Bahan_produksiMaxAggregateOutputType | null
  }

  export type Bahan_produksiAvgAggregateOutputType = {
    id: number | null
    stok_terpakai: number | null
    produksi_id: number | null
    stok_bahan_id: number | null
  }

  export type Bahan_produksiSumAggregateOutputType = {
    id: number | null
    stok_terpakai: number | null
    produksi_id: number | null
    stok_bahan_id: number | null
  }

  export type Bahan_produksiMinAggregateOutputType = {
    id: number | null
    stok_terpakai: number | null
    produksi_id: number | null
    stok_bahan_id: number | null
  }

  export type Bahan_produksiMaxAggregateOutputType = {
    id: number | null
    stok_terpakai: number | null
    produksi_id: number | null
    stok_bahan_id: number | null
  }

  export type Bahan_produksiCountAggregateOutputType = {
    id: number
    stok_terpakai: number
    produksi_id: number
    stok_bahan_id: number
    _all: number
  }


  export type Bahan_produksiAvgAggregateInputType = {
    id?: true
    stok_terpakai?: true
    produksi_id?: true
    stok_bahan_id?: true
  }

  export type Bahan_produksiSumAggregateInputType = {
    id?: true
    stok_terpakai?: true
    produksi_id?: true
    stok_bahan_id?: true
  }

  export type Bahan_produksiMinAggregateInputType = {
    id?: true
    stok_terpakai?: true
    produksi_id?: true
    stok_bahan_id?: true
  }

  export type Bahan_produksiMaxAggregateInputType = {
    id?: true
    stok_terpakai?: true
    produksi_id?: true
    stok_bahan_id?: true
  }

  export type Bahan_produksiCountAggregateInputType = {
    id?: true
    stok_terpakai?: true
    produksi_id?: true
    stok_bahan_id?: true
    _all?: true
  }

  export type Bahan_produksiAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bahan_produksi to aggregate.
     */
    where?: bahan_produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produksis to fetch.
     */
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bahan_produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bahan_produksis
    **/
    _count?: true | Bahan_produksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bahan_produksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bahan_produksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bahan_produksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bahan_produksiMaxAggregateInputType
  }

  export type GetBahan_produksiAggregateType<T extends Bahan_produksiAggregateArgs> = {
        [P in keyof T & keyof AggregateBahan_produksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahan_produksi[P]>
      : GetScalarType<T[P], AggregateBahan_produksi[P]>
  }




  export type bahan_produksiGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bahan_produksiWhereInput
    orderBy?: bahan_produksiOrderByWithAggregationInput | bahan_produksiOrderByWithAggregationInput[]
    by: Bahan_produksiScalarFieldEnum[] | Bahan_produksiScalarFieldEnum
    having?: bahan_produksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bahan_produksiCountAggregateInputType | true
    _avg?: Bahan_produksiAvgAggregateInputType
    _sum?: Bahan_produksiSumAggregateInputType
    _min?: Bahan_produksiMinAggregateInputType
    _max?: Bahan_produksiMaxAggregateInputType
  }

  export type Bahan_produksiGroupByOutputType = {
    id: number
    stok_terpakai: number
    produksi_id: number
    stok_bahan_id: number
    _count: Bahan_produksiCountAggregateOutputType | null
    _avg: Bahan_produksiAvgAggregateOutputType | null
    _sum: Bahan_produksiSumAggregateOutputType | null
    _min: Bahan_produksiMinAggregateOutputType | null
    _max: Bahan_produksiMaxAggregateOutputType | null
  }

  type GetBahan_produksiGroupByPayload<T extends bahan_produksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bahan_produksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bahan_produksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bahan_produksiGroupByOutputType[P]>
            : GetScalarType<T[P], Bahan_produksiGroupByOutputType[P]>
        }
      >
    >


  export type bahan_produksiSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stok_terpakai?: boolean
    produksi_id?: boolean
    stok_bahan_id?: boolean
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahan_produksi"]>

  export type bahan_produksiSelectScalar = {
    id?: boolean
    stok_terpakai?: boolean
    produksi_id?: boolean
    stok_bahan_id?: boolean
  }

  export type bahan_produksiInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
  }


  export type $bahan_produksiPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "bahan_produksi"
    objects: {
      produksi: Prisma.$produksiPayload<ExtArgs>
      stok_bahan: Prisma.$stok_bahanPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      stok_terpakai: number
      produksi_id: number
      stok_bahan_id: number
    }, ExtArgs["result"]["bahan_produksi"]>
    composites: {}
  }


  type bahan_produksiGetPayload<S extends boolean | null | undefined | bahan_produksiDefaultArgs> = $Result.GetResult<Prisma.$bahan_produksiPayload, S>

  type bahan_produksiCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bahan_produksiFindManyArgs, 'select' | 'include'> & {
      select?: Bahan_produksiCountAggregateInputType | true
    }

  export interface bahan_produksiDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bahan_produksi'], meta: { name: 'bahan_produksi' } }
    /**
     * Find zero or one Bahan_produksi that matches the filter.
     * @param {bahan_produksiFindUniqueArgs} args - Arguments to find a Bahan_produksi
     * @example
     * // Get one Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bahan_produksiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiFindUniqueArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bahan_produksi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bahan_produksiFindUniqueOrThrowArgs} args - Arguments to find a Bahan_produksi
     * @example
     * // Get one Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bahan_produksiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bahan_produksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiFindFirstArgs} args - Arguments to find a Bahan_produksi
     * @example
     * // Get one Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bahan_produksiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiFindFirstArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bahan_produksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiFindFirstOrThrowArgs} args - Arguments to find a Bahan_produksi
     * @example
     * // Get one Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bahan_produksiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bahan_produksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bahan_produksis
     * const bahan_produksis = await prisma.bahan_produksi.findMany()
     * 
     * // Get first 10 Bahan_produksis
     * const bahan_produksis = await prisma.bahan_produksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bahan_produksiWithIdOnly = await prisma.bahan_produksi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bahan_produksiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bahan_produksi.
     * @param {bahan_produksiCreateArgs} args - Arguments to create a Bahan_produksi.
     * @example
     * // Create one Bahan_produksi
     * const Bahan_produksi = await prisma.bahan_produksi.create({
     *   data: {
     *     // ... data to create a Bahan_produksi
     *   }
     * })
     * 
    **/
    create<T extends bahan_produksiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiCreateArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bahan_produksis.
     *     @param {bahan_produksiCreateManyArgs} args - Arguments to create many Bahan_produksis.
     *     @example
     *     // Create many Bahan_produksis
     *     const bahan_produksi = await prisma.bahan_produksi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bahan_produksiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bahan_produksi.
     * @param {bahan_produksiDeleteArgs} args - Arguments to delete one Bahan_produksi.
     * @example
     * // Delete one Bahan_produksi
     * const Bahan_produksi = await prisma.bahan_produksi.delete({
     *   where: {
     *     // ... filter to delete one Bahan_produksi
     *   }
     * })
     * 
    **/
    delete<T extends bahan_produksiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiDeleteArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bahan_produksi.
     * @param {bahan_produksiUpdateArgs} args - Arguments to update one Bahan_produksi.
     * @example
     * // Update one Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bahan_produksiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiUpdateArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bahan_produksis.
     * @param {bahan_produksiDeleteManyArgs} args - Arguments to filter Bahan_produksis to delete.
     * @example
     * // Delete a few Bahan_produksis
     * const { count } = await prisma.bahan_produksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bahan_produksiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produksiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bahan_produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bahan_produksis
     * const bahan_produksi = await prisma.bahan_produksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bahan_produksiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bahan_produksi.
     * @param {bahan_produksiUpsertArgs} args - Arguments to update or create a Bahan_produksi.
     * @example
     * // Update or create a Bahan_produksi
     * const bahan_produksi = await prisma.bahan_produksi.upsert({
     *   create: {
     *     // ... data to create a Bahan_produksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bahan_produksi we want to update
     *   }
     * })
    **/
    upsert<T extends bahan_produksiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produksiUpsertArgs<ExtArgs>>
    ): Prisma__bahan_produksiClient<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bahan_produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiCountArgs} args - Arguments to filter Bahan_produksis to count.
     * @example
     * // Count the number of Bahan_produksis
     * const count = await prisma.bahan_produksi.count({
     *   where: {
     *     // ... the filter for the Bahan_produksis we want to count
     *   }
     * })
    **/
    count<T extends bahan_produksiCountArgs>(
      args?: Subset<T, bahan_produksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bahan_produksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bahan_produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bahan_produksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bahan_produksiAggregateArgs>(args: Subset<T, Bahan_produksiAggregateArgs>): Prisma.PrismaPromise<GetBahan_produksiAggregateType<T>>

    /**
     * Group by Bahan_produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bahan_produksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bahan_produksiGroupByArgs['orderBy'] }
        : { orderBy?: bahan_produksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bahan_produksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahan_produksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bahan_produksi model
   */
  readonly fields: bahan_produksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bahan_produksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bahan_produksiClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produksi<T extends produksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produksiDefaultArgs<ExtArgs>>): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stok_bahan<T extends stok_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahanDefaultArgs<ExtArgs>>): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bahan_produksi model
   */ 
  interface bahan_produksiFieldRefs {
    readonly id: FieldRef<"bahan_produksi", 'Int'>
    readonly stok_terpakai: FieldRef<"bahan_produksi", 'Float'>
    readonly produksi_id: FieldRef<"bahan_produksi", 'Int'>
    readonly stok_bahan_id: FieldRef<"bahan_produksi", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * bahan_produksi findUnique
   */
  export type bahan_produksiFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produksi to fetch.
     */
    where: bahan_produksiWhereUniqueInput
  }


  /**
   * bahan_produksi findUniqueOrThrow
   */
  export type bahan_produksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produksi to fetch.
     */
    where: bahan_produksiWhereUniqueInput
  }


  /**
   * bahan_produksi findFirst
   */
  export type bahan_produksiFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produksi to fetch.
     */
    where?: bahan_produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produksis to fetch.
     */
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bahan_produksis.
     */
    cursor?: bahan_produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bahan_produksis.
     */
    distinct?: Bahan_produksiScalarFieldEnum | Bahan_produksiScalarFieldEnum[]
  }


  /**
   * bahan_produksi findFirstOrThrow
   */
  export type bahan_produksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produksi to fetch.
     */
    where?: bahan_produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produksis to fetch.
     */
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bahan_produksis.
     */
    cursor?: bahan_produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bahan_produksis.
     */
    distinct?: Bahan_produksiScalarFieldEnum | Bahan_produksiScalarFieldEnum[]
  }


  /**
   * bahan_produksi findMany
   */
  export type bahan_produksiFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produksis to fetch.
     */
    where?: bahan_produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produksis to fetch.
     */
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bahan_produksis.
     */
    cursor?: bahan_produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produksis.
     */
    skip?: number
    distinct?: Bahan_produksiScalarFieldEnum | Bahan_produksiScalarFieldEnum[]
  }


  /**
   * bahan_produksi create
   */
  export type bahan_produksiCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * The data needed to create a bahan_produksi.
     */
    data: XOR<bahan_produksiCreateInput, bahan_produksiUncheckedCreateInput>
  }


  /**
   * bahan_produksi createMany
   */
  export type bahan_produksiCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bahan_produksis.
     */
    data: bahan_produksiCreateManyInput | bahan_produksiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bahan_produksi update
   */
  export type bahan_produksiUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * The data needed to update a bahan_produksi.
     */
    data: XOR<bahan_produksiUpdateInput, bahan_produksiUncheckedUpdateInput>
    /**
     * Choose, which bahan_produksi to update.
     */
    where: bahan_produksiWhereUniqueInput
  }


  /**
   * bahan_produksi updateMany
   */
  export type bahan_produksiUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bahan_produksis.
     */
    data: XOR<bahan_produksiUpdateManyMutationInput, bahan_produksiUncheckedUpdateManyInput>
    /**
     * Filter which bahan_produksis to update
     */
    where?: bahan_produksiWhereInput
  }


  /**
   * bahan_produksi upsert
   */
  export type bahan_produksiUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * The filter to search for the bahan_produksi to update in case it exists.
     */
    where: bahan_produksiWhereUniqueInput
    /**
     * In case the bahan_produksi found by the `where` argument doesn't exist, create a new bahan_produksi with this data.
     */
    create: XOR<bahan_produksiCreateInput, bahan_produksiUncheckedCreateInput>
    /**
     * In case the bahan_produksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bahan_produksiUpdateInput, bahan_produksiUncheckedUpdateInput>
  }


  /**
   * bahan_produksi delete
   */
  export type bahan_produksiDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    /**
     * Filter which bahan_produksi to delete.
     */
    where: bahan_produksiWhereUniqueInput
  }


  /**
   * bahan_produksi deleteMany
   */
  export type bahan_produksiDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bahan_produksis to delete
     */
    where?: bahan_produksiWhereInput
  }


  /**
   * bahan_produksi without action
   */
  export type bahan_produksiDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
  }



  /**
   * Model stok_bahan
   */

  export type AggregateStok_bahan = {
    _count: Stok_bahanCountAggregateOutputType | null
    _avg: Stok_bahanAvgAggregateOutputType | null
    _sum: Stok_bahanSumAggregateOutputType | null
    _min: Stok_bahanMinAggregateOutputType | null
    _max: Stok_bahanMaxAggregateOutputType | null
  }

  export type Stok_bahanAvgAggregateOutputType = {
    id: number | null
    ukuran: number | null
    stok: number | null
  }

  export type Stok_bahanSumAggregateOutputType = {
    id: number | null
    ukuran: number | null
    stok: number | null
  }

  export type Stok_bahanMinAggregateOutputType = {
    id: number | null
    kode_bahan: string | null
    nama_bahan: string | null
    ukuran: number | null
    satuan: string | null
    stok: number | null
  }

  export type Stok_bahanMaxAggregateOutputType = {
    id: number | null
    kode_bahan: string | null
    nama_bahan: string | null
    ukuran: number | null
    satuan: string | null
    stok: number | null
  }

  export type Stok_bahanCountAggregateOutputType = {
    id: number
    kode_bahan: number
    nama_bahan: number
    ukuran: number
    satuan: number
    stok: number
    _all: number
  }


  export type Stok_bahanAvgAggregateInputType = {
    id?: true
    ukuran?: true
    stok?: true
  }

  export type Stok_bahanSumAggregateInputType = {
    id?: true
    ukuran?: true
    stok?: true
  }

  export type Stok_bahanMinAggregateInputType = {
    id?: true
    kode_bahan?: true
    nama_bahan?: true
    ukuran?: true
    satuan?: true
    stok?: true
  }

  export type Stok_bahanMaxAggregateInputType = {
    id?: true
    kode_bahan?: true
    nama_bahan?: true
    ukuran?: true
    satuan?: true
    stok?: true
  }

  export type Stok_bahanCountAggregateInputType = {
    id?: true
    kode_bahan?: true
    nama_bahan?: true
    ukuran?: true
    satuan?: true
    stok?: true
    _all?: true
  }

  export type Stok_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which stok_bahan to aggregate.
     */
    where?: stok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stok_bahans to fetch.
     */
    orderBy?: stok_bahanOrderByWithRelationInput | stok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stok_bahans
    **/
    _count?: true | Stok_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stok_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stok_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stok_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stok_bahanMaxAggregateInputType
  }

  export type GetStok_bahanAggregateType<T extends Stok_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateStok_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStok_bahan[P]>
      : GetScalarType<T[P], AggregateStok_bahan[P]>
  }




  export type stok_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: stok_bahanWhereInput
    orderBy?: stok_bahanOrderByWithAggregationInput | stok_bahanOrderByWithAggregationInput[]
    by: Stok_bahanScalarFieldEnum[] | Stok_bahanScalarFieldEnum
    having?: stok_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stok_bahanCountAggregateInputType | true
    _avg?: Stok_bahanAvgAggregateInputType
    _sum?: Stok_bahanSumAggregateInputType
    _min?: Stok_bahanMinAggregateInputType
    _max?: Stok_bahanMaxAggregateInputType
  }

  export type Stok_bahanGroupByOutputType = {
    id: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    _count: Stok_bahanCountAggregateOutputType | null
    _avg: Stok_bahanAvgAggregateOutputType | null
    _sum: Stok_bahanSumAggregateOutputType | null
    _min: Stok_bahanMinAggregateOutputType | null
    _max: Stok_bahanMaxAggregateOutputType | null
  }

  type GetStok_bahanGroupByPayload<T extends stok_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stok_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stok_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stok_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Stok_bahanGroupByOutputType[P]>
        }
      >
    >


  export type stok_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_bahan?: boolean
    nama_bahan?: boolean
    ukuran?: boolean
    satuan?: boolean
    stok?: boolean
    bahan_produksi?: boolean | stok_bahan$bahan_produksiArgs<ExtArgs>
    detail_pengecekan_bahan?: boolean | stok_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    detail_pemesanan_bahan?: boolean | stok_bahan$detail_pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | Stok_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stok_bahan"]>

  export type stok_bahanSelectScalar = {
    id?: boolean
    kode_bahan?: boolean
    nama_bahan?: boolean
    ukuran?: boolean
    satuan?: boolean
    stok?: boolean
  }

  export type stok_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bahan_produksi?: boolean | stok_bahan$bahan_produksiArgs<ExtArgs>
    detail_pengecekan_bahan?: boolean | stok_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    detail_pemesanan_bahan?: boolean | stok_bahan$detail_pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | Stok_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $stok_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "stok_bahan"
    objects: {
      bahan_produksi: Prisma.$bahan_produksiPayload<ExtArgs>[]
      detail_pengecekan_bahan: Prisma.$detail_pengecekan_bahanPayload<ExtArgs>[]
      detail_pemesanan_bahan: Prisma.$detail_pemesanan_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      kode_bahan: string
      nama_bahan: string
      ukuran: number
      satuan: string
      stok: number
    }, ExtArgs["result"]["stok_bahan"]>
    composites: {}
  }


  type stok_bahanGetPayload<S extends boolean | null | undefined | stok_bahanDefaultArgs> = $Result.GetResult<Prisma.$stok_bahanPayload, S>

  type stok_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<stok_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Stok_bahanCountAggregateInputType | true
    }

  export interface stok_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stok_bahan'], meta: { name: 'stok_bahan' } }
    /**
     * Find zero or one Stok_bahan that matches the filter.
     * @param {stok_bahanFindUniqueArgs} args - Arguments to find a Stok_bahan
     * @example
     * // Get one Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends stok_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Stok_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {stok_bahanFindUniqueOrThrowArgs} args - Arguments to find a Stok_bahan
     * @example
     * // Get one Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends stok_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Stok_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanFindFirstArgs} args - Arguments to find a Stok_bahan
     * @example
     * // Get one Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends stok_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Stok_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanFindFirstOrThrowArgs} args - Arguments to find a Stok_bahan
     * @example
     * // Get one Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends stok_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Stok_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stok_bahans
     * const stok_bahans = await prisma.stok_bahan.findMany()
     * 
     * // Get first 10 Stok_bahans
     * const stok_bahans = await prisma.stok_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stok_bahanWithIdOnly = await prisma.stok_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends stok_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Stok_bahan.
     * @param {stok_bahanCreateArgs} args - Arguments to create a Stok_bahan.
     * @example
     * // Create one Stok_bahan
     * const Stok_bahan = await prisma.stok_bahan.create({
     *   data: {
     *     // ... data to create a Stok_bahan
     *   }
     * })
     * 
    **/
    create<T extends stok_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanCreateArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Stok_bahans.
     *     @param {stok_bahanCreateManyArgs} args - Arguments to create many Stok_bahans.
     *     @example
     *     // Create many Stok_bahans
     *     const stok_bahan = await prisma.stok_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends stok_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stok_bahan.
     * @param {stok_bahanDeleteArgs} args - Arguments to delete one Stok_bahan.
     * @example
     * // Delete one Stok_bahan
     * const Stok_bahan = await prisma.stok_bahan.delete({
     *   where: {
     *     // ... filter to delete one Stok_bahan
     *   }
     * })
     * 
    **/
    delete<T extends stok_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanDeleteArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Stok_bahan.
     * @param {stok_bahanUpdateArgs} args - Arguments to update one Stok_bahan.
     * @example
     * // Update one Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends stok_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanUpdateArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Stok_bahans.
     * @param {stok_bahanDeleteManyArgs} args - Arguments to filter Stok_bahans to delete.
     * @example
     * // Delete a few Stok_bahans
     * const { count } = await prisma.stok_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends stok_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stok_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stok_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stok_bahans
     * const stok_bahan = await prisma.stok_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends stok_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stok_bahan.
     * @param {stok_bahanUpsertArgs} args - Arguments to update or create a Stok_bahan.
     * @example
     * // Update or create a Stok_bahan
     * const stok_bahan = await prisma.stok_bahan.upsert({
     *   create: {
     *     // ... data to create a Stok_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stok_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends stok_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, stok_bahanUpsertArgs<ExtArgs>>
    ): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Stok_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanCountArgs} args - Arguments to filter Stok_bahans to count.
     * @example
     * // Count the number of Stok_bahans
     * const count = await prisma.stok_bahan.count({
     *   where: {
     *     // ... the filter for the Stok_bahans we want to count
     *   }
     * })
    **/
    count<T extends stok_bahanCountArgs>(
      args?: Subset<T, stok_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stok_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stok_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stok_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stok_bahanAggregateArgs>(args: Subset<T, Stok_bahanAggregateArgs>): Prisma.PrismaPromise<GetStok_bahanAggregateType<T>>

    /**
     * Group by Stok_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stok_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stok_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stok_bahanGroupByArgs['orderBy'] }
        : { orderBy?: stok_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stok_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStok_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stok_bahan model
   */
  readonly fields: stok_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stok_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stok_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bahan_produksi<T extends stok_bahan$bahan_produksiArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahan$bahan_produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pengecekan_bahan<T extends stok_bahan$detail_pengecekan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahan$detail_pengecekan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pemesanan_bahan<T extends stok_bahan$detail_pemesanan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahan$detail_pemesanan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the stok_bahan model
   */ 
  interface stok_bahanFieldRefs {
    readonly id: FieldRef<"stok_bahan", 'Int'>
    readonly kode_bahan: FieldRef<"stok_bahan", 'String'>
    readonly nama_bahan: FieldRef<"stok_bahan", 'String'>
    readonly ukuran: FieldRef<"stok_bahan", 'Float'>
    readonly satuan: FieldRef<"stok_bahan", 'String'>
    readonly stok: FieldRef<"stok_bahan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * stok_bahan findUnique
   */
  export type stok_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which stok_bahan to fetch.
     */
    where: stok_bahanWhereUniqueInput
  }


  /**
   * stok_bahan findUniqueOrThrow
   */
  export type stok_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which stok_bahan to fetch.
     */
    where: stok_bahanWhereUniqueInput
  }


  /**
   * stok_bahan findFirst
   */
  export type stok_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which stok_bahan to fetch.
     */
    where?: stok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stok_bahans to fetch.
     */
    orderBy?: stok_bahanOrderByWithRelationInput | stok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stok_bahans.
     */
    cursor?: stok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stok_bahans.
     */
    distinct?: Stok_bahanScalarFieldEnum | Stok_bahanScalarFieldEnum[]
  }


  /**
   * stok_bahan findFirstOrThrow
   */
  export type stok_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which stok_bahan to fetch.
     */
    where?: stok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stok_bahans to fetch.
     */
    orderBy?: stok_bahanOrderByWithRelationInput | stok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stok_bahans.
     */
    cursor?: stok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stok_bahans.
     */
    distinct?: Stok_bahanScalarFieldEnum | Stok_bahanScalarFieldEnum[]
  }


  /**
   * stok_bahan findMany
   */
  export type stok_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which stok_bahans to fetch.
     */
    where?: stok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stok_bahans to fetch.
     */
    orderBy?: stok_bahanOrderByWithRelationInput | stok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stok_bahans.
     */
    cursor?: stok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stok_bahans.
     */
    skip?: number
    distinct?: Stok_bahanScalarFieldEnum | Stok_bahanScalarFieldEnum[]
  }


  /**
   * stok_bahan create
   */
  export type stok_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a stok_bahan.
     */
    data: XOR<stok_bahanCreateInput, stok_bahanUncheckedCreateInput>
  }


  /**
   * stok_bahan createMany
   */
  export type stok_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stok_bahans.
     */
    data: stok_bahanCreateManyInput | stok_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * stok_bahan update
   */
  export type stok_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a stok_bahan.
     */
    data: XOR<stok_bahanUpdateInput, stok_bahanUncheckedUpdateInput>
    /**
     * Choose, which stok_bahan to update.
     */
    where: stok_bahanWhereUniqueInput
  }


  /**
   * stok_bahan updateMany
   */
  export type stok_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stok_bahans.
     */
    data: XOR<stok_bahanUpdateManyMutationInput, stok_bahanUncheckedUpdateManyInput>
    /**
     * Filter which stok_bahans to update
     */
    where?: stok_bahanWhereInput
  }


  /**
   * stok_bahan upsert
   */
  export type stok_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the stok_bahan to update in case it exists.
     */
    where: stok_bahanWhereUniqueInput
    /**
     * In case the stok_bahan found by the `where` argument doesn't exist, create a new stok_bahan with this data.
     */
    create: XOR<stok_bahanCreateInput, stok_bahanUncheckedCreateInput>
    /**
     * In case the stok_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stok_bahanUpdateInput, stok_bahanUncheckedUpdateInput>
  }


  /**
   * stok_bahan delete
   */
  export type stok_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
    /**
     * Filter which stok_bahan to delete.
     */
    where: stok_bahanWhereUniqueInput
  }


  /**
   * stok_bahan deleteMany
   */
  export type stok_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which stok_bahans to delete
     */
    where?: stok_bahanWhereInput
  }


  /**
   * stok_bahan.bahan_produksi
   */
  export type stok_bahan$bahan_produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produksi
     */
    select?: bahan_produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produksiInclude<ExtArgs> | null
    where?: bahan_produksiWhereInput
    orderBy?: bahan_produksiOrderByWithRelationInput | bahan_produksiOrderByWithRelationInput[]
    cursor?: bahan_produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bahan_produksiScalarFieldEnum | Bahan_produksiScalarFieldEnum[]
  }


  /**
   * stok_bahan.detail_pengecekan_bahan
   */
  export type stok_bahan$detail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    where?: detail_pengecekan_bahanWhereInput
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * stok_bahan.detail_pemesanan_bahan
   */
  export type stok_bahan$detail_pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    where?: detail_pemesanan_bahanWhereInput
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pemesanan_bahanScalarFieldEnum | Detail_pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * stok_bahan without action
   */
  export type stok_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stok_bahan
     */
    select?: stok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: stok_bahanInclude<ExtArgs> | null
  }



  /**
   * Model detail_pengecekan_produk
   */

  export type AggregateDetail_pengecekan_produk = {
    _count: Detail_pengecekan_produkCountAggregateOutputType | null
    _avg: Detail_pengecekan_produkAvgAggregateOutputType | null
    _sum: Detail_pengecekan_produkSumAggregateOutputType | null
    _min: Detail_pengecekan_produkMinAggregateOutputType | null
    _max: Detail_pengecekan_produkMaxAggregateOutputType | null
  }

  export type Detail_pengecekan_produkAvgAggregateOutputType = {
    id: number | null
    pengecekan_produk_id: number | null
    produk_item_id: number | null
    kondisi_produk_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_produkSumAggregateOutputType = {
    id: number | null
    pengecekan_produk_id: number | null
    produk_item_id: number | null
    kondisi_produk_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_produkMinAggregateOutputType = {
    id: number | null
    pengecekan_produk_id: number | null
    produk_item_id: number | null
    kondisi_produk_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_produkMaxAggregateOutputType = {
    id: number | null
    pengecekan_produk_id: number | null
    produk_item_id: number | null
    kondisi_produk_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_produkCountAggregateOutputType = {
    id: number
    pengecekan_produk_id: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
    _all: number
  }


  export type Detail_pengecekan_produkAvgAggregateInputType = {
    id?: true
    pengecekan_produk_id?: true
    produk_item_id?: true
    kondisi_produk_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_produkSumAggregateInputType = {
    id?: true
    pengecekan_produk_id?: true
    produk_item_id?: true
    kondisi_produk_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_produkMinAggregateInputType = {
    id?: true
    pengecekan_produk_id?: true
    produk_item_id?: true
    kondisi_produk_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_produkMaxAggregateInputType = {
    id?: true
    pengecekan_produk_id?: true
    produk_item_id?: true
    kondisi_produk_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_produkCountAggregateInputType = {
    id?: true
    pengecekan_produk_id?: true
    produk_item_id?: true
    kondisi_produk_id?: true
    jumlah?: true
    _all?: true
  }

  export type Detail_pengecekan_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pengecekan_produk to aggregate.
     */
    where?: detail_pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_produks to fetch.
     */
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_pengecekan_produks
    **/
    _count?: true | Detail_pengecekan_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_pengecekan_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_pengecekan_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_pengecekan_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_pengecekan_produkMaxAggregateInputType
  }

  export type GetDetail_pengecekan_produkAggregateType<T extends Detail_pengecekan_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_pengecekan_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_pengecekan_produk[P]>
      : GetScalarType<T[P], AggregateDetail_pengecekan_produk[P]>
  }




  export type detail_pengecekan_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_produkWhereInput
    orderBy?: detail_pengecekan_produkOrderByWithAggregationInput | detail_pengecekan_produkOrderByWithAggregationInput[]
    by: Detail_pengecekan_produkScalarFieldEnum[] | Detail_pengecekan_produkScalarFieldEnum
    having?: detail_pengecekan_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_pengecekan_produkCountAggregateInputType | true
    _avg?: Detail_pengecekan_produkAvgAggregateInputType
    _sum?: Detail_pengecekan_produkSumAggregateInputType
    _min?: Detail_pengecekan_produkMinAggregateInputType
    _max?: Detail_pengecekan_produkMaxAggregateInputType
  }

  export type Detail_pengecekan_produkGroupByOutputType = {
    id: number
    pengecekan_produk_id: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
    _count: Detail_pengecekan_produkCountAggregateOutputType | null
    _avg: Detail_pengecekan_produkAvgAggregateOutputType | null
    _sum: Detail_pengecekan_produkSumAggregateOutputType | null
    _min: Detail_pengecekan_produkMinAggregateOutputType | null
    _max: Detail_pengecekan_produkMaxAggregateOutputType | null
  }

  type GetDetail_pengecekan_produkGroupByPayload<T extends detail_pengecekan_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_pengecekan_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_pengecekan_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_pengecekan_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_pengecekan_produkGroupByOutputType[P]>
        }
      >
    >


  export type detail_pengecekan_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pengecekan_produk_id?: boolean
    produk_item_id?: boolean
    kondisi_produk_id?: boolean
    jumlah?: boolean
    pengecekan_produk?: boolean | pengecekan_produkDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
    kondisi_produk?: boolean | kondisi_produkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_pengecekan_produk"]>

  export type detail_pengecekan_produkSelectScalar = {
    id?: boolean
    pengecekan_produk_id?: boolean
    produk_item_id?: boolean
    kondisi_produk_id?: boolean
    jumlah?: boolean
  }

  export type detail_pengecekan_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pengecekan_produk?: boolean | pengecekan_produkDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
    kondisi_produk?: boolean | kondisi_produkDefaultArgs<ExtArgs>
  }


  export type $detail_pengecekan_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_pengecekan_produk"
    objects: {
      pengecekan_produk: Prisma.$pengecekan_produkPayload<ExtArgs>
      produk_item: Prisma.$produk_itemPayload<ExtArgs>
      kondisi_produk: Prisma.$kondisi_produkPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      pengecekan_produk_id: number
      produk_item_id: number
      kondisi_produk_id: number
      jumlah: number
    }, ExtArgs["result"]["detail_pengecekan_produk"]>
    composites: {}
  }


  type detail_pengecekan_produkGetPayload<S extends boolean | null | undefined | detail_pengecekan_produkDefaultArgs> = $Result.GetResult<Prisma.$detail_pengecekan_produkPayload, S>

  type detail_pengecekan_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_pengecekan_produkFindManyArgs, 'select' | 'include'> & {
      select?: Detail_pengecekan_produkCountAggregateInputType | true
    }

  export interface detail_pengecekan_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_pengecekan_produk'], meta: { name: 'detail_pengecekan_produk' } }
    /**
     * Find zero or one Detail_pengecekan_produk that matches the filter.
     * @param {detail_pengecekan_produkFindUniqueArgs} args - Arguments to find a Detail_pengecekan_produk
     * @example
     * // Get one Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_pengecekan_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_pengecekan_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_pengecekan_produkFindUniqueOrThrowArgs} args - Arguments to find a Detail_pengecekan_produk
     * @example
     * // Get one Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_pengecekan_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkFindFirstArgs} args - Arguments to find a Detail_pengecekan_produk
     * @example
     * // Get one Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_pengecekan_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkFindFirstArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_pengecekan_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkFindFirstOrThrowArgs} args - Arguments to find a Detail_pengecekan_produk
     * @example
     * // Get one Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_pengecekan_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_pengecekan_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_pengecekan_produks
     * const detail_pengecekan_produks = await prisma.detail_pengecekan_produk.findMany()
     * 
     * // Get first 10 Detail_pengecekan_produks
     * const detail_pengecekan_produks = await prisma.detail_pengecekan_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_pengecekan_produkWithIdOnly = await prisma.detail_pengecekan_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_pengecekan_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_pengecekan_produk.
     * @param {detail_pengecekan_produkCreateArgs} args - Arguments to create a Detail_pengecekan_produk.
     * @example
     * // Create one Detail_pengecekan_produk
     * const Detail_pengecekan_produk = await prisma.detail_pengecekan_produk.create({
     *   data: {
     *     // ... data to create a Detail_pengecekan_produk
     *   }
     * })
     * 
    **/
    create<T extends detail_pengecekan_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkCreateArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_pengecekan_produks.
     *     @param {detail_pengecekan_produkCreateManyArgs} args - Arguments to create many Detail_pengecekan_produks.
     *     @example
     *     // Create many Detail_pengecekan_produks
     *     const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_pengecekan_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_pengecekan_produk.
     * @param {detail_pengecekan_produkDeleteArgs} args - Arguments to delete one Detail_pengecekan_produk.
     * @example
     * // Delete one Detail_pengecekan_produk
     * const Detail_pengecekan_produk = await prisma.detail_pengecekan_produk.delete({
     *   where: {
     *     // ... filter to delete one Detail_pengecekan_produk
     *   }
     * })
     * 
    **/
    delete<T extends detail_pengecekan_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkDeleteArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_pengecekan_produk.
     * @param {detail_pengecekan_produkUpdateArgs} args - Arguments to update one Detail_pengecekan_produk.
     * @example
     * // Update one Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_pengecekan_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkUpdateArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_pengecekan_produks.
     * @param {detail_pengecekan_produkDeleteManyArgs} args - Arguments to filter Detail_pengecekan_produks to delete.
     * @example
     * // Delete a few Detail_pengecekan_produks
     * const { count } = await prisma.detail_pengecekan_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_pengecekan_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_pengecekan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_pengecekan_produks
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_pengecekan_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_pengecekan_produk.
     * @param {detail_pengecekan_produkUpsertArgs} args - Arguments to update or create a Detail_pengecekan_produk.
     * @example
     * // Update or create a Detail_pengecekan_produk
     * const detail_pengecekan_produk = await prisma.detail_pengecekan_produk.upsert({
     *   create: {
     *     // ... data to create a Detail_pengecekan_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_pengecekan_produk we want to update
     *   }
     * })
    **/
    upsert<T extends detail_pengecekan_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_produkUpsertArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_produkClient<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_pengecekan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkCountArgs} args - Arguments to filter Detail_pengecekan_produks to count.
     * @example
     * // Count the number of Detail_pengecekan_produks
     * const count = await prisma.detail_pengecekan_produk.count({
     *   where: {
     *     // ... the filter for the Detail_pengecekan_produks we want to count
     *   }
     * })
    **/
    count<T extends detail_pengecekan_produkCountArgs>(
      args?: Subset<T, detail_pengecekan_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_pengecekan_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_pengecekan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_pengecekan_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_pengecekan_produkAggregateArgs>(args: Subset<T, Detail_pengecekan_produkAggregateArgs>): Prisma.PrismaPromise<GetDetail_pengecekan_produkAggregateType<T>>

    /**
     * Group by Detail_pengecekan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_pengecekan_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_pengecekan_produkGroupByArgs['orderBy'] }
        : { orderBy?: detail_pengecekan_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_pengecekan_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_pengecekan_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_pengecekan_produk model
   */
  readonly fields: detail_pengecekan_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_pengecekan_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_pengecekan_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pengecekan_produk<T extends pengecekan_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pengecekan_produkDefaultArgs<ExtArgs>>): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produk_item<T extends produk_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produk_itemDefaultArgs<ExtArgs>>): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    kondisi_produk<T extends kondisi_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kondisi_produkDefaultArgs<ExtArgs>>): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_pengecekan_produk model
   */ 
  interface detail_pengecekan_produkFieldRefs {
    readonly id: FieldRef<"detail_pengecekan_produk", 'Int'>
    readonly pengecekan_produk_id: FieldRef<"detail_pengecekan_produk", 'Int'>
    readonly produk_item_id: FieldRef<"detail_pengecekan_produk", 'Int'>
    readonly kondisi_produk_id: FieldRef<"detail_pengecekan_produk", 'Int'>
    readonly jumlah: FieldRef<"detail_pengecekan_produk", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * detail_pengecekan_produk findUnique
   */
  export type detail_pengecekan_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_produk to fetch.
     */
    where: detail_pengecekan_produkWhereUniqueInput
  }


  /**
   * detail_pengecekan_produk findUniqueOrThrow
   */
  export type detail_pengecekan_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_produk to fetch.
     */
    where: detail_pengecekan_produkWhereUniqueInput
  }


  /**
   * detail_pengecekan_produk findFirst
   */
  export type detail_pengecekan_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_produk to fetch.
     */
    where?: detail_pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_produks to fetch.
     */
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pengecekan_produks.
     */
    cursor?: detail_pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pengecekan_produks.
     */
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_produk findFirstOrThrow
   */
  export type detail_pengecekan_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_produk to fetch.
     */
    where?: detail_pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_produks to fetch.
     */
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pengecekan_produks.
     */
    cursor?: detail_pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pengecekan_produks.
     */
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_produk findMany
   */
  export type detail_pengecekan_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_produks to fetch.
     */
    where?: detail_pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_produks to fetch.
     */
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_pengecekan_produks.
     */
    cursor?: detail_pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_produks.
     */
    skip?: number
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_produk create
   */
  export type detail_pengecekan_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_pengecekan_produk.
     */
    data: XOR<detail_pengecekan_produkCreateInput, detail_pengecekan_produkUncheckedCreateInput>
  }


  /**
   * detail_pengecekan_produk createMany
   */
  export type detail_pengecekan_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_pengecekan_produks.
     */
    data: detail_pengecekan_produkCreateManyInput | detail_pengecekan_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_pengecekan_produk update
   */
  export type detail_pengecekan_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_pengecekan_produk.
     */
    data: XOR<detail_pengecekan_produkUpdateInput, detail_pengecekan_produkUncheckedUpdateInput>
    /**
     * Choose, which detail_pengecekan_produk to update.
     */
    where: detail_pengecekan_produkWhereUniqueInput
  }


  /**
   * detail_pengecekan_produk updateMany
   */
  export type detail_pengecekan_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_pengecekan_produks.
     */
    data: XOR<detail_pengecekan_produkUpdateManyMutationInput, detail_pengecekan_produkUncheckedUpdateManyInput>
    /**
     * Filter which detail_pengecekan_produks to update
     */
    where?: detail_pengecekan_produkWhereInput
  }


  /**
   * detail_pengecekan_produk upsert
   */
  export type detail_pengecekan_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_pengecekan_produk to update in case it exists.
     */
    where: detail_pengecekan_produkWhereUniqueInput
    /**
     * In case the detail_pengecekan_produk found by the `where` argument doesn't exist, create a new detail_pengecekan_produk with this data.
     */
    create: XOR<detail_pengecekan_produkCreateInput, detail_pengecekan_produkUncheckedCreateInput>
    /**
     * In case the detail_pengecekan_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_pengecekan_produkUpdateInput, detail_pengecekan_produkUncheckedUpdateInput>
  }


  /**
   * detail_pengecekan_produk delete
   */
  export type detail_pengecekan_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter which detail_pengecekan_produk to delete.
     */
    where: detail_pengecekan_produkWhereUniqueInput
  }


  /**
   * detail_pengecekan_produk deleteMany
   */
  export type detail_pengecekan_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pengecekan_produks to delete
     */
    where?: detail_pengecekan_produkWhereInput
  }


  /**
   * detail_pengecekan_produk without action
   */
  export type detail_pengecekan_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
  }



  /**
   * Model pengecekan_produk
   */

  export type AggregatePengecekan_produk = {
    _count: Pengecekan_produkCountAggregateOutputType | null
    _avg: Pengecekan_produkAvgAggregateOutputType | null
    _sum: Pengecekan_produkSumAggregateOutputType | null
    _min: Pengecekan_produkMinAggregateOutputType | null
    _max: Pengecekan_produkMaxAggregateOutputType | null
  }

  export type Pengecekan_produkAvgAggregateOutputType = {
    id: number | null
  }

  export type Pengecekan_produkSumAggregateOutputType = {
    id: number | null
  }

  export type Pengecekan_produkMinAggregateOutputType = {
    id: number | null
    nama_pic: string | null
    tanggal: Date | null
  }

  export type Pengecekan_produkMaxAggregateOutputType = {
    id: number | null
    nama_pic: string | null
    tanggal: Date | null
  }

  export type Pengecekan_produkCountAggregateOutputType = {
    id: number
    nama_pic: number
    tanggal: number
    _all: number
  }


  export type Pengecekan_produkAvgAggregateInputType = {
    id?: true
  }

  export type Pengecekan_produkSumAggregateInputType = {
    id?: true
  }

  export type Pengecekan_produkMinAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
  }

  export type Pengecekan_produkMaxAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
  }

  export type Pengecekan_produkCountAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
    _all?: true
  }

  export type Pengecekan_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengecekan_produk to aggregate.
     */
    where?: pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_produks to fetch.
     */
    orderBy?: pengecekan_produkOrderByWithRelationInput | pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pengecekan_produks
    **/
    _count?: true | Pengecekan_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pengecekan_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pengecekan_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pengecekan_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pengecekan_produkMaxAggregateInputType
  }

  export type GetPengecekan_produkAggregateType<T extends Pengecekan_produkAggregateArgs> = {
        [P in keyof T & keyof AggregatePengecekan_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengecekan_produk[P]>
      : GetScalarType<T[P], AggregatePengecekan_produk[P]>
  }




  export type pengecekan_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pengecekan_produkWhereInput
    orderBy?: pengecekan_produkOrderByWithAggregationInput | pengecekan_produkOrderByWithAggregationInput[]
    by: Pengecekan_produkScalarFieldEnum[] | Pengecekan_produkScalarFieldEnum
    having?: pengecekan_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pengecekan_produkCountAggregateInputType | true
    _avg?: Pengecekan_produkAvgAggregateInputType
    _sum?: Pengecekan_produkSumAggregateInputType
    _min?: Pengecekan_produkMinAggregateInputType
    _max?: Pengecekan_produkMaxAggregateInputType
  }

  export type Pengecekan_produkGroupByOutputType = {
    id: number
    nama_pic: string
    tanggal: Date
    _count: Pengecekan_produkCountAggregateOutputType | null
    _avg: Pengecekan_produkAvgAggregateOutputType | null
    _sum: Pengecekan_produkSumAggregateOutputType | null
    _min: Pengecekan_produkMinAggregateOutputType | null
    _max: Pengecekan_produkMaxAggregateOutputType | null
  }

  type GetPengecekan_produkGroupByPayload<T extends pengecekan_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pengecekan_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pengecekan_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pengecekan_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Pengecekan_produkGroupByOutputType[P]>
        }
      >
    >


  export type pengecekan_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_pic?: boolean
    tanggal?: boolean
    detail_pengecekan_produk?: boolean | pengecekan_produk$detail_pengecekan_produkArgs<ExtArgs>
    _count?: boolean | Pengecekan_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengecekan_produk"]>

  export type pengecekan_produkSelectScalar = {
    id?: boolean
    nama_pic?: boolean
    tanggal?: boolean
  }

  export type pengecekan_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_produk?: boolean | pengecekan_produk$detail_pengecekan_produkArgs<ExtArgs>
    _count?: boolean | Pengecekan_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pengecekan_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "pengecekan_produk"
    objects: {
      detail_pengecekan_produk: Prisma.$detail_pengecekan_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_pic: string
      tanggal: Date
    }, ExtArgs["result"]["pengecekan_produk"]>
    composites: {}
  }


  type pengecekan_produkGetPayload<S extends boolean | null | undefined | pengecekan_produkDefaultArgs> = $Result.GetResult<Prisma.$pengecekan_produkPayload, S>

  type pengecekan_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<pengecekan_produkFindManyArgs, 'select' | 'include'> & {
      select?: Pengecekan_produkCountAggregateInputType | true
    }

  export interface pengecekan_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pengecekan_produk'], meta: { name: 'pengecekan_produk' } }
    /**
     * Find zero or one Pengecekan_produk that matches the filter.
     * @param {pengecekan_produkFindUniqueArgs} args - Arguments to find a Pengecekan_produk
     * @example
     * // Get one Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pengecekan_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pengecekan_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pengecekan_produkFindUniqueOrThrowArgs} args - Arguments to find a Pengecekan_produk
     * @example
     * // Get one Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pengecekan_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkFindFirstArgs} args - Arguments to find a Pengecekan_produk
     * @example
     * // Get one Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pengecekan_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkFindFirstArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pengecekan_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkFindFirstOrThrowArgs} args - Arguments to find a Pengecekan_produk
     * @example
     * // Get one Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pengecekan_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pengecekan_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengecekan_produks
     * const pengecekan_produks = await prisma.pengecekan_produk.findMany()
     * 
     * // Get first 10 Pengecekan_produks
     * const pengecekan_produks = await prisma.pengecekan_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengecekan_produkWithIdOnly = await prisma.pengecekan_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pengecekan_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pengecekan_produk.
     * @param {pengecekan_produkCreateArgs} args - Arguments to create a Pengecekan_produk.
     * @example
     * // Create one Pengecekan_produk
     * const Pengecekan_produk = await prisma.pengecekan_produk.create({
     *   data: {
     *     // ... data to create a Pengecekan_produk
     *   }
     * })
     * 
    **/
    create<T extends pengecekan_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkCreateArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pengecekan_produks.
     *     @param {pengecekan_produkCreateManyArgs} args - Arguments to create many Pengecekan_produks.
     *     @example
     *     // Create many Pengecekan_produks
     *     const pengecekan_produk = await prisma.pengecekan_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pengecekan_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pengecekan_produk.
     * @param {pengecekan_produkDeleteArgs} args - Arguments to delete one Pengecekan_produk.
     * @example
     * // Delete one Pengecekan_produk
     * const Pengecekan_produk = await prisma.pengecekan_produk.delete({
     *   where: {
     *     // ... filter to delete one Pengecekan_produk
     *   }
     * })
     * 
    **/
    delete<T extends pengecekan_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkDeleteArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pengecekan_produk.
     * @param {pengecekan_produkUpdateArgs} args - Arguments to update one Pengecekan_produk.
     * @example
     * // Update one Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pengecekan_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkUpdateArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pengecekan_produks.
     * @param {pengecekan_produkDeleteManyArgs} args - Arguments to filter Pengecekan_produks to delete.
     * @example
     * // Delete a few Pengecekan_produks
     * const { count } = await prisma.pengecekan_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pengecekan_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengecekan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengecekan_produks
     * const pengecekan_produk = await prisma.pengecekan_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pengecekan_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengecekan_produk.
     * @param {pengecekan_produkUpsertArgs} args - Arguments to update or create a Pengecekan_produk.
     * @example
     * // Update or create a Pengecekan_produk
     * const pengecekan_produk = await prisma.pengecekan_produk.upsert({
     *   create: {
     *     // ... data to create a Pengecekan_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengecekan_produk we want to update
     *   }
     * })
    **/
    upsert<T extends pengecekan_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_produkUpsertArgs<ExtArgs>>
    ): Prisma__pengecekan_produkClient<$Result.GetResult<Prisma.$pengecekan_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pengecekan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkCountArgs} args - Arguments to filter Pengecekan_produks to count.
     * @example
     * // Count the number of Pengecekan_produks
     * const count = await prisma.pengecekan_produk.count({
     *   where: {
     *     // ... the filter for the Pengecekan_produks we want to count
     *   }
     * })
    **/
    count<T extends pengecekan_produkCountArgs>(
      args?: Subset<T, pengecekan_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pengecekan_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengecekan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pengecekan_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pengecekan_produkAggregateArgs>(args: Subset<T, Pengecekan_produkAggregateArgs>): Prisma.PrismaPromise<GetPengecekan_produkAggregateType<T>>

    /**
     * Group by Pengecekan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pengecekan_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pengecekan_produkGroupByArgs['orderBy'] }
        : { orderBy?: pengecekan_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pengecekan_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengecekan_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pengecekan_produk model
   */
  readonly fields: pengecekan_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pengecekan_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pengecekan_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_pengecekan_produk<T extends pengecekan_produk$detail_pengecekan_produkArgs<ExtArgs> = {}>(args?: Subset<T, pengecekan_produk$detail_pengecekan_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pengecekan_produk model
   */ 
  interface pengecekan_produkFieldRefs {
    readonly id: FieldRef<"pengecekan_produk", 'Int'>
    readonly nama_pic: FieldRef<"pengecekan_produk", 'String'>
    readonly tanggal: FieldRef<"pengecekan_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * pengecekan_produk findUnique
   */
  export type pengecekan_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_produk to fetch.
     */
    where: pengecekan_produkWhereUniqueInput
  }


  /**
   * pengecekan_produk findUniqueOrThrow
   */
  export type pengecekan_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_produk to fetch.
     */
    where: pengecekan_produkWhereUniqueInput
  }


  /**
   * pengecekan_produk findFirst
   */
  export type pengecekan_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_produk to fetch.
     */
    where?: pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_produks to fetch.
     */
    orderBy?: pengecekan_produkOrderByWithRelationInput | pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengecekan_produks.
     */
    cursor?: pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengecekan_produks.
     */
    distinct?: Pengecekan_produkScalarFieldEnum | Pengecekan_produkScalarFieldEnum[]
  }


  /**
   * pengecekan_produk findFirstOrThrow
   */
  export type pengecekan_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_produk to fetch.
     */
    where?: pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_produks to fetch.
     */
    orderBy?: pengecekan_produkOrderByWithRelationInput | pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengecekan_produks.
     */
    cursor?: pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengecekan_produks.
     */
    distinct?: Pengecekan_produkScalarFieldEnum | Pengecekan_produkScalarFieldEnum[]
  }


  /**
   * pengecekan_produk findMany
   */
  export type pengecekan_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_produks to fetch.
     */
    where?: pengecekan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_produks to fetch.
     */
    orderBy?: pengecekan_produkOrderByWithRelationInput | pengecekan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pengecekan_produks.
     */
    cursor?: pengecekan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_produks.
     */
    skip?: number
    distinct?: Pengecekan_produkScalarFieldEnum | Pengecekan_produkScalarFieldEnum[]
  }


  /**
   * pengecekan_produk create
   */
  export type pengecekan_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a pengecekan_produk.
     */
    data: XOR<pengecekan_produkCreateInput, pengecekan_produkUncheckedCreateInput>
  }


  /**
   * pengecekan_produk createMany
   */
  export type pengecekan_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pengecekan_produks.
     */
    data: pengecekan_produkCreateManyInput | pengecekan_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pengecekan_produk update
   */
  export type pengecekan_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a pengecekan_produk.
     */
    data: XOR<pengecekan_produkUpdateInput, pengecekan_produkUncheckedUpdateInput>
    /**
     * Choose, which pengecekan_produk to update.
     */
    where: pengecekan_produkWhereUniqueInput
  }


  /**
   * pengecekan_produk updateMany
   */
  export type pengecekan_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pengecekan_produks.
     */
    data: XOR<pengecekan_produkUpdateManyMutationInput, pengecekan_produkUncheckedUpdateManyInput>
    /**
     * Filter which pengecekan_produks to update
     */
    where?: pengecekan_produkWhereInput
  }


  /**
   * pengecekan_produk upsert
   */
  export type pengecekan_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the pengecekan_produk to update in case it exists.
     */
    where: pengecekan_produkWhereUniqueInput
    /**
     * In case the pengecekan_produk found by the `where` argument doesn't exist, create a new pengecekan_produk with this data.
     */
    create: XOR<pengecekan_produkCreateInput, pengecekan_produkUncheckedCreateInput>
    /**
     * In case the pengecekan_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pengecekan_produkUpdateInput, pengecekan_produkUncheckedUpdateInput>
  }


  /**
   * pengecekan_produk delete
   */
  export type pengecekan_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
    /**
     * Filter which pengecekan_produk to delete.
     */
    where: pengecekan_produkWhereUniqueInput
  }


  /**
   * pengecekan_produk deleteMany
   */
  export type pengecekan_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengecekan_produks to delete
     */
    where?: pengecekan_produkWhereInput
  }


  /**
   * pengecekan_produk.detail_pengecekan_produk
   */
  export type pengecekan_produk$detail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    where?: detail_pengecekan_produkWhereInput
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    cursor?: detail_pengecekan_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * pengecekan_produk without action
   */
  export type pengecekan_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_produk
     */
    select?: pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_produkInclude<ExtArgs> | null
  }



  /**
   * Model kondisi_produk
   */

  export type AggregateKondisi_produk = {
    _count: Kondisi_produkCountAggregateOutputType | null
    _avg: Kondisi_produkAvgAggregateOutputType | null
    _sum: Kondisi_produkSumAggregateOutputType | null
    _min: Kondisi_produkMinAggregateOutputType | null
    _max: Kondisi_produkMaxAggregateOutputType | null
  }

  export type Kondisi_produkAvgAggregateOutputType = {
    id: number | null
  }

  export type Kondisi_produkSumAggregateOutputType = {
    id: number | null
  }

  export type Kondisi_produkMinAggregateOutputType = {
    id: number | null
    kondisi: string | null
  }

  export type Kondisi_produkMaxAggregateOutputType = {
    id: number | null
    kondisi: string | null
  }

  export type Kondisi_produkCountAggregateOutputType = {
    id: number
    kondisi: number
    _all: number
  }


  export type Kondisi_produkAvgAggregateInputType = {
    id?: true
  }

  export type Kondisi_produkSumAggregateInputType = {
    id?: true
  }

  export type Kondisi_produkMinAggregateInputType = {
    id?: true
    kondisi?: true
  }

  export type Kondisi_produkMaxAggregateInputType = {
    id?: true
    kondisi?: true
  }

  export type Kondisi_produkCountAggregateInputType = {
    id?: true
    kondisi?: true
    _all?: true
  }

  export type Kondisi_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kondisi_produk to aggregate.
     */
    where?: kondisi_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_produks to fetch.
     */
    orderBy?: kondisi_produkOrderByWithRelationInput | kondisi_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kondisi_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kondisi_produks
    **/
    _count?: true | Kondisi_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kondisi_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kondisi_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kondisi_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kondisi_produkMaxAggregateInputType
  }

  export type GetKondisi_produkAggregateType<T extends Kondisi_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateKondisi_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKondisi_produk[P]>
      : GetScalarType<T[P], AggregateKondisi_produk[P]>
  }




  export type kondisi_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: kondisi_produkWhereInput
    orderBy?: kondisi_produkOrderByWithAggregationInput | kondisi_produkOrderByWithAggregationInput[]
    by: Kondisi_produkScalarFieldEnum[] | Kondisi_produkScalarFieldEnum
    having?: kondisi_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kondisi_produkCountAggregateInputType | true
    _avg?: Kondisi_produkAvgAggregateInputType
    _sum?: Kondisi_produkSumAggregateInputType
    _min?: Kondisi_produkMinAggregateInputType
    _max?: Kondisi_produkMaxAggregateInputType
  }

  export type Kondisi_produkGroupByOutputType = {
    id: number
    kondisi: string
    _count: Kondisi_produkCountAggregateOutputType | null
    _avg: Kondisi_produkAvgAggregateOutputType | null
    _sum: Kondisi_produkSumAggregateOutputType | null
    _min: Kondisi_produkMinAggregateOutputType | null
    _max: Kondisi_produkMaxAggregateOutputType | null
  }

  type GetKondisi_produkGroupByPayload<T extends kondisi_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kondisi_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kondisi_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kondisi_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Kondisi_produkGroupByOutputType[P]>
        }
      >
    >


  export type kondisi_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kondisi?: boolean
    detail_pengecekan_produk?: boolean | kondisi_produk$detail_pengecekan_produkArgs<ExtArgs>
    _count?: boolean | Kondisi_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kondisi_produk"]>

  export type kondisi_produkSelectScalar = {
    id?: boolean
    kondisi?: boolean
  }

  export type kondisi_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_produk?: boolean | kondisi_produk$detail_pengecekan_produkArgs<ExtArgs>
    _count?: boolean | Kondisi_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $kondisi_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "kondisi_produk"
    objects: {
      detail_pengecekan_produk: Prisma.$detail_pengecekan_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      kondisi: string
    }, ExtArgs["result"]["kondisi_produk"]>
    composites: {}
  }


  type kondisi_produkGetPayload<S extends boolean | null | undefined | kondisi_produkDefaultArgs> = $Result.GetResult<Prisma.$kondisi_produkPayload, S>

  type kondisi_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<kondisi_produkFindManyArgs, 'select' | 'include'> & {
      select?: Kondisi_produkCountAggregateInputType | true
    }

  export interface kondisi_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kondisi_produk'], meta: { name: 'kondisi_produk' } }
    /**
     * Find zero or one Kondisi_produk that matches the filter.
     * @param {kondisi_produkFindUniqueArgs} args - Arguments to find a Kondisi_produk
     * @example
     * // Get one Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kondisi_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Kondisi_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kondisi_produkFindUniqueOrThrowArgs} args - Arguments to find a Kondisi_produk
     * @example
     * // Get one Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kondisi_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Kondisi_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkFindFirstArgs} args - Arguments to find a Kondisi_produk
     * @example
     * // Get one Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kondisi_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkFindFirstArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Kondisi_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkFindFirstOrThrowArgs} args - Arguments to find a Kondisi_produk
     * @example
     * // Get one Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kondisi_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Kondisi_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kondisi_produks
     * const kondisi_produks = await prisma.kondisi_produk.findMany()
     * 
     * // Get first 10 Kondisi_produks
     * const kondisi_produks = await prisma.kondisi_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kondisi_produkWithIdOnly = await prisma.kondisi_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kondisi_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Kondisi_produk.
     * @param {kondisi_produkCreateArgs} args - Arguments to create a Kondisi_produk.
     * @example
     * // Create one Kondisi_produk
     * const Kondisi_produk = await prisma.kondisi_produk.create({
     *   data: {
     *     // ... data to create a Kondisi_produk
     *   }
     * })
     * 
    **/
    create<T extends kondisi_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkCreateArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Kondisi_produks.
     *     @param {kondisi_produkCreateManyArgs} args - Arguments to create many Kondisi_produks.
     *     @example
     *     // Create many Kondisi_produks
     *     const kondisi_produk = await prisma.kondisi_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kondisi_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kondisi_produk.
     * @param {kondisi_produkDeleteArgs} args - Arguments to delete one Kondisi_produk.
     * @example
     * // Delete one Kondisi_produk
     * const Kondisi_produk = await prisma.kondisi_produk.delete({
     *   where: {
     *     // ... filter to delete one Kondisi_produk
     *   }
     * })
     * 
    **/
    delete<T extends kondisi_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkDeleteArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Kondisi_produk.
     * @param {kondisi_produkUpdateArgs} args - Arguments to update one Kondisi_produk.
     * @example
     * // Update one Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kondisi_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkUpdateArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Kondisi_produks.
     * @param {kondisi_produkDeleteManyArgs} args - Arguments to filter Kondisi_produks to delete.
     * @example
     * // Delete a few Kondisi_produks
     * const { count } = await prisma.kondisi_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kondisi_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kondisi_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kondisi_produks
     * const kondisi_produk = await prisma.kondisi_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kondisi_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kondisi_produk.
     * @param {kondisi_produkUpsertArgs} args - Arguments to update or create a Kondisi_produk.
     * @example
     * // Update or create a Kondisi_produk
     * const kondisi_produk = await prisma.kondisi_produk.upsert({
     *   create: {
     *     // ... data to create a Kondisi_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kondisi_produk we want to update
     *   }
     * })
    **/
    upsert<T extends kondisi_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_produkUpsertArgs<ExtArgs>>
    ): Prisma__kondisi_produkClient<$Result.GetResult<Prisma.$kondisi_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Kondisi_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkCountArgs} args - Arguments to filter Kondisi_produks to count.
     * @example
     * // Count the number of Kondisi_produks
     * const count = await prisma.kondisi_produk.count({
     *   where: {
     *     // ... the filter for the Kondisi_produks we want to count
     *   }
     * })
    **/
    count<T extends kondisi_produkCountArgs>(
      args?: Subset<T, kondisi_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kondisi_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kondisi_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kondisi_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kondisi_produkAggregateArgs>(args: Subset<T, Kondisi_produkAggregateArgs>): Prisma.PrismaPromise<GetKondisi_produkAggregateType<T>>

    /**
     * Group by Kondisi_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kondisi_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kondisi_produkGroupByArgs['orderBy'] }
        : { orderBy?: kondisi_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kondisi_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKondisi_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kondisi_produk model
   */
  readonly fields: kondisi_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kondisi_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kondisi_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_pengecekan_produk<T extends kondisi_produk$detail_pengecekan_produkArgs<ExtArgs> = {}>(args?: Subset<T, kondisi_produk$detail_pengecekan_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the kondisi_produk model
   */ 
  interface kondisi_produkFieldRefs {
    readonly id: FieldRef<"kondisi_produk", 'Int'>
    readonly kondisi: FieldRef<"kondisi_produk", 'String'>
  }
    

  // Custom InputTypes

  /**
   * kondisi_produk findUnique
   */
  export type kondisi_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_produk to fetch.
     */
    where: kondisi_produkWhereUniqueInput
  }


  /**
   * kondisi_produk findUniqueOrThrow
   */
  export type kondisi_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_produk to fetch.
     */
    where: kondisi_produkWhereUniqueInput
  }


  /**
   * kondisi_produk findFirst
   */
  export type kondisi_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_produk to fetch.
     */
    where?: kondisi_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_produks to fetch.
     */
    orderBy?: kondisi_produkOrderByWithRelationInput | kondisi_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kondisi_produks.
     */
    cursor?: kondisi_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kondisi_produks.
     */
    distinct?: Kondisi_produkScalarFieldEnum | Kondisi_produkScalarFieldEnum[]
  }


  /**
   * kondisi_produk findFirstOrThrow
   */
  export type kondisi_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_produk to fetch.
     */
    where?: kondisi_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_produks to fetch.
     */
    orderBy?: kondisi_produkOrderByWithRelationInput | kondisi_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kondisi_produks.
     */
    cursor?: kondisi_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kondisi_produks.
     */
    distinct?: Kondisi_produkScalarFieldEnum | Kondisi_produkScalarFieldEnum[]
  }


  /**
   * kondisi_produk findMany
   */
  export type kondisi_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_produks to fetch.
     */
    where?: kondisi_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_produks to fetch.
     */
    orderBy?: kondisi_produkOrderByWithRelationInput | kondisi_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kondisi_produks.
     */
    cursor?: kondisi_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_produks.
     */
    skip?: number
    distinct?: Kondisi_produkScalarFieldEnum | Kondisi_produkScalarFieldEnum[]
  }


  /**
   * kondisi_produk create
   */
  export type kondisi_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a kondisi_produk.
     */
    data: XOR<kondisi_produkCreateInput, kondisi_produkUncheckedCreateInput>
  }


  /**
   * kondisi_produk createMany
   */
  export type kondisi_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kondisi_produks.
     */
    data: kondisi_produkCreateManyInput | kondisi_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * kondisi_produk update
   */
  export type kondisi_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a kondisi_produk.
     */
    data: XOR<kondisi_produkUpdateInput, kondisi_produkUncheckedUpdateInput>
    /**
     * Choose, which kondisi_produk to update.
     */
    where: kondisi_produkWhereUniqueInput
  }


  /**
   * kondisi_produk updateMany
   */
  export type kondisi_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kondisi_produks.
     */
    data: XOR<kondisi_produkUpdateManyMutationInput, kondisi_produkUncheckedUpdateManyInput>
    /**
     * Filter which kondisi_produks to update
     */
    where?: kondisi_produkWhereInput
  }


  /**
   * kondisi_produk upsert
   */
  export type kondisi_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the kondisi_produk to update in case it exists.
     */
    where: kondisi_produkWhereUniqueInput
    /**
     * In case the kondisi_produk found by the `where` argument doesn't exist, create a new kondisi_produk with this data.
     */
    create: XOR<kondisi_produkCreateInput, kondisi_produkUncheckedCreateInput>
    /**
     * In case the kondisi_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kondisi_produkUpdateInput, kondisi_produkUncheckedUpdateInput>
  }


  /**
   * kondisi_produk delete
   */
  export type kondisi_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
    /**
     * Filter which kondisi_produk to delete.
     */
    where: kondisi_produkWhereUniqueInput
  }


  /**
   * kondisi_produk deleteMany
   */
  export type kondisi_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kondisi_produks to delete
     */
    where?: kondisi_produkWhereInput
  }


  /**
   * kondisi_produk.detail_pengecekan_produk
   */
  export type kondisi_produk$detail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_produk
     */
    select?: detail_pengecekan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_produkInclude<ExtArgs> | null
    where?: detail_pengecekan_produkWhereInput
    orderBy?: detail_pengecekan_produkOrderByWithRelationInput | detail_pengecekan_produkOrderByWithRelationInput[]
    cursor?: detail_pengecekan_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_produkScalarFieldEnum | Detail_pengecekan_produkScalarFieldEnum[]
  }


  /**
   * kondisi_produk without action
   */
  export type kondisi_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_produk
     */
    select?: kondisi_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_produkInclude<ExtArgs> | null
  }



  /**
   * Model detail_pengecekan_bahan
   */

  export type AggregateDetail_pengecekan_bahan = {
    _count: Detail_pengecekan_bahanCountAggregateOutputType | null
    _avg: Detail_pengecekan_bahanAvgAggregateOutputType | null
    _sum: Detail_pengecekan_bahanSumAggregateOutputType | null
    _min: Detail_pengecekan_bahanMinAggregateOutputType | null
    _max: Detail_pengecekan_bahanMaxAggregateOutputType | null
  }

  export type Detail_pengecekan_bahanAvgAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
    stok_bahan_id: number | null
    kondisi_bahan_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_bahanSumAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
    stok_bahan_id: number | null
    kondisi_bahan_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_bahanMinAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
    stok_bahan_id: number | null
    kondisi_bahan_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_bahanMaxAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
    stok_bahan_id: number | null
    kondisi_bahan_id: number | null
    jumlah: number | null
  }

  export type Detail_pengecekan_bahanCountAggregateOutputType = {
    id: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
    _all: number
  }


  export type Detail_pengecekan_bahanAvgAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
    stok_bahan_id?: true
    kondisi_bahan_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_bahanSumAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
    stok_bahan_id?: true
    kondisi_bahan_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_bahanMinAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
    stok_bahan_id?: true
    kondisi_bahan_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_bahanMaxAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
    stok_bahan_id?: true
    kondisi_bahan_id?: true
    jumlah?: true
  }

  export type Detail_pengecekan_bahanCountAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
    stok_bahan_id?: true
    kondisi_bahan_id?: true
    jumlah?: true
    _all?: true
  }

  export type Detail_pengecekan_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pengecekan_bahan to aggregate.
     */
    where?: detail_pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_bahans to fetch.
     */
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_pengecekan_bahans
    **/
    _count?: true | Detail_pengecekan_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_pengecekan_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_pengecekan_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_pengecekan_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_pengecekan_bahanMaxAggregateInputType
  }

  export type GetDetail_pengecekan_bahanAggregateType<T extends Detail_pengecekan_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_pengecekan_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_pengecekan_bahan[P]>
      : GetScalarType<T[P], AggregateDetail_pengecekan_bahan[P]>
  }




  export type detail_pengecekan_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pengecekan_bahanWhereInput
    orderBy?: detail_pengecekan_bahanOrderByWithAggregationInput | detail_pengecekan_bahanOrderByWithAggregationInput[]
    by: Detail_pengecekan_bahanScalarFieldEnum[] | Detail_pengecekan_bahanScalarFieldEnum
    having?: detail_pengecekan_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_pengecekan_bahanCountAggregateInputType | true
    _avg?: Detail_pengecekan_bahanAvgAggregateInputType
    _sum?: Detail_pengecekan_bahanSumAggregateInputType
    _min?: Detail_pengecekan_bahanMinAggregateInputType
    _max?: Detail_pengecekan_bahanMaxAggregateInputType
  }

  export type Detail_pengecekan_bahanGroupByOutputType = {
    id: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
    _count: Detail_pengecekan_bahanCountAggregateOutputType | null
    _avg: Detail_pengecekan_bahanAvgAggregateOutputType | null
    _sum: Detail_pengecekan_bahanSumAggregateOutputType | null
    _min: Detail_pengecekan_bahanMinAggregateOutputType | null
    _max: Detail_pengecekan_bahanMaxAggregateOutputType | null
  }

  type GetDetail_pengecekan_bahanGroupByPayload<T extends detail_pengecekan_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_pengecekan_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_pengecekan_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_pengecekan_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_pengecekan_bahanGroupByOutputType[P]>
        }
      >
    >


  export type detail_pengecekan_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pengecekan_bahan_id?: boolean
    stok_bahan_id?: boolean
    kondisi_bahan_id?: boolean
    jumlah?: boolean
    pengecekan_bahan?: boolean | pengecekan_bahanDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
    kondisi_bahan?: boolean | kondisi_bahanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_pengecekan_bahan"]>

  export type detail_pengecekan_bahanSelectScalar = {
    id?: boolean
    pengecekan_bahan_id?: boolean
    stok_bahan_id?: boolean
    kondisi_bahan_id?: boolean
    jumlah?: boolean
  }

  export type detail_pengecekan_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pengecekan_bahan?: boolean | pengecekan_bahanDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
    kondisi_bahan?: boolean | kondisi_bahanDefaultArgs<ExtArgs>
  }


  export type $detail_pengecekan_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_pengecekan_bahan"
    objects: {
      pengecekan_bahan: Prisma.$pengecekan_bahanPayload<ExtArgs>
      stok_bahan: Prisma.$stok_bahanPayload<ExtArgs>
      kondisi_bahan: Prisma.$kondisi_bahanPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      pengecekan_bahan_id: number
      stok_bahan_id: number
      kondisi_bahan_id: number
      jumlah: number
    }, ExtArgs["result"]["detail_pengecekan_bahan"]>
    composites: {}
  }


  type detail_pengecekan_bahanGetPayload<S extends boolean | null | undefined | detail_pengecekan_bahanDefaultArgs> = $Result.GetResult<Prisma.$detail_pengecekan_bahanPayload, S>

  type detail_pengecekan_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_pengecekan_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Detail_pengecekan_bahanCountAggregateInputType | true
    }

  export interface detail_pengecekan_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_pengecekan_bahan'], meta: { name: 'detail_pengecekan_bahan' } }
    /**
     * Find zero or one Detail_pengecekan_bahan that matches the filter.
     * @param {detail_pengecekan_bahanFindUniqueArgs} args - Arguments to find a Detail_pengecekan_bahan
     * @example
     * // Get one Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_pengecekan_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_pengecekan_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_pengecekan_bahanFindUniqueOrThrowArgs} args - Arguments to find a Detail_pengecekan_bahan
     * @example
     * // Get one Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_pengecekan_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanFindFirstArgs} args - Arguments to find a Detail_pengecekan_bahan
     * @example
     * // Get one Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_pengecekan_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_pengecekan_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanFindFirstOrThrowArgs} args - Arguments to find a Detail_pengecekan_bahan
     * @example
     * // Get one Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_pengecekan_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_pengecekan_bahans
     * const detail_pengecekan_bahans = await prisma.detail_pengecekan_bahan.findMany()
     * 
     * // Get first 10 Detail_pengecekan_bahans
     * const detail_pengecekan_bahans = await prisma.detail_pengecekan_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_pengecekan_bahanWithIdOnly = await prisma.detail_pengecekan_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_pengecekan_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_pengecekan_bahan.
     * @param {detail_pengecekan_bahanCreateArgs} args - Arguments to create a Detail_pengecekan_bahan.
     * @example
     * // Create one Detail_pengecekan_bahan
     * const Detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.create({
     *   data: {
     *     // ... data to create a Detail_pengecekan_bahan
     *   }
     * })
     * 
    **/
    create<T extends detail_pengecekan_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanCreateArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_pengecekan_bahans.
     *     @param {detail_pengecekan_bahanCreateManyArgs} args - Arguments to create many Detail_pengecekan_bahans.
     *     @example
     *     // Create many Detail_pengecekan_bahans
     *     const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_pengecekan_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_pengecekan_bahan.
     * @param {detail_pengecekan_bahanDeleteArgs} args - Arguments to delete one Detail_pengecekan_bahan.
     * @example
     * // Delete one Detail_pengecekan_bahan
     * const Detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.delete({
     *   where: {
     *     // ... filter to delete one Detail_pengecekan_bahan
     *   }
     * })
     * 
    **/
    delete<T extends detail_pengecekan_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanDeleteArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_pengecekan_bahan.
     * @param {detail_pengecekan_bahanUpdateArgs} args - Arguments to update one Detail_pengecekan_bahan.
     * @example
     * // Update one Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_pengecekan_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanUpdateArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_pengecekan_bahans.
     * @param {detail_pengecekan_bahanDeleteManyArgs} args - Arguments to filter Detail_pengecekan_bahans to delete.
     * @example
     * // Delete a few Detail_pengecekan_bahans
     * const { count } = await prisma.detail_pengecekan_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_pengecekan_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pengecekan_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_pengecekan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_pengecekan_bahans
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_pengecekan_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_pengecekan_bahan.
     * @param {detail_pengecekan_bahanUpsertArgs} args - Arguments to update or create a Detail_pengecekan_bahan.
     * @example
     * // Update or create a Detail_pengecekan_bahan
     * const detail_pengecekan_bahan = await prisma.detail_pengecekan_bahan.upsert({
     *   create: {
     *     // ... data to create a Detail_pengecekan_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_pengecekan_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends detail_pengecekan_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pengecekan_bahanUpsertArgs<ExtArgs>>
    ): Prisma__detail_pengecekan_bahanClient<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_pengecekan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanCountArgs} args - Arguments to filter Detail_pengecekan_bahans to count.
     * @example
     * // Count the number of Detail_pengecekan_bahans
     * const count = await prisma.detail_pengecekan_bahan.count({
     *   where: {
     *     // ... the filter for the Detail_pengecekan_bahans we want to count
     *   }
     * })
    **/
    count<T extends detail_pengecekan_bahanCountArgs>(
      args?: Subset<T, detail_pengecekan_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_pengecekan_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_pengecekan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_pengecekan_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_pengecekan_bahanAggregateArgs>(args: Subset<T, Detail_pengecekan_bahanAggregateArgs>): Prisma.PrismaPromise<GetDetail_pengecekan_bahanAggregateType<T>>

    /**
     * Group by Detail_pengecekan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pengecekan_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_pengecekan_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_pengecekan_bahanGroupByArgs['orderBy'] }
        : { orderBy?: detail_pengecekan_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_pengecekan_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_pengecekan_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_pengecekan_bahan model
   */
  readonly fields: detail_pengecekan_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_pengecekan_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_pengecekan_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pengecekan_bahan<T extends pengecekan_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pengecekan_bahanDefaultArgs<ExtArgs>>): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stok_bahan<T extends stok_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahanDefaultArgs<ExtArgs>>): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    kondisi_bahan<T extends kondisi_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kondisi_bahanDefaultArgs<ExtArgs>>): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_pengecekan_bahan model
   */ 
  interface detail_pengecekan_bahanFieldRefs {
    readonly id: FieldRef<"detail_pengecekan_bahan", 'Int'>
    readonly pengecekan_bahan_id: FieldRef<"detail_pengecekan_bahan", 'Int'>
    readonly stok_bahan_id: FieldRef<"detail_pengecekan_bahan", 'Int'>
    readonly kondisi_bahan_id: FieldRef<"detail_pengecekan_bahan", 'Int'>
    readonly jumlah: FieldRef<"detail_pengecekan_bahan", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * detail_pengecekan_bahan findUnique
   */
  export type detail_pengecekan_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_bahan to fetch.
     */
    where: detail_pengecekan_bahanWhereUniqueInput
  }


  /**
   * detail_pengecekan_bahan findUniqueOrThrow
   */
  export type detail_pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_bahan to fetch.
     */
    where: detail_pengecekan_bahanWhereUniqueInput
  }


  /**
   * detail_pengecekan_bahan findFirst
   */
  export type detail_pengecekan_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_bahan to fetch.
     */
    where?: detail_pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_bahans to fetch.
     */
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pengecekan_bahans.
     */
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pengecekan_bahans.
     */
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_bahan findFirstOrThrow
   */
  export type detail_pengecekan_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_bahan to fetch.
     */
    where?: detail_pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_bahans to fetch.
     */
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pengecekan_bahans.
     */
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pengecekan_bahans.
     */
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_bahan findMany
   */
  export type detail_pengecekan_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pengecekan_bahans to fetch.
     */
    where?: detail_pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pengecekan_bahans to fetch.
     */
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_pengecekan_bahans.
     */
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pengecekan_bahans.
     */
    skip?: number
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pengecekan_bahan create
   */
  export type detail_pengecekan_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_pengecekan_bahan.
     */
    data: XOR<detail_pengecekan_bahanCreateInput, detail_pengecekan_bahanUncheckedCreateInput>
  }


  /**
   * detail_pengecekan_bahan createMany
   */
  export type detail_pengecekan_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_pengecekan_bahans.
     */
    data: detail_pengecekan_bahanCreateManyInput | detail_pengecekan_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_pengecekan_bahan update
   */
  export type detail_pengecekan_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_pengecekan_bahan.
     */
    data: XOR<detail_pengecekan_bahanUpdateInput, detail_pengecekan_bahanUncheckedUpdateInput>
    /**
     * Choose, which detail_pengecekan_bahan to update.
     */
    where: detail_pengecekan_bahanWhereUniqueInput
  }


  /**
   * detail_pengecekan_bahan updateMany
   */
  export type detail_pengecekan_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_pengecekan_bahans.
     */
    data: XOR<detail_pengecekan_bahanUpdateManyMutationInput, detail_pengecekan_bahanUncheckedUpdateManyInput>
    /**
     * Filter which detail_pengecekan_bahans to update
     */
    where?: detail_pengecekan_bahanWhereInput
  }


  /**
   * detail_pengecekan_bahan upsert
   */
  export type detail_pengecekan_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_pengecekan_bahan to update in case it exists.
     */
    where: detail_pengecekan_bahanWhereUniqueInput
    /**
     * In case the detail_pengecekan_bahan found by the `where` argument doesn't exist, create a new detail_pengecekan_bahan with this data.
     */
    create: XOR<detail_pengecekan_bahanCreateInput, detail_pengecekan_bahanUncheckedCreateInput>
    /**
     * In case the detail_pengecekan_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_pengecekan_bahanUpdateInput, detail_pengecekan_bahanUncheckedUpdateInput>
  }


  /**
   * detail_pengecekan_bahan delete
   */
  export type detail_pengecekan_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter which detail_pengecekan_bahan to delete.
     */
    where: detail_pengecekan_bahanWhereUniqueInput
  }


  /**
   * detail_pengecekan_bahan deleteMany
   */
  export type detail_pengecekan_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pengecekan_bahans to delete
     */
    where?: detail_pengecekan_bahanWhereInput
  }


  /**
   * detail_pengecekan_bahan without action
   */
  export type detail_pengecekan_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
  }



  /**
   * Model pengecekan_bahan
   */

  export type AggregatePengecekan_bahan = {
    _count: Pengecekan_bahanCountAggregateOutputType | null
    _avg: Pengecekan_bahanAvgAggregateOutputType | null
    _sum: Pengecekan_bahanSumAggregateOutputType | null
    _min: Pengecekan_bahanMinAggregateOutputType | null
    _max: Pengecekan_bahanMaxAggregateOutputType | null
  }

  export type Pengecekan_bahanAvgAggregateOutputType = {
    id: number | null
  }

  export type Pengecekan_bahanSumAggregateOutputType = {
    id: number | null
  }

  export type Pengecekan_bahanMinAggregateOutputType = {
    id: number | null
    nama_pic: string | null
    tanggal: Date | null
  }

  export type Pengecekan_bahanMaxAggregateOutputType = {
    id: number | null
    nama_pic: string | null
    tanggal: Date | null
  }

  export type Pengecekan_bahanCountAggregateOutputType = {
    id: number
    nama_pic: number
    tanggal: number
    _all: number
  }


  export type Pengecekan_bahanAvgAggregateInputType = {
    id?: true
  }

  export type Pengecekan_bahanSumAggregateInputType = {
    id?: true
  }

  export type Pengecekan_bahanMinAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
  }

  export type Pengecekan_bahanMaxAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
  }

  export type Pengecekan_bahanCountAggregateInputType = {
    id?: true
    nama_pic?: true
    tanggal?: true
    _all?: true
  }

  export type Pengecekan_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengecekan_bahan to aggregate.
     */
    where?: pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_bahans to fetch.
     */
    orderBy?: pengecekan_bahanOrderByWithRelationInput | pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pengecekan_bahans
    **/
    _count?: true | Pengecekan_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pengecekan_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pengecekan_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pengecekan_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pengecekan_bahanMaxAggregateInputType
  }

  export type GetPengecekan_bahanAggregateType<T extends Pengecekan_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengecekan_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengecekan_bahan[P]>
      : GetScalarType<T[P], AggregatePengecekan_bahan[P]>
  }




  export type pengecekan_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pengecekan_bahanWhereInput
    orderBy?: pengecekan_bahanOrderByWithAggregationInput | pengecekan_bahanOrderByWithAggregationInput[]
    by: Pengecekan_bahanScalarFieldEnum[] | Pengecekan_bahanScalarFieldEnum
    having?: pengecekan_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pengecekan_bahanCountAggregateInputType | true
    _avg?: Pengecekan_bahanAvgAggregateInputType
    _sum?: Pengecekan_bahanSumAggregateInputType
    _min?: Pengecekan_bahanMinAggregateInputType
    _max?: Pengecekan_bahanMaxAggregateInputType
  }

  export type Pengecekan_bahanGroupByOutputType = {
    id: number
    nama_pic: string
    tanggal: Date
    _count: Pengecekan_bahanCountAggregateOutputType | null
    _avg: Pengecekan_bahanAvgAggregateOutputType | null
    _sum: Pengecekan_bahanSumAggregateOutputType | null
    _min: Pengecekan_bahanMinAggregateOutputType | null
    _max: Pengecekan_bahanMaxAggregateOutputType | null
  }

  type GetPengecekan_bahanGroupByPayload<T extends pengecekan_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pengecekan_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pengecekan_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pengecekan_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Pengecekan_bahanGroupByOutputType[P]>
        }
      >
    >


  export type pengecekan_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_pic?: boolean
    tanggal?: boolean
    detail_pengecekan_bahan?: boolean | pengecekan_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    _count?: boolean | Pengecekan_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengecekan_bahan"]>

  export type pengecekan_bahanSelectScalar = {
    id?: boolean
    nama_pic?: boolean
    tanggal?: boolean
  }

  export type pengecekan_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_bahan?: boolean | pengecekan_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    _count?: boolean | Pengecekan_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pengecekan_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "pengecekan_bahan"
    objects: {
      detail_pengecekan_bahan: Prisma.$detail_pengecekan_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_pic: string
      tanggal: Date
    }, ExtArgs["result"]["pengecekan_bahan"]>
    composites: {}
  }


  type pengecekan_bahanGetPayload<S extends boolean | null | undefined | pengecekan_bahanDefaultArgs> = $Result.GetResult<Prisma.$pengecekan_bahanPayload, S>

  type pengecekan_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<pengecekan_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Pengecekan_bahanCountAggregateInputType | true
    }

  export interface pengecekan_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pengecekan_bahan'], meta: { name: 'pengecekan_bahan' } }
    /**
     * Find zero or one Pengecekan_bahan that matches the filter.
     * @param {pengecekan_bahanFindUniqueArgs} args - Arguments to find a Pengecekan_bahan
     * @example
     * // Get one Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pengecekan_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pengecekan_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pengecekan_bahanFindUniqueOrThrowArgs} args - Arguments to find a Pengecekan_bahan
     * @example
     * // Get one Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pengecekan_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanFindFirstArgs} args - Arguments to find a Pengecekan_bahan
     * @example
     * // Get one Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pengecekan_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pengecekan_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanFindFirstOrThrowArgs} args - Arguments to find a Pengecekan_bahan
     * @example
     * // Get one Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pengecekan_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengecekan_bahans
     * const pengecekan_bahans = await prisma.pengecekan_bahan.findMany()
     * 
     * // Get first 10 Pengecekan_bahans
     * const pengecekan_bahans = await prisma.pengecekan_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengecekan_bahanWithIdOnly = await prisma.pengecekan_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pengecekan_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pengecekan_bahan.
     * @param {pengecekan_bahanCreateArgs} args - Arguments to create a Pengecekan_bahan.
     * @example
     * // Create one Pengecekan_bahan
     * const Pengecekan_bahan = await prisma.pengecekan_bahan.create({
     *   data: {
     *     // ... data to create a Pengecekan_bahan
     *   }
     * })
     * 
    **/
    create<T extends pengecekan_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanCreateArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pengecekan_bahans.
     *     @param {pengecekan_bahanCreateManyArgs} args - Arguments to create many Pengecekan_bahans.
     *     @example
     *     // Create many Pengecekan_bahans
     *     const pengecekan_bahan = await prisma.pengecekan_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pengecekan_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pengecekan_bahan.
     * @param {pengecekan_bahanDeleteArgs} args - Arguments to delete one Pengecekan_bahan.
     * @example
     * // Delete one Pengecekan_bahan
     * const Pengecekan_bahan = await prisma.pengecekan_bahan.delete({
     *   where: {
     *     // ... filter to delete one Pengecekan_bahan
     *   }
     * })
     * 
    **/
    delete<T extends pengecekan_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanDeleteArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pengecekan_bahan.
     * @param {pengecekan_bahanUpdateArgs} args - Arguments to update one Pengecekan_bahan.
     * @example
     * // Update one Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pengecekan_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanUpdateArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pengecekan_bahans.
     * @param {pengecekan_bahanDeleteManyArgs} args - Arguments to filter Pengecekan_bahans to delete.
     * @example
     * // Delete a few Pengecekan_bahans
     * const { count } = await prisma.pengecekan_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pengecekan_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pengecekan_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengecekan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengecekan_bahans
     * const pengecekan_bahan = await prisma.pengecekan_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pengecekan_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengecekan_bahan.
     * @param {pengecekan_bahanUpsertArgs} args - Arguments to update or create a Pengecekan_bahan.
     * @example
     * // Update or create a Pengecekan_bahan
     * const pengecekan_bahan = await prisma.pengecekan_bahan.upsert({
     *   create: {
     *     // ... data to create a Pengecekan_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengecekan_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends pengecekan_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pengecekan_bahanUpsertArgs<ExtArgs>>
    ): Prisma__pengecekan_bahanClient<$Result.GetResult<Prisma.$pengecekan_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pengecekan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanCountArgs} args - Arguments to filter Pengecekan_bahans to count.
     * @example
     * // Count the number of Pengecekan_bahans
     * const count = await prisma.pengecekan_bahan.count({
     *   where: {
     *     // ... the filter for the Pengecekan_bahans we want to count
     *   }
     * })
    **/
    count<T extends pengecekan_bahanCountArgs>(
      args?: Subset<T, pengecekan_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pengecekan_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengecekan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pengecekan_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pengecekan_bahanAggregateArgs>(args: Subset<T, Pengecekan_bahanAggregateArgs>): Prisma.PrismaPromise<GetPengecekan_bahanAggregateType<T>>

    /**
     * Group by Pengecekan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengecekan_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pengecekan_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pengecekan_bahanGroupByArgs['orderBy'] }
        : { orderBy?: pengecekan_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pengecekan_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengecekan_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pengecekan_bahan model
   */
  readonly fields: pengecekan_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pengecekan_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pengecekan_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_pengecekan_bahan<T extends pengecekan_bahan$detail_pengecekan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, pengecekan_bahan$detail_pengecekan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pengecekan_bahan model
   */ 
  interface pengecekan_bahanFieldRefs {
    readonly id: FieldRef<"pengecekan_bahan", 'Int'>
    readonly nama_pic: FieldRef<"pengecekan_bahan", 'String'>
    readonly tanggal: FieldRef<"pengecekan_bahan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * pengecekan_bahan findUnique
   */
  export type pengecekan_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_bahan to fetch.
     */
    where: pengecekan_bahanWhereUniqueInput
  }


  /**
   * pengecekan_bahan findUniqueOrThrow
   */
  export type pengecekan_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_bahan to fetch.
     */
    where: pengecekan_bahanWhereUniqueInput
  }


  /**
   * pengecekan_bahan findFirst
   */
  export type pengecekan_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_bahan to fetch.
     */
    where?: pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_bahans to fetch.
     */
    orderBy?: pengecekan_bahanOrderByWithRelationInput | pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengecekan_bahans.
     */
    cursor?: pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengecekan_bahans.
     */
    distinct?: Pengecekan_bahanScalarFieldEnum | Pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * pengecekan_bahan findFirstOrThrow
   */
  export type pengecekan_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_bahan to fetch.
     */
    where?: pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_bahans to fetch.
     */
    orderBy?: pengecekan_bahanOrderByWithRelationInput | pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengecekan_bahans.
     */
    cursor?: pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengecekan_bahans.
     */
    distinct?: Pengecekan_bahanScalarFieldEnum | Pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * pengecekan_bahan findMany
   */
  export type pengecekan_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pengecekan_bahans to fetch.
     */
    where?: pengecekan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengecekan_bahans to fetch.
     */
    orderBy?: pengecekan_bahanOrderByWithRelationInput | pengecekan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pengecekan_bahans.
     */
    cursor?: pengecekan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengecekan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengecekan_bahans.
     */
    skip?: number
    distinct?: Pengecekan_bahanScalarFieldEnum | Pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * pengecekan_bahan create
   */
  export type pengecekan_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a pengecekan_bahan.
     */
    data: XOR<pengecekan_bahanCreateInput, pengecekan_bahanUncheckedCreateInput>
  }


  /**
   * pengecekan_bahan createMany
   */
  export type pengecekan_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pengecekan_bahans.
     */
    data: pengecekan_bahanCreateManyInput | pengecekan_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pengecekan_bahan update
   */
  export type pengecekan_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a pengecekan_bahan.
     */
    data: XOR<pengecekan_bahanUpdateInput, pengecekan_bahanUncheckedUpdateInput>
    /**
     * Choose, which pengecekan_bahan to update.
     */
    where: pengecekan_bahanWhereUniqueInput
  }


  /**
   * pengecekan_bahan updateMany
   */
  export type pengecekan_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pengecekan_bahans.
     */
    data: XOR<pengecekan_bahanUpdateManyMutationInput, pengecekan_bahanUncheckedUpdateManyInput>
    /**
     * Filter which pengecekan_bahans to update
     */
    where?: pengecekan_bahanWhereInput
  }


  /**
   * pengecekan_bahan upsert
   */
  export type pengecekan_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the pengecekan_bahan to update in case it exists.
     */
    where: pengecekan_bahanWhereUniqueInput
    /**
     * In case the pengecekan_bahan found by the `where` argument doesn't exist, create a new pengecekan_bahan with this data.
     */
    create: XOR<pengecekan_bahanCreateInput, pengecekan_bahanUncheckedCreateInput>
    /**
     * In case the pengecekan_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pengecekan_bahanUpdateInput, pengecekan_bahanUncheckedUpdateInput>
  }


  /**
   * pengecekan_bahan delete
   */
  export type pengecekan_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
    /**
     * Filter which pengecekan_bahan to delete.
     */
    where: pengecekan_bahanWhereUniqueInput
  }


  /**
   * pengecekan_bahan deleteMany
   */
  export type pengecekan_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengecekan_bahans to delete
     */
    where?: pengecekan_bahanWhereInput
  }


  /**
   * pengecekan_bahan.detail_pengecekan_bahan
   */
  export type pengecekan_bahan$detail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    where?: detail_pengecekan_bahanWhereInput
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * pengecekan_bahan without action
   */
  export type pengecekan_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengecekan_bahan
     */
    select?: pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pengecekan_bahanInclude<ExtArgs> | null
  }



  /**
   * Model kondisi_bahan
   */

  export type AggregateKondisi_bahan = {
    _count: Kondisi_bahanCountAggregateOutputType | null
    _avg: Kondisi_bahanAvgAggregateOutputType | null
    _sum: Kondisi_bahanSumAggregateOutputType | null
    _min: Kondisi_bahanMinAggregateOutputType | null
    _max: Kondisi_bahanMaxAggregateOutputType | null
  }

  export type Kondisi_bahanAvgAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
  }

  export type Kondisi_bahanSumAggregateOutputType = {
    id: number | null
    pengecekan_bahan_id: number | null
  }

  export type Kondisi_bahanMinAggregateOutputType = {
    id: number | null
    kondisi: string | null
    pengecekan_bahan_id: number | null
  }

  export type Kondisi_bahanMaxAggregateOutputType = {
    id: number | null
    kondisi: string | null
    pengecekan_bahan_id: number | null
  }

  export type Kondisi_bahanCountAggregateOutputType = {
    id: number
    kondisi: number
    pengecekan_bahan_id: number
    _all: number
  }


  export type Kondisi_bahanAvgAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
  }

  export type Kondisi_bahanSumAggregateInputType = {
    id?: true
    pengecekan_bahan_id?: true
  }

  export type Kondisi_bahanMinAggregateInputType = {
    id?: true
    kondisi?: true
    pengecekan_bahan_id?: true
  }

  export type Kondisi_bahanMaxAggregateInputType = {
    id?: true
    kondisi?: true
    pengecekan_bahan_id?: true
  }

  export type Kondisi_bahanCountAggregateInputType = {
    id?: true
    kondisi?: true
    pengecekan_bahan_id?: true
    _all?: true
  }

  export type Kondisi_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kondisi_bahan to aggregate.
     */
    where?: kondisi_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_bahans to fetch.
     */
    orderBy?: kondisi_bahanOrderByWithRelationInput | kondisi_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kondisi_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kondisi_bahans
    **/
    _count?: true | Kondisi_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kondisi_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kondisi_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kondisi_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kondisi_bahanMaxAggregateInputType
  }

  export type GetKondisi_bahanAggregateType<T extends Kondisi_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateKondisi_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKondisi_bahan[P]>
      : GetScalarType<T[P], AggregateKondisi_bahan[P]>
  }




  export type kondisi_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: kondisi_bahanWhereInput
    orderBy?: kondisi_bahanOrderByWithAggregationInput | kondisi_bahanOrderByWithAggregationInput[]
    by: Kondisi_bahanScalarFieldEnum[] | Kondisi_bahanScalarFieldEnum
    having?: kondisi_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kondisi_bahanCountAggregateInputType | true
    _avg?: Kondisi_bahanAvgAggregateInputType
    _sum?: Kondisi_bahanSumAggregateInputType
    _min?: Kondisi_bahanMinAggregateInputType
    _max?: Kondisi_bahanMaxAggregateInputType
  }

  export type Kondisi_bahanGroupByOutputType = {
    id: number
    kondisi: string
    pengecekan_bahan_id: number
    _count: Kondisi_bahanCountAggregateOutputType | null
    _avg: Kondisi_bahanAvgAggregateOutputType | null
    _sum: Kondisi_bahanSumAggregateOutputType | null
    _min: Kondisi_bahanMinAggregateOutputType | null
    _max: Kondisi_bahanMaxAggregateOutputType | null
  }

  type GetKondisi_bahanGroupByPayload<T extends kondisi_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kondisi_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kondisi_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kondisi_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Kondisi_bahanGroupByOutputType[P]>
        }
      >
    >


  export type kondisi_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kondisi?: boolean
    pengecekan_bahan_id?: boolean
    detail_pengecekan_bahan?: boolean | kondisi_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    _count?: boolean | Kondisi_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kondisi_bahan"]>

  export type kondisi_bahanSelectScalar = {
    id?: boolean
    kondisi?: boolean
    pengecekan_bahan_id?: boolean
  }

  export type kondisi_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pengecekan_bahan?: boolean | kondisi_bahan$detail_pengecekan_bahanArgs<ExtArgs>
    _count?: boolean | Kondisi_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $kondisi_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "kondisi_bahan"
    objects: {
      detail_pengecekan_bahan: Prisma.$detail_pengecekan_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      kondisi: string
      pengecekan_bahan_id: number
    }, ExtArgs["result"]["kondisi_bahan"]>
    composites: {}
  }


  type kondisi_bahanGetPayload<S extends boolean | null | undefined | kondisi_bahanDefaultArgs> = $Result.GetResult<Prisma.$kondisi_bahanPayload, S>

  type kondisi_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<kondisi_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Kondisi_bahanCountAggregateInputType | true
    }

  export interface kondisi_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kondisi_bahan'], meta: { name: 'kondisi_bahan' } }
    /**
     * Find zero or one Kondisi_bahan that matches the filter.
     * @param {kondisi_bahanFindUniqueArgs} args - Arguments to find a Kondisi_bahan
     * @example
     * // Get one Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kondisi_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Kondisi_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kondisi_bahanFindUniqueOrThrowArgs} args - Arguments to find a Kondisi_bahan
     * @example
     * // Get one Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kondisi_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Kondisi_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanFindFirstArgs} args - Arguments to find a Kondisi_bahan
     * @example
     * // Get one Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kondisi_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Kondisi_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanFindFirstOrThrowArgs} args - Arguments to find a Kondisi_bahan
     * @example
     * // Get one Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kondisi_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Kondisi_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kondisi_bahans
     * const kondisi_bahans = await prisma.kondisi_bahan.findMany()
     * 
     * // Get first 10 Kondisi_bahans
     * const kondisi_bahans = await prisma.kondisi_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kondisi_bahanWithIdOnly = await prisma.kondisi_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kondisi_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Kondisi_bahan.
     * @param {kondisi_bahanCreateArgs} args - Arguments to create a Kondisi_bahan.
     * @example
     * // Create one Kondisi_bahan
     * const Kondisi_bahan = await prisma.kondisi_bahan.create({
     *   data: {
     *     // ... data to create a Kondisi_bahan
     *   }
     * })
     * 
    **/
    create<T extends kondisi_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanCreateArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Kondisi_bahans.
     *     @param {kondisi_bahanCreateManyArgs} args - Arguments to create many Kondisi_bahans.
     *     @example
     *     // Create many Kondisi_bahans
     *     const kondisi_bahan = await prisma.kondisi_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kondisi_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kondisi_bahan.
     * @param {kondisi_bahanDeleteArgs} args - Arguments to delete one Kondisi_bahan.
     * @example
     * // Delete one Kondisi_bahan
     * const Kondisi_bahan = await prisma.kondisi_bahan.delete({
     *   where: {
     *     // ... filter to delete one Kondisi_bahan
     *   }
     * })
     * 
    **/
    delete<T extends kondisi_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanDeleteArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Kondisi_bahan.
     * @param {kondisi_bahanUpdateArgs} args - Arguments to update one Kondisi_bahan.
     * @example
     * // Update one Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kondisi_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanUpdateArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Kondisi_bahans.
     * @param {kondisi_bahanDeleteManyArgs} args - Arguments to filter Kondisi_bahans to delete.
     * @example
     * // Delete a few Kondisi_bahans
     * const { count } = await prisma.kondisi_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kondisi_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kondisi_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kondisi_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kondisi_bahans
     * const kondisi_bahan = await prisma.kondisi_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kondisi_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kondisi_bahan.
     * @param {kondisi_bahanUpsertArgs} args - Arguments to update or create a Kondisi_bahan.
     * @example
     * // Update or create a Kondisi_bahan
     * const kondisi_bahan = await prisma.kondisi_bahan.upsert({
     *   create: {
     *     // ... data to create a Kondisi_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kondisi_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends kondisi_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, kondisi_bahanUpsertArgs<ExtArgs>>
    ): Prisma__kondisi_bahanClient<$Result.GetResult<Prisma.$kondisi_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Kondisi_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanCountArgs} args - Arguments to filter Kondisi_bahans to count.
     * @example
     * // Count the number of Kondisi_bahans
     * const count = await prisma.kondisi_bahan.count({
     *   where: {
     *     // ... the filter for the Kondisi_bahans we want to count
     *   }
     * })
    **/
    count<T extends kondisi_bahanCountArgs>(
      args?: Subset<T, kondisi_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kondisi_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kondisi_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kondisi_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kondisi_bahanAggregateArgs>(args: Subset<T, Kondisi_bahanAggregateArgs>): Prisma.PrismaPromise<GetKondisi_bahanAggregateType<T>>

    /**
     * Group by Kondisi_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kondisi_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kondisi_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kondisi_bahanGroupByArgs['orderBy'] }
        : { orderBy?: kondisi_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kondisi_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKondisi_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kondisi_bahan model
   */
  readonly fields: kondisi_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kondisi_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kondisi_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_pengecekan_bahan<T extends kondisi_bahan$detail_pengecekan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, kondisi_bahan$detail_pengecekan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pengecekan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the kondisi_bahan model
   */ 
  interface kondisi_bahanFieldRefs {
    readonly id: FieldRef<"kondisi_bahan", 'Int'>
    readonly kondisi: FieldRef<"kondisi_bahan", 'String'>
    readonly pengecekan_bahan_id: FieldRef<"kondisi_bahan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * kondisi_bahan findUnique
   */
  export type kondisi_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_bahan to fetch.
     */
    where: kondisi_bahanWhereUniqueInput
  }


  /**
   * kondisi_bahan findUniqueOrThrow
   */
  export type kondisi_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_bahan to fetch.
     */
    where: kondisi_bahanWhereUniqueInput
  }


  /**
   * kondisi_bahan findFirst
   */
  export type kondisi_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_bahan to fetch.
     */
    where?: kondisi_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_bahans to fetch.
     */
    orderBy?: kondisi_bahanOrderByWithRelationInput | kondisi_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kondisi_bahans.
     */
    cursor?: kondisi_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kondisi_bahans.
     */
    distinct?: Kondisi_bahanScalarFieldEnum | Kondisi_bahanScalarFieldEnum[]
  }


  /**
   * kondisi_bahan findFirstOrThrow
   */
  export type kondisi_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_bahan to fetch.
     */
    where?: kondisi_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_bahans to fetch.
     */
    orderBy?: kondisi_bahanOrderByWithRelationInput | kondisi_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kondisi_bahans.
     */
    cursor?: kondisi_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kondisi_bahans.
     */
    distinct?: Kondisi_bahanScalarFieldEnum | Kondisi_bahanScalarFieldEnum[]
  }


  /**
   * kondisi_bahan findMany
   */
  export type kondisi_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter, which kondisi_bahans to fetch.
     */
    where?: kondisi_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kondisi_bahans to fetch.
     */
    orderBy?: kondisi_bahanOrderByWithRelationInput | kondisi_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kondisi_bahans.
     */
    cursor?: kondisi_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kondisi_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kondisi_bahans.
     */
    skip?: number
    distinct?: Kondisi_bahanScalarFieldEnum | Kondisi_bahanScalarFieldEnum[]
  }


  /**
   * kondisi_bahan create
   */
  export type kondisi_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a kondisi_bahan.
     */
    data: XOR<kondisi_bahanCreateInput, kondisi_bahanUncheckedCreateInput>
  }


  /**
   * kondisi_bahan createMany
   */
  export type kondisi_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kondisi_bahans.
     */
    data: kondisi_bahanCreateManyInput | kondisi_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * kondisi_bahan update
   */
  export type kondisi_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a kondisi_bahan.
     */
    data: XOR<kondisi_bahanUpdateInput, kondisi_bahanUncheckedUpdateInput>
    /**
     * Choose, which kondisi_bahan to update.
     */
    where: kondisi_bahanWhereUniqueInput
  }


  /**
   * kondisi_bahan updateMany
   */
  export type kondisi_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kondisi_bahans.
     */
    data: XOR<kondisi_bahanUpdateManyMutationInput, kondisi_bahanUncheckedUpdateManyInput>
    /**
     * Filter which kondisi_bahans to update
     */
    where?: kondisi_bahanWhereInput
  }


  /**
   * kondisi_bahan upsert
   */
  export type kondisi_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the kondisi_bahan to update in case it exists.
     */
    where: kondisi_bahanWhereUniqueInput
    /**
     * In case the kondisi_bahan found by the `where` argument doesn't exist, create a new kondisi_bahan with this data.
     */
    create: XOR<kondisi_bahanCreateInput, kondisi_bahanUncheckedCreateInput>
    /**
     * In case the kondisi_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kondisi_bahanUpdateInput, kondisi_bahanUncheckedUpdateInput>
  }


  /**
   * kondisi_bahan delete
   */
  export type kondisi_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
    /**
     * Filter which kondisi_bahan to delete.
     */
    where: kondisi_bahanWhereUniqueInput
  }


  /**
   * kondisi_bahan deleteMany
   */
  export type kondisi_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which kondisi_bahans to delete
     */
    where?: kondisi_bahanWhereInput
  }


  /**
   * kondisi_bahan.detail_pengecekan_bahan
   */
  export type kondisi_bahan$detail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pengecekan_bahan
     */
    select?: detail_pengecekan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pengecekan_bahanInclude<ExtArgs> | null
    where?: detail_pengecekan_bahanWhereInput
    orderBy?: detail_pengecekan_bahanOrderByWithRelationInput | detail_pengecekan_bahanOrderByWithRelationInput[]
    cursor?: detail_pengecekan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pengecekan_bahanScalarFieldEnum | Detail_pengecekan_bahanScalarFieldEnum[]
  }


  /**
   * kondisi_bahan without action
   */
  export type kondisi_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kondisi_bahan
     */
    select?: kondisi_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kondisi_bahanInclude<ExtArgs> | null
  }



  /**
   * Model detail_pemesanan_bahan
   */

  export type AggregateDetail_pemesanan_bahan = {
    _count: Detail_pemesanan_bahanCountAggregateOutputType | null
    _avg: Detail_pemesanan_bahanAvgAggregateOutputType | null
    _sum: Detail_pemesanan_bahanSumAggregateOutputType | null
    _min: Detail_pemesanan_bahanMinAggregateOutputType | null
    _max: Detail_pemesanan_bahanMaxAggregateOutputType | null
  }

  export type Detail_pemesanan_bahanAvgAggregateOutputType = {
    id: number | null
    stok_bahan_id: number | null
    pemesanan_bahan_id: number | null
    jumlah: number | null
    harga: number | null
  }

  export type Detail_pemesanan_bahanSumAggregateOutputType = {
    id: number | null
    stok_bahan_id: number | null
    pemesanan_bahan_id: number | null
    jumlah: number | null
    harga: number | null
  }

  export type Detail_pemesanan_bahanMinAggregateOutputType = {
    id: number | null
    stok_bahan_id: number | null
    pemesanan_bahan_id: number | null
    jumlah: number | null
    harga: number | null
  }

  export type Detail_pemesanan_bahanMaxAggregateOutputType = {
    id: number | null
    stok_bahan_id: number | null
    pemesanan_bahan_id: number | null
    jumlah: number | null
    harga: number | null
  }

  export type Detail_pemesanan_bahanCountAggregateOutputType = {
    id: number
    stok_bahan_id: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
    _all: number
  }


  export type Detail_pemesanan_bahanAvgAggregateInputType = {
    id?: true
    stok_bahan_id?: true
    pemesanan_bahan_id?: true
    jumlah?: true
    harga?: true
  }

  export type Detail_pemesanan_bahanSumAggregateInputType = {
    id?: true
    stok_bahan_id?: true
    pemesanan_bahan_id?: true
    jumlah?: true
    harga?: true
  }

  export type Detail_pemesanan_bahanMinAggregateInputType = {
    id?: true
    stok_bahan_id?: true
    pemesanan_bahan_id?: true
    jumlah?: true
    harga?: true
  }

  export type Detail_pemesanan_bahanMaxAggregateInputType = {
    id?: true
    stok_bahan_id?: true
    pemesanan_bahan_id?: true
    jumlah?: true
    harga?: true
  }

  export type Detail_pemesanan_bahanCountAggregateInputType = {
    id?: true
    stok_bahan_id?: true
    pemesanan_bahan_id?: true
    jumlah?: true
    harga?: true
    _all?: true
  }

  export type Detail_pemesanan_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pemesanan_bahan to aggregate.
     */
    where?: detail_pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pemesanan_bahans to fetch.
     */
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_pemesanan_bahans
    **/
    _count?: true | Detail_pemesanan_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_pemesanan_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_pemesanan_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_pemesanan_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_pemesanan_bahanMaxAggregateInputType
  }

  export type GetDetail_pemesanan_bahanAggregateType<T extends Detail_pemesanan_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_pemesanan_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_pemesanan_bahan[P]>
      : GetScalarType<T[P], AggregateDetail_pemesanan_bahan[P]>
  }




  export type detail_pemesanan_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pemesanan_bahanWhereInput
    orderBy?: detail_pemesanan_bahanOrderByWithAggregationInput | detail_pemesanan_bahanOrderByWithAggregationInput[]
    by: Detail_pemesanan_bahanScalarFieldEnum[] | Detail_pemesanan_bahanScalarFieldEnum
    having?: detail_pemesanan_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_pemesanan_bahanCountAggregateInputType | true
    _avg?: Detail_pemesanan_bahanAvgAggregateInputType
    _sum?: Detail_pemesanan_bahanSumAggregateInputType
    _min?: Detail_pemesanan_bahanMinAggregateInputType
    _max?: Detail_pemesanan_bahanMaxAggregateInputType
  }

  export type Detail_pemesanan_bahanGroupByOutputType = {
    id: number
    stok_bahan_id: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
    _count: Detail_pemesanan_bahanCountAggregateOutputType | null
    _avg: Detail_pemesanan_bahanAvgAggregateOutputType | null
    _sum: Detail_pemesanan_bahanSumAggregateOutputType | null
    _min: Detail_pemesanan_bahanMinAggregateOutputType | null
    _max: Detail_pemesanan_bahanMaxAggregateOutputType | null
  }

  type GetDetail_pemesanan_bahanGroupByPayload<T extends detail_pemesanan_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_pemesanan_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_pemesanan_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_pemesanan_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_pemesanan_bahanGroupByOutputType[P]>
        }
      >
    >


  export type detail_pemesanan_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stok_bahan_id?: boolean
    pemesanan_bahan_id?: boolean
    jumlah?: boolean
    harga?: boolean
    pemesanan_bahan?: boolean | pemesanan_bahanDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_pemesanan_bahan"]>

  export type detail_pemesanan_bahanSelectScalar = {
    id?: boolean
    stok_bahan_id?: boolean
    pemesanan_bahan_id?: boolean
    jumlah?: boolean
    harga?: boolean
  }

  export type detail_pemesanan_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pemesanan_bahan?: boolean | pemesanan_bahanDefaultArgs<ExtArgs>
    stok_bahan?: boolean | stok_bahanDefaultArgs<ExtArgs>
  }


  export type $detail_pemesanan_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_pemesanan_bahan"
    objects: {
      pemesanan_bahan: Prisma.$pemesanan_bahanPayload<ExtArgs>
      stok_bahan: Prisma.$stok_bahanPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      stok_bahan_id: number
      pemesanan_bahan_id: number
      jumlah: number
      harga: number
    }, ExtArgs["result"]["detail_pemesanan_bahan"]>
    composites: {}
  }


  type detail_pemesanan_bahanGetPayload<S extends boolean | null | undefined | detail_pemesanan_bahanDefaultArgs> = $Result.GetResult<Prisma.$detail_pemesanan_bahanPayload, S>

  type detail_pemesanan_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_pemesanan_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Detail_pemesanan_bahanCountAggregateInputType | true
    }

  export interface detail_pemesanan_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_pemesanan_bahan'], meta: { name: 'detail_pemesanan_bahan' } }
    /**
     * Find zero or one Detail_pemesanan_bahan that matches the filter.
     * @param {detail_pemesanan_bahanFindUniqueArgs} args - Arguments to find a Detail_pemesanan_bahan
     * @example
     * // Get one Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_pemesanan_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_pemesanan_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_pemesanan_bahanFindUniqueOrThrowArgs} args - Arguments to find a Detail_pemesanan_bahan
     * @example
     * // Get one Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_pemesanan_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanFindFirstArgs} args - Arguments to find a Detail_pemesanan_bahan
     * @example
     * // Get one Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_pemesanan_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_pemesanan_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanFindFirstOrThrowArgs} args - Arguments to find a Detail_pemesanan_bahan
     * @example
     * // Get one Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_pemesanan_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_pemesanan_bahans
     * const detail_pemesanan_bahans = await prisma.detail_pemesanan_bahan.findMany()
     * 
     * // Get first 10 Detail_pemesanan_bahans
     * const detail_pemesanan_bahans = await prisma.detail_pemesanan_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_pemesanan_bahanWithIdOnly = await prisma.detail_pemesanan_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_pemesanan_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_pemesanan_bahan.
     * @param {detail_pemesanan_bahanCreateArgs} args - Arguments to create a Detail_pemesanan_bahan.
     * @example
     * // Create one Detail_pemesanan_bahan
     * const Detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.create({
     *   data: {
     *     // ... data to create a Detail_pemesanan_bahan
     *   }
     * })
     * 
    **/
    create<T extends detail_pemesanan_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanCreateArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_pemesanan_bahans.
     *     @param {detail_pemesanan_bahanCreateManyArgs} args - Arguments to create many Detail_pemesanan_bahans.
     *     @example
     *     // Create many Detail_pemesanan_bahans
     *     const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_pemesanan_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_pemesanan_bahan.
     * @param {detail_pemesanan_bahanDeleteArgs} args - Arguments to delete one Detail_pemesanan_bahan.
     * @example
     * // Delete one Detail_pemesanan_bahan
     * const Detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.delete({
     *   where: {
     *     // ... filter to delete one Detail_pemesanan_bahan
     *   }
     * })
     * 
    **/
    delete<T extends detail_pemesanan_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanDeleteArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_pemesanan_bahan.
     * @param {detail_pemesanan_bahanUpdateArgs} args - Arguments to update one Detail_pemesanan_bahan.
     * @example
     * // Update one Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_pemesanan_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanUpdateArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_pemesanan_bahans.
     * @param {detail_pemesanan_bahanDeleteManyArgs} args - Arguments to filter Detail_pemesanan_bahans to delete.
     * @example
     * // Delete a few Detail_pemesanan_bahans
     * const { count } = await prisma.detail_pemesanan_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_pemesanan_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pemesanan_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_pemesanan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_pemesanan_bahans
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_pemesanan_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_pemesanan_bahan.
     * @param {detail_pemesanan_bahanUpsertArgs} args - Arguments to update or create a Detail_pemesanan_bahan.
     * @example
     * // Update or create a Detail_pemesanan_bahan
     * const detail_pemesanan_bahan = await prisma.detail_pemesanan_bahan.upsert({
     *   create: {
     *     // ... data to create a Detail_pemesanan_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_pemesanan_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends detail_pemesanan_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pemesanan_bahanUpsertArgs<ExtArgs>>
    ): Prisma__detail_pemesanan_bahanClient<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_pemesanan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanCountArgs} args - Arguments to filter Detail_pemesanan_bahans to count.
     * @example
     * // Count the number of Detail_pemesanan_bahans
     * const count = await prisma.detail_pemesanan_bahan.count({
     *   where: {
     *     // ... the filter for the Detail_pemesanan_bahans we want to count
     *   }
     * })
    **/
    count<T extends detail_pemesanan_bahanCountArgs>(
      args?: Subset<T, detail_pemesanan_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_pemesanan_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_pemesanan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_pemesanan_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_pemesanan_bahanAggregateArgs>(args: Subset<T, Detail_pemesanan_bahanAggregateArgs>): Prisma.PrismaPromise<GetDetail_pemesanan_bahanAggregateType<T>>

    /**
     * Group by Detail_pemesanan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pemesanan_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_pemesanan_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_pemesanan_bahanGroupByArgs['orderBy'] }
        : { orderBy?: detail_pemesanan_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_pemesanan_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_pemesanan_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_pemesanan_bahan model
   */
  readonly fields: detail_pemesanan_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_pemesanan_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_pemesanan_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pemesanan_bahan<T extends pemesanan_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pemesanan_bahanDefaultArgs<ExtArgs>>): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stok_bahan<T extends stok_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stok_bahanDefaultArgs<ExtArgs>>): Prisma__stok_bahanClient<$Result.GetResult<Prisma.$stok_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_pemesanan_bahan model
   */ 
  interface detail_pemesanan_bahanFieldRefs {
    readonly id: FieldRef<"detail_pemesanan_bahan", 'Int'>
    readonly stok_bahan_id: FieldRef<"detail_pemesanan_bahan", 'Int'>
    readonly pemesanan_bahan_id: FieldRef<"detail_pemesanan_bahan", 'Int'>
    readonly jumlah: FieldRef<"detail_pemesanan_bahan", 'Float'>
    readonly harga: FieldRef<"detail_pemesanan_bahan", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * detail_pemesanan_bahan findUnique
   */
  export type detail_pemesanan_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pemesanan_bahan to fetch.
     */
    where: detail_pemesanan_bahanWhereUniqueInput
  }


  /**
   * detail_pemesanan_bahan findUniqueOrThrow
   */
  export type detail_pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pemesanan_bahan to fetch.
     */
    where: detail_pemesanan_bahanWhereUniqueInput
  }


  /**
   * detail_pemesanan_bahan findFirst
   */
  export type detail_pemesanan_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pemesanan_bahan to fetch.
     */
    where?: detail_pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pemesanan_bahans to fetch.
     */
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pemesanan_bahans.
     */
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pemesanan_bahans.
     */
    distinct?: Detail_pemesanan_bahanScalarFieldEnum | Detail_pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pemesanan_bahan findFirstOrThrow
   */
  export type detail_pemesanan_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pemesanan_bahan to fetch.
     */
    where?: detail_pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pemesanan_bahans to fetch.
     */
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pemesanan_bahans.
     */
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pemesanan_bahans.
     */
    distinct?: Detail_pemesanan_bahanScalarFieldEnum | Detail_pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pemesanan_bahan findMany
   */
  export type detail_pemesanan_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which detail_pemesanan_bahans to fetch.
     */
    where?: detail_pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pemesanan_bahans to fetch.
     */
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_pemesanan_bahans.
     */
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pemesanan_bahans.
     */
    skip?: number
    distinct?: Detail_pemesanan_bahanScalarFieldEnum | Detail_pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * detail_pemesanan_bahan create
   */
  export type detail_pemesanan_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_pemesanan_bahan.
     */
    data: XOR<detail_pemesanan_bahanCreateInput, detail_pemesanan_bahanUncheckedCreateInput>
  }


  /**
   * detail_pemesanan_bahan createMany
   */
  export type detail_pemesanan_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_pemesanan_bahans.
     */
    data: detail_pemesanan_bahanCreateManyInput | detail_pemesanan_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_pemesanan_bahan update
   */
  export type detail_pemesanan_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_pemesanan_bahan.
     */
    data: XOR<detail_pemesanan_bahanUpdateInput, detail_pemesanan_bahanUncheckedUpdateInput>
    /**
     * Choose, which detail_pemesanan_bahan to update.
     */
    where: detail_pemesanan_bahanWhereUniqueInput
  }


  /**
   * detail_pemesanan_bahan updateMany
   */
  export type detail_pemesanan_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_pemesanan_bahans.
     */
    data: XOR<detail_pemesanan_bahanUpdateManyMutationInput, detail_pemesanan_bahanUncheckedUpdateManyInput>
    /**
     * Filter which detail_pemesanan_bahans to update
     */
    where?: detail_pemesanan_bahanWhereInput
  }


  /**
   * detail_pemesanan_bahan upsert
   */
  export type detail_pemesanan_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_pemesanan_bahan to update in case it exists.
     */
    where: detail_pemesanan_bahanWhereUniqueInput
    /**
     * In case the detail_pemesanan_bahan found by the `where` argument doesn't exist, create a new detail_pemesanan_bahan with this data.
     */
    create: XOR<detail_pemesanan_bahanCreateInput, detail_pemesanan_bahanUncheckedCreateInput>
    /**
     * In case the detail_pemesanan_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_pemesanan_bahanUpdateInput, detail_pemesanan_bahanUncheckedUpdateInput>
  }


  /**
   * detail_pemesanan_bahan delete
   */
  export type detail_pemesanan_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter which detail_pemesanan_bahan to delete.
     */
    where: detail_pemesanan_bahanWhereUniqueInput
  }


  /**
   * detail_pemesanan_bahan deleteMany
   */
  export type detail_pemesanan_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pemesanan_bahans to delete
     */
    where?: detail_pemesanan_bahanWhereInput
  }


  /**
   * detail_pemesanan_bahan without action
   */
  export type detail_pemesanan_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
  }



  /**
   * Model pemesanan_bahan
   */

  export type AggregatePemesanan_bahan = {
    _count: Pemesanan_bahanCountAggregateOutputType | null
    _avg: Pemesanan_bahanAvgAggregateOutputType | null
    _sum: Pemesanan_bahanSumAggregateOutputType | null
    _min: Pemesanan_bahanMinAggregateOutputType | null
    _max: Pemesanan_bahanMaxAggregateOutputType | null
  }

  export type Pemesanan_bahanAvgAggregateOutputType = {
    id: number | null
    supplier_id: number | null
  }

  export type Pemesanan_bahanSumAggregateOutputType = {
    id: number | null
    supplier_id: number | null
  }

  export type Pemesanan_bahanMinAggregateOutputType = {
    id: number | null
    tanggal_pesan: Date | null
    tanggal_terima: Date | null
    pic_pemesan: string | null
    kontak_pic_pemesan: string | null
    supplier_id: number | null
  }

  export type Pemesanan_bahanMaxAggregateOutputType = {
    id: number | null
    tanggal_pesan: Date | null
    tanggal_terima: Date | null
    pic_pemesan: string | null
    kontak_pic_pemesan: string | null
    supplier_id: number | null
  }

  export type Pemesanan_bahanCountAggregateOutputType = {
    id: number
    tanggal_pesan: number
    tanggal_terima: number
    pic_pemesan: number
    kontak_pic_pemesan: number
    supplier_id: number
    _all: number
  }


  export type Pemesanan_bahanAvgAggregateInputType = {
    id?: true
    supplier_id?: true
  }

  export type Pemesanan_bahanSumAggregateInputType = {
    id?: true
    supplier_id?: true
  }

  export type Pemesanan_bahanMinAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    pic_pemesan?: true
    kontak_pic_pemesan?: true
    supplier_id?: true
  }

  export type Pemesanan_bahanMaxAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    pic_pemesan?: true
    kontak_pic_pemesan?: true
    supplier_id?: true
  }

  export type Pemesanan_bahanCountAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    pic_pemesan?: true
    kontak_pic_pemesan?: true
    supplier_id?: true
    _all?: true
  }

  export type Pemesanan_bahanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pemesanan_bahan to aggregate.
     */
    where?: pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemesanan_bahans to fetch.
     */
    orderBy?: pemesanan_bahanOrderByWithRelationInput | pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pemesanan_bahans
    **/
    _count?: true | Pemesanan_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pemesanan_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pemesanan_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pemesanan_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pemesanan_bahanMaxAggregateInputType
  }

  export type GetPemesanan_bahanAggregateType<T extends Pemesanan_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregatePemesanan_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePemesanan_bahan[P]>
      : GetScalarType<T[P], AggregatePemesanan_bahan[P]>
  }




  export type pemesanan_bahanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pemesanan_bahanWhereInput
    orderBy?: pemesanan_bahanOrderByWithAggregationInput | pemesanan_bahanOrderByWithAggregationInput[]
    by: Pemesanan_bahanScalarFieldEnum[] | Pemesanan_bahanScalarFieldEnum
    having?: pemesanan_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pemesanan_bahanCountAggregateInputType | true
    _avg?: Pemesanan_bahanAvgAggregateInputType
    _sum?: Pemesanan_bahanSumAggregateInputType
    _min?: Pemesanan_bahanMinAggregateInputType
    _max?: Pemesanan_bahanMaxAggregateInputType
  }

  export type Pemesanan_bahanGroupByOutputType = {
    id: number
    tanggal_pesan: Date
    tanggal_terima: Date
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier_id: number
    _count: Pemesanan_bahanCountAggregateOutputType | null
    _avg: Pemesanan_bahanAvgAggregateOutputType | null
    _sum: Pemesanan_bahanSumAggregateOutputType | null
    _min: Pemesanan_bahanMinAggregateOutputType | null
    _max: Pemesanan_bahanMaxAggregateOutputType | null
  }

  type GetPemesanan_bahanGroupByPayload<T extends pemesanan_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pemesanan_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pemesanan_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pemesanan_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Pemesanan_bahanGroupByOutputType[P]>
        }
      >
    >


  export type pemesanan_bahanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal_pesan?: boolean
    tanggal_terima?: boolean
    pic_pemesan?: boolean
    kontak_pic_pemesan?: boolean
    supplier_id?: boolean
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
    detail_pemesanan_bahan?: boolean | pemesanan_bahan$detail_pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | Pemesanan_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pemesanan_bahan"]>

  export type pemesanan_bahanSelectScalar = {
    id?: boolean
    tanggal_pesan?: boolean
    tanggal_terima?: boolean
    pic_pemesan?: boolean
    kontak_pic_pemesan?: boolean
    supplier_id?: boolean
  }

  export type pemesanan_bahanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
    detail_pemesanan_bahan?: boolean | pemesanan_bahan$detail_pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | Pemesanan_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pemesanan_bahanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "pemesanan_bahan"
    objects: {
      supplier: Prisma.$supplierPayload<ExtArgs>
      detail_pemesanan_bahan: Prisma.$detail_pemesanan_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      tanggal_pesan: Date
      tanggal_terima: Date
      pic_pemesan: string
      kontak_pic_pemesan: string
      supplier_id: number
    }, ExtArgs["result"]["pemesanan_bahan"]>
    composites: {}
  }


  type pemesanan_bahanGetPayload<S extends boolean | null | undefined | pemesanan_bahanDefaultArgs> = $Result.GetResult<Prisma.$pemesanan_bahanPayload, S>

  type pemesanan_bahanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<pemesanan_bahanFindManyArgs, 'select' | 'include'> & {
      select?: Pemesanan_bahanCountAggregateInputType | true
    }

  export interface pemesanan_bahanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pemesanan_bahan'], meta: { name: 'pemesanan_bahan' } }
    /**
     * Find zero or one Pemesanan_bahan that matches the filter.
     * @param {pemesanan_bahanFindUniqueArgs} args - Arguments to find a Pemesanan_bahan
     * @example
     * // Get one Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pemesanan_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pemesanan_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pemesanan_bahanFindUniqueOrThrowArgs} args - Arguments to find a Pemesanan_bahan
     * @example
     * // Get one Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pemesanan_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanFindFirstArgs} args - Arguments to find a Pemesanan_bahan
     * @example
     * // Get one Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pemesanan_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pemesanan_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanFindFirstOrThrowArgs} args - Arguments to find a Pemesanan_bahan
     * @example
     * // Get one Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pemesanan_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pemesanan_bahans
     * const pemesanan_bahans = await prisma.pemesanan_bahan.findMany()
     * 
     * // Get first 10 Pemesanan_bahans
     * const pemesanan_bahans = await prisma.pemesanan_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pemesanan_bahanWithIdOnly = await prisma.pemesanan_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pemesanan_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pemesanan_bahan.
     * @param {pemesanan_bahanCreateArgs} args - Arguments to create a Pemesanan_bahan.
     * @example
     * // Create one Pemesanan_bahan
     * const Pemesanan_bahan = await prisma.pemesanan_bahan.create({
     *   data: {
     *     // ... data to create a Pemesanan_bahan
     *   }
     * })
     * 
    **/
    create<T extends pemesanan_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanCreateArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pemesanan_bahans.
     *     @param {pemesanan_bahanCreateManyArgs} args - Arguments to create many Pemesanan_bahans.
     *     @example
     *     // Create many Pemesanan_bahans
     *     const pemesanan_bahan = await prisma.pemesanan_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pemesanan_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pemesanan_bahan.
     * @param {pemesanan_bahanDeleteArgs} args - Arguments to delete one Pemesanan_bahan.
     * @example
     * // Delete one Pemesanan_bahan
     * const Pemesanan_bahan = await prisma.pemesanan_bahan.delete({
     *   where: {
     *     // ... filter to delete one Pemesanan_bahan
     *   }
     * })
     * 
    **/
    delete<T extends pemesanan_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanDeleteArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pemesanan_bahan.
     * @param {pemesanan_bahanUpdateArgs} args - Arguments to update one Pemesanan_bahan.
     * @example
     * // Update one Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pemesanan_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanUpdateArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pemesanan_bahans.
     * @param {pemesanan_bahanDeleteManyArgs} args - Arguments to filter Pemesanan_bahans to delete.
     * @example
     * // Delete a few Pemesanan_bahans
     * const { count } = await prisma.pemesanan_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pemesanan_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pemesanan_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pemesanan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pemesanan_bahans
     * const pemesanan_bahan = await prisma.pemesanan_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pemesanan_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pemesanan_bahan.
     * @param {pemesanan_bahanUpsertArgs} args - Arguments to update or create a Pemesanan_bahan.
     * @example
     * // Update or create a Pemesanan_bahan
     * const pemesanan_bahan = await prisma.pemesanan_bahan.upsert({
     *   create: {
     *     // ... data to create a Pemesanan_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pemesanan_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends pemesanan_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pemesanan_bahanUpsertArgs<ExtArgs>>
    ): Prisma__pemesanan_bahanClient<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pemesanan_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanCountArgs} args - Arguments to filter Pemesanan_bahans to count.
     * @example
     * // Count the number of Pemesanan_bahans
     * const count = await prisma.pemesanan_bahan.count({
     *   where: {
     *     // ... the filter for the Pemesanan_bahans we want to count
     *   }
     * })
    **/
    count<T extends pemesanan_bahanCountArgs>(
      args?: Subset<T, pemesanan_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pemesanan_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pemesanan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pemesanan_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pemesanan_bahanAggregateArgs>(args: Subset<T, Pemesanan_bahanAggregateArgs>): Prisma.PrismaPromise<GetPemesanan_bahanAggregateType<T>>

    /**
     * Group by Pemesanan_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemesanan_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pemesanan_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pemesanan_bahanGroupByArgs['orderBy'] }
        : { orderBy?: pemesanan_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pemesanan_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPemesanan_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pemesanan_bahan model
   */
  readonly fields: pemesanan_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pemesanan_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pemesanan_bahanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detail_pemesanan_bahan<T extends pemesanan_bahan$detail_pemesanan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, pemesanan_bahan$detail_pemesanan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pemesanan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pemesanan_bahan model
   */ 
  interface pemesanan_bahanFieldRefs {
    readonly id: FieldRef<"pemesanan_bahan", 'Int'>
    readonly tanggal_pesan: FieldRef<"pemesanan_bahan", 'DateTime'>
    readonly tanggal_terima: FieldRef<"pemesanan_bahan", 'DateTime'>
    readonly pic_pemesan: FieldRef<"pemesanan_bahan", 'String'>
    readonly kontak_pic_pemesan: FieldRef<"pemesanan_bahan", 'String'>
    readonly supplier_id: FieldRef<"pemesanan_bahan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * pemesanan_bahan findUnique
   */
  export type pemesanan_bahanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pemesanan_bahan to fetch.
     */
    where: pemesanan_bahanWhereUniqueInput
  }


  /**
   * pemesanan_bahan findUniqueOrThrow
   */
  export type pemesanan_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pemesanan_bahan to fetch.
     */
    where: pemesanan_bahanWhereUniqueInput
  }


  /**
   * pemesanan_bahan findFirst
   */
  export type pemesanan_bahanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pemesanan_bahan to fetch.
     */
    where?: pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemesanan_bahans to fetch.
     */
    orderBy?: pemesanan_bahanOrderByWithRelationInput | pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pemesanan_bahans.
     */
    cursor?: pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pemesanan_bahans.
     */
    distinct?: Pemesanan_bahanScalarFieldEnum | Pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * pemesanan_bahan findFirstOrThrow
   */
  export type pemesanan_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pemesanan_bahan to fetch.
     */
    where?: pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemesanan_bahans to fetch.
     */
    orderBy?: pemesanan_bahanOrderByWithRelationInput | pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pemesanan_bahans.
     */
    cursor?: pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemesanan_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pemesanan_bahans.
     */
    distinct?: Pemesanan_bahanScalarFieldEnum | Pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * pemesanan_bahan findMany
   */
  export type pemesanan_bahanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter, which pemesanan_bahans to fetch.
     */
    where?: pemesanan_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemesanan_bahans to fetch.
     */
    orderBy?: pemesanan_bahanOrderByWithRelationInput | pemesanan_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pemesanan_bahans.
     */
    cursor?: pemesanan_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemesanan_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemesanan_bahans.
     */
    skip?: number
    distinct?: Pemesanan_bahanScalarFieldEnum | Pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * pemesanan_bahan create
   */
  export type pemesanan_bahanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a pemesanan_bahan.
     */
    data: XOR<pemesanan_bahanCreateInput, pemesanan_bahanUncheckedCreateInput>
  }


  /**
   * pemesanan_bahan createMany
   */
  export type pemesanan_bahanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pemesanan_bahans.
     */
    data: pemesanan_bahanCreateManyInput | pemesanan_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pemesanan_bahan update
   */
  export type pemesanan_bahanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a pemesanan_bahan.
     */
    data: XOR<pemesanan_bahanUpdateInput, pemesanan_bahanUncheckedUpdateInput>
    /**
     * Choose, which pemesanan_bahan to update.
     */
    where: pemesanan_bahanWhereUniqueInput
  }


  /**
   * pemesanan_bahan updateMany
   */
  export type pemesanan_bahanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pemesanan_bahans.
     */
    data: XOR<pemesanan_bahanUpdateManyMutationInput, pemesanan_bahanUncheckedUpdateManyInput>
    /**
     * Filter which pemesanan_bahans to update
     */
    where?: pemesanan_bahanWhereInput
  }


  /**
   * pemesanan_bahan upsert
   */
  export type pemesanan_bahanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the pemesanan_bahan to update in case it exists.
     */
    where: pemesanan_bahanWhereUniqueInput
    /**
     * In case the pemesanan_bahan found by the `where` argument doesn't exist, create a new pemesanan_bahan with this data.
     */
    create: XOR<pemesanan_bahanCreateInput, pemesanan_bahanUncheckedCreateInput>
    /**
     * In case the pemesanan_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pemesanan_bahanUpdateInput, pemesanan_bahanUncheckedUpdateInput>
  }


  /**
   * pemesanan_bahan delete
   */
  export type pemesanan_bahanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    /**
     * Filter which pemesanan_bahan to delete.
     */
    where: pemesanan_bahanWhereUniqueInput
  }


  /**
   * pemesanan_bahan deleteMany
   */
  export type pemesanan_bahanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pemesanan_bahans to delete
     */
    where?: pemesanan_bahanWhereInput
  }


  /**
   * pemesanan_bahan.detail_pemesanan_bahan
   */
  export type pemesanan_bahan$detail_pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pemesanan_bahan
     */
    select?: detail_pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pemesanan_bahanInclude<ExtArgs> | null
    where?: detail_pemesanan_bahanWhereInput
    orderBy?: detail_pemesanan_bahanOrderByWithRelationInput | detail_pemesanan_bahanOrderByWithRelationInput[]
    cursor?: detail_pemesanan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pemesanan_bahanScalarFieldEnum | Detail_pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * pemesanan_bahan without action
   */
  export type pemesanan_bahanDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
  }



  /**
   * Model supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    nama_supplier: string | null
    alamat: string | null
    kontak: string | null
    nama_pic: string | null
    kontak_pic: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    nama_supplier: string | null
    alamat: string | null
    kontak: string | null
    nama_pic: string | null
    kontak_pic: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    nama_supplier: number
    alamat: number
    kontak: number
    nama_pic: number
    kontak_pic: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    nama_supplier?: true
    alamat?: true
    kontak?: true
    nama_pic?: true
    kontak_pic?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    nama_supplier?: true
    alamat?: true
    kontak?: true
    nama_pic?: true
    kontak_pic?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    nama_supplier?: true
    alamat?: true
    kontak?: true
    nama_pic?: true
    kontak_pic?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier to aggregate.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type supplierGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: supplierWhereInput
    orderBy?: supplierOrderByWithAggregationInput | supplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends supplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_supplier?: boolean
    alamat?: boolean
    kontak?: boolean
    nama_pic?: boolean
    kontak_pic?: boolean
    pemesanan_bahan?: boolean | supplier$pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type supplierSelectScalar = {
    id?: boolean
    nama_supplier?: boolean
    alamat?: boolean
    kontak?: boolean
    nama_pic?: boolean
    kontak_pic?: boolean
  }

  export type supplierInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pemesanan_bahan?: boolean | supplier$pemesanan_bahanArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $supplierPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "supplier"
    objects: {
      pemesanan_bahan: Prisma.$pemesanan_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_supplier: string
      alamat: string
      kontak: string
      nama_pic: string
      kontak_pic: string
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type supplierGetPayload<S extends boolean | null | undefined | supplierDefaultArgs> = $Result.GetResult<Prisma.$supplierPayload, S>

  type supplierCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<supplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface supplierDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier'], meta: { name: 'supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, supplierFindUniqueArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {supplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends supplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends supplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends supplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends supplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierCreateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends supplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends supplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, supplierDeleteArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends supplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpsertArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierGroupByArgs['orderBy'] }
        : { orderBy?: supplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier model
   */
  readonly fields: supplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pemesanan_bahan<T extends supplier$pemesanan_bahanArgs<ExtArgs> = {}>(args?: Subset<T, supplier$pemesanan_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pemesanan_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the supplier model
   */ 
  interface supplierFieldRefs {
    readonly id: FieldRef<"supplier", 'Int'>
    readonly nama_supplier: FieldRef<"supplier", 'String'>
    readonly alamat: FieldRef<"supplier", 'String'>
    readonly kontak: FieldRef<"supplier", 'String'>
    readonly nama_pic: FieldRef<"supplier", 'String'>
    readonly kontak_pic: FieldRef<"supplier", 'String'>
  }
    

  // Custom InputTypes

  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findUniqueOrThrow
   */
  export type supplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier findFirstOrThrow
   */
  export type supplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier findMany
   */
  export type supplierFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which suppliers to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier create
   */
  export type supplierCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to create a supplier.
     */
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }


  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * supplier update
   */
  export type supplierUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to update a supplier.
     */
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
  }


  /**
   * supplier upsert
   */
  export type supplierUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The filter to search for the supplier to update in case it exists.
     */
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     */
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }


  /**
   * supplier delete
   */
  export type supplierDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter which supplier to delete.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which suppliers to delete
     */
    where?: supplierWhereInput
  }


  /**
   * supplier.pemesanan_bahan
   */
  export type supplier$pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemesanan_bahan
     */
    select?: pemesanan_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pemesanan_bahanInclude<ExtArgs> | null
    where?: pemesanan_bahanWhereInput
    orderBy?: pemesanan_bahanOrderByWithRelationInput | pemesanan_bahanOrderByWithRelationInput[]
    cursor?: pemesanan_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pemesanan_bahanScalarFieldEnum | Pemesanan_bahanScalarFieldEnum[]
  }


  /**
   * supplier without action
   */
  export type supplierDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
  }



  /**
   * Model detail_gawangan
   */

  export type AggregateDetail_gawangan = {
    _count: Detail_gawanganCountAggregateOutputType | null
    _avg: Detail_gawanganAvgAggregateOutputType | null
    _sum: Detail_gawanganSumAggregateOutputType | null
    _min: Detail_gawanganMinAggregateOutputType | null
    _max: Detail_gawanganMaxAggregateOutputType | null
  }

  export type Detail_gawanganAvgAggregateOutputType = {
    id: number | null
    gawangan_id: number | null
    produk_item_id: number | null
    jumlah: number | null
  }

  export type Detail_gawanganSumAggregateOutputType = {
    id: number | null
    gawangan_id: number | null
    produk_item_id: number | null
    jumlah: number | null
  }

  export type Detail_gawanganMinAggregateOutputType = {
    id: number | null
    gawangan_id: number | null
    produk_item_id: number | null
    jumlah: number | null
  }

  export type Detail_gawanganMaxAggregateOutputType = {
    id: number | null
    gawangan_id: number | null
    produk_item_id: number | null
    jumlah: number | null
  }

  export type Detail_gawanganCountAggregateOutputType = {
    id: number
    gawangan_id: number
    produk_item_id: number
    jumlah: number
    _all: number
  }


  export type Detail_gawanganAvgAggregateInputType = {
    id?: true
    gawangan_id?: true
    produk_item_id?: true
    jumlah?: true
  }

  export type Detail_gawanganSumAggregateInputType = {
    id?: true
    gawangan_id?: true
    produk_item_id?: true
    jumlah?: true
  }

  export type Detail_gawanganMinAggregateInputType = {
    id?: true
    gawangan_id?: true
    produk_item_id?: true
    jumlah?: true
  }

  export type Detail_gawanganMaxAggregateInputType = {
    id?: true
    gawangan_id?: true
    produk_item_id?: true
    jumlah?: true
  }

  export type Detail_gawanganCountAggregateInputType = {
    id?: true
    gawangan_id?: true
    produk_item_id?: true
    jumlah?: true
    _all?: true
  }

  export type Detail_gawanganAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_gawangan to aggregate.
     */
    where?: detail_gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_gawangans to fetch.
     */
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_gawangans
    **/
    _count?: true | Detail_gawanganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_gawanganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_gawanganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_gawanganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_gawanganMaxAggregateInputType
  }

  export type GetDetail_gawanganAggregateType<T extends Detail_gawanganAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_gawangan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_gawangan[P]>
      : GetScalarType<T[P], AggregateDetail_gawangan[P]>
  }




  export type detail_gawanganGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_gawanganWhereInput
    orderBy?: detail_gawanganOrderByWithAggregationInput | detail_gawanganOrderByWithAggregationInput[]
    by: Detail_gawanganScalarFieldEnum[] | Detail_gawanganScalarFieldEnum
    having?: detail_gawanganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_gawanganCountAggregateInputType | true
    _avg?: Detail_gawanganAvgAggregateInputType
    _sum?: Detail_gawanganSumAggregateInputType
    _min?: Detail_gawanganMinAggregateInputType
    _max?: Detail_gawanganMaxAggregateInputType
  }

  export type Detail_gawanganGroupByOutputType = {
    id: number
    gawangan_id: number
    produk_item_id: number
    jumlah: number
    _count: Detail_gawanganCountAggregateOutputType | null
    _avg: Detail_gawanganAvgAggregateOutputType | null
    _sum: Detail_gawanganSumAggregateOutputType | null
    _min: Detail_gawanganMinAggregateOutputType | null
    _max: Detail_gawanganMaxAggregateOutputType | null
  }

  type GetDetail_gawanganGroupByPayload<T extends detail_gawanganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_gawanganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_gawanganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_gawanganGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_gawanganGroupByOutputType[P]>
        }
      >
    >


  export type detail_gawanganSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gawangan_id?: boolean
    produk_item_id?: boolean
    jumlah?: boolean
    gawangan?: boolean | gawanganDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_gawangan"]>

  export type detail_gawanganSelectScalar = {
    id?: boolean
    gawangan_id?: boolean
    produk_item_id?: boolean
    jumlah?: boolean
  }

  export type detail_gawanganInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gawangan?: boolean | gawanganDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
  }


  export type $detail_gawanganPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_gawangan"
    objects: {
      gawangan: Prisma.$gawanganPayload<ExtArgs>
      produk_item: Prisma.$produk_itemPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      gawangan_id: number
      produk_item_id: number
      jumlah: number
    }, ExtArgs["result"]["detail_gawangan"]>
    composites: {}
  }


  type detail_gawanganGetPayload<S extends boolean | null | undefined | detail_gawanganDefaultArgs> = $Result.GetResult<Prisma.$detail_gawanganPayload, S>

  type detail_gawanganCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_gawanganFindManyArgs, 'select' | 'include'> & {
      select?: Detail_gawanganCountAggregateInputType | true
    }

  export interface detail_gawanganDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_gawangan'], meta: { name: 'detail_gawangan' } }
    /**
     * Find zero or one Detail_gawangan that matches the filter.
     * @param {detail_gawanganFindUniqueArgs} args - Arguments to find a Detail_gawangan
     * @example
     * // Get one Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_gawanganFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_gawangan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_gawanganFindUniqueOrThrowArgs} args - Arguments to find a Detail_gawangan
     * @example
     * // Get one Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_gawanganFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_gawangan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganFindFirstArgs} args - Arguments to find a Detail_gawangan
     * @example
     * // Get one Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_gawanganFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganFindFirstArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_gawangan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganFindFirstOrThrowArgs} args - Arguments to find a Detail_gawangan
     * @example
     * // Get one Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_gawanganFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_gawangans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_gawangans
     * const detail_gawangans = await prisma.detail_gawangan.findMany()
     * 
     * // Get first 10 Detail_gawangans
     * const detail_gawangans = await prisma.detail_gawangan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_gawanganWithIdOnly = await prisma.detail_gawangan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_gawanganFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_gawangan.
     * @param {detail_gawanganCreateArgs} args - Arguments to create a Detail_gawangan.
     * @example
     * // Create one Detail_gawangan
     * const Detail_gawangan = await prisma.detail_gawangan.create({
     *   data: {
     *     // ... data to create a Detail_gawangan
     *   }
     * })
     * 
    **/
    create<T extends detail_gawanganCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganCreateArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_gawangans.
     *     @param {detail_gawanganCreateManyArgs} args - Arguments to create many Detail_gawangans.
     *     @example
     *     // Create many Detail_gawangans
     *     const detail_gawangan = await prisma.detail_gawangan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_gawanganCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_gawangan.
     * @param {detail_gawanganDeleteArgs} args - Arguments to delete one Detail_gawangan.
     * @example
     * // Delete one Detail_gawangan
     * const Detail_gawangan = await prisma.detail_gawangan.delete({
     *   where: {
     *     // ... filter to delete one Detail_gawangan
     *   }
     * })
     * 
    **/
    delete<T extends detail_gawanganDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganDeleteArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_gawangan.
     * @param {detail_gawanganUpdateArgs} args - Arguments to update one Detail_gawangan.
     * @example
     * // Update one Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_gawanganUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganUpdateArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_gawangans.
     * @param {detail_gawanganDeleteManyArgs} args - Arguments to filter Detail_gawangans to delete.
     * @example
     * // Delete a few Detail_gawangans
     * const { count } = await prisma.detail_gawangan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_gawanganDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_gawanganDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_gawangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_gawangans
     * const detail_gawangan = await prisma.detail_gawangan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_gawanganUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_gawangan.
     * @param {detail_gawanganUpsertArgs} args - Arguments to update or create a Detail_gawangan.
     * @example
     * // Update or create a Detail_gawangan
     * const detail_gawangan = await prisma.detail_gawangan.upsert({
     *   create: {
     *     // ... data to create a Detail_gawangan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_gawangan we want to update
     *   }
     * })
    **/
    upsert<T extends detail_gawanganUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_gawanganUpsertArgs<ExtArgs>>
    ): Prisma__detail_gawanganClient<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_gawangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganCountArgs} args - Arguments to filter Detail_gawangans to count.
     * @example
     * // Count the number of Detail_gawangans
     * const count = await prisma.detail_gawangan.count({
     *   where: {
     *     // ... the filter for the Detail_gawangans we want to count
     *   }
     * })
    **/
    count<T extends detail_gawanganCountArgs>(
      args?: Subset<T, detail_gawanganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_gawanganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_gawangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_gawanganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_gawanganAggregateArgs>(args: Subset<T, Detail_gawanganAggregateArgs>): Prisma.PrismaPromise<GetDetail_gawanganAggregateType<T>>

    /**
     * Group by Detail_gawangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_gawanganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_gawanganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_gawanganGroupByArgs['orderBy'] }
        : { orderBy?: detail_gawanganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_gawanganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_gawanganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_gawangan model
   */
  readonly fields: detail_gawanganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_gawangan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_gawanganClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    gawangan<T extends gawanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gawanganDefaultArgs<ExtArgs>>): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produk_item<T extends produk_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produk_itemDefaultArgs<ExtArgs>>): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_gawangan model
   */ 
  interface detail_gawanganFieldRefs {
    readonly id: FieldRef<"detail_gawangan", 'Int'>
    readonly gawangan_id: FieldRef<"detail_gawangan", 'Int'>
    readonly produk_item_id: FieldRef<"detail_gawangan", 'Int'>
    readonly jumlah: FieldRef<"detail_gawangan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * detail_gawangan findUnique
   */
  export type detail_gawanganFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter, which detail_gawangan to fetch.
     */
    where: detail_gawanganWhereUniqueInput
  }


  /**
   * detail_gawangan findUniqueOrThrow
   */
  export type detail_gawanganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter, which detail_gawangan to fetch.
     */
    where: detail_gawanganWhereUniqueInput
  }


  /**
   * detail_gawangan findFirst
   */
  export type detail_gawanganFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter, which detail_gawangan to fetch.
     */
    where?: detail_gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_gawangans to fetch.
     */
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_gawangans.
     */
    cursor?: detail_gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_gawangans.
     */
    distinct?: Detail_gawanganScalarFieldEnum | Detail_gawanganScalarFieldEnum[]
  }


  /**
   * detail_gawangan findFirstOrThrow
   */
  export type detail_gawanganFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter, which detail_gawangan to fetch.
     */
    where?: detail_gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_gawangans to fetch.
     */
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_gawangans.
     */
    cursor?: detail_gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_gawangans.
     */
    distinct?: Detail_gawanganScalarFieldEnum | Detail_gawanganScalarFieldEnum[]
  }


  /**
   * detail_gawangan findMany
   */
  export type detail_gawanganFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter, which detail_gawangans to fetch.
     */
    where?: detail_gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_gawangans to fetch.
     */
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_gawangans.
     */
    cursor?: detail_gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_gawangans.
     */
    skip?: number
    distinct?: Detail_gawanganScalarFieldEnum | Detail_gawanganScalarFieldEnum[]
  }


  /**
   * detail_gawangan create
   */
  export type detail_gawanganCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_gawangan.
     */
    data: XOR<detail_gawanganCreateInput, detail_gawanganUncheckedCreateInput>
  }


  /**
   * detail_gawangan createMany
   */
  export type detail_gawanganCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_gawangans.
     */
    data: detail_gawanganCreateManyInput | detail_gawanganCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_gawangan update
   */
  export type detail_gawanganUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_gawangan.
     */
    data: XOR<detail_gawanganUpdateInput, detail_gawanganUncheckedUpdateInput>
    /**
     * Choose, which detail_gawangan to update.
     */
    where: detail_gawanganWhereUniqueInput
  }


  /**
   * detail_gawangan updateMany
   */
  export type detail_gawanganUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_gawangans.
     */
    data: XOR<detail_gawanganUpdateManyMutationInput, detail_gawanganUncheckedUpdateManyInput>
    /**
     * Filter which detail_gawangans to update
     */
    where?: detail_gawanganWhereInput
  }


  /**
   * detail_gawangan upsert
   */
  export type detail_gawanganUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_gawangan to update in case it exists.
     */
    where: detail_gawanganWhereUniqueInput
    /**
     * In case the detail_gawangan found by the `where` argument doesn't exist, create a new detail_gawangan with this data.
     */
    create: XOR<detail_gawanganCreateInput, detail_gawanganUncheckedCreateInput>
    /**
     * In case the detail_gawangan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_gawanganUpdateInput, detail_gawanganUncheckedUpdateInput>
  }


  /**
   * detail_gawangan delete
   */
  export type detail_gawanganDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    /**
     * Filter which detail_gawangan to delete.
     */
    where: detail_gawanganWhereUniqueInput
  }


  /**
   * detail_gawangan deleteMany
   */
  export type detail_gawanganDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_gawangans to delete
     */
    where?: detail_gawanganWhereInput
  }


  /**
   * detail_gawangan without action
   */
  export type detail_gawanganDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
  }



  /**
   * Model gawangan
   */

  export type AggregateGawangan = {
    _count: GawanganCountAggregateOutputType | null
    _avg: GawanganAvgAggregateOutputType | null
    _sum: GawanganSumAggregateOutputType | null
    _min: GawanganMinAggregateOutputType | null
    _max: GawanganMaxAggregateOutputType | null
  }

  export type GawanganAvgAggregateOutputType = {
    id: number | null
    outlet_id: number | null
  }

  export type GawanganSumAggregateOutputType = {
    id: number | null
    outlet_id: number | null
  }

  export type GawanganMinAggregateOutputType = {
    id: number | null
    nama_gawangan: string | null
    outlet_id: number | null
  }

  export type GawanganMaxAggregateOutputType = {
    id: number | null
    nama_gawangan: string | null
    outlet_id: number | null
  }

  export type GawanganCountAggregateOutputType = {
    id: number
    nama_gawangan: number
    outlet_id: number
    _all: number
  }


  export type GawanganAvgAggregateInputType = {
    id?: true
    outlet_id?: true
  }

  export type GawanganSumAggregateInputType = {
    id?: true
    outlet_id?: true
  }

  export type GawanganMinAggregateInputType = {
    id?: true
    nama_gawangan?: true
    outlet_id?: true
  }

  export type GawanganMaxAggregateInputType = {
    id?: true
    nama_gawangan?: true
    outlet_id?: true
  }

  export type GawanganCountAggregateInputType = {
    id?: true
    nama_gawangan?: true
    outlet_id?: true
    _all?: true
  }

  export type GawanganAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gawangan to aggregate.
     */
    where?: gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gawangans to fetch.
     */
    orderBy?: gawanganOrderByWithRelationInput | gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gawangans
    **/
    _count?: true | GawanganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GawanganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GawanganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GawanganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GawanganMaxAggregateInputType
  }

  export type GetGawanganAggregateType<T extends GawanganAggregateArgs> = {
        [P in keyof T & keyof AggregateGawangan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGawangan[P]>
      : GetScalarType<T[P], AggregateGawangan[P]>
  }




  export type gawanganGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gawanganWhereInput
    orderBy?: gawanganOrderByWithAggregationInput | gawanganOrderByWithAggregationInput[]
    by: GawanganScalarFieldEnum[] | GawanganScalarFieldEnum
    having?: gawanganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GawanganCountAggregateInputType | true
    _avg?: GawanganAvgAggregateInputType
    _sum?: GawanganSumAggregateInputType
    _min?: GawanganMinAggregateInputType
    _max?: GawanganMaxAggregateInputType
  }

  export type GawanganGroupByOutputType = {
    id: number
    nama_gawangan: string
    outlet_id: number
    _count: GawanganCountAggregateOutputType | null
    _avg: GawanganAvgAggregateOutputType | null
    _sum: GawanganSumAggregateOutputType | null
    _min: GawanganMinAggregateOutputType | null
    _max: GawanganMaxAggregateOutputType | null
  }

  type GetGawanganGroupByPayload<T extends gawanganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GawanganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GawanganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GawanganGroupByOutputType[P]>
            : GetScalarType<T[P], GawanganGroupByOutputType[P]>
        }
      >
    >


  export type gawanganSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_gawangan?: boolean
    outlet_id?: boolean
    outlet?: boolean | outletDefaultArgs<ExtArgs>
    detail_gawangans?: boolean | gawangan$detail_gawangansArgs<ExtArgs>
    detail_pembelian_produk?: boolean | gawangan$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | GawanganCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gawangan"]>

  export type gawanganSelectScalar = {
    id?: boolean
    nama_gawangan?: boolean
    outlet_id?: boolean
  }

  export type gawanganInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    outlet?: boolean | outletDefaultArgs<ExtArgs>
    detail_gawangans?: boolean | gawangan$detail_gawangansArgs<ExtArgs>
    detail_pembelian_produk?: boolean | gawangan$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | GawanganCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $gawanganPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "gawangan"
    objects: {
      outlet: Prisma.$outletPayload<ExtArgs>
      detail_gawangans: Prisma.$detail_gawanganPayload<ExtArgs>[]
      detail_pembelian_produk: Prisma.$detail_pembelian_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_gawangan: string
      outlet_id: number
    }, ExtArgs["result"]["gawangan"]>
    composites: {}
  }


  type gawanganGetPayload<S extends boolean | null | undefined | gawanganDefaultArgs> = $Result.GetResult<Prisma.$gawanganPayload, S>

  type gawanganCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gawanganFindManyArgs, 'select' | 'include'> & {
      select?: GawanganCountAggregateInputType | true
    }

  export interface gawanganDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gawangan'], meta: { name: 'gawangan' } }
    /**
     * Find zero or one Gawangan that matches the filter.
     * @param {gawanganFindUniqueArgs} args - Arguments to find a Gawangan
     * @example
     * // Get one Gawangan
     * const gawangan = await prisma.gawangan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gawanganFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganFindUniqueArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Gawangan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gawanganFindUniqueOrThrowArgs} args - Arguments to find a Gawangan
     * @example
     * // Get one Gawangan
     * const gawangan = await prisma.gawangan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gawanganFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Gawangan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganFindFirstArgs} args - Arguments to find a Gawangan
     * @example
     * // Get one Gawangan
     * const gawangan = await prisma.gawangan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gawanganFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganFindFirstArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Gawangan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganFindFirstOrThrowArgs} args - Arguments to find a Gawangan
     * @example
     * // Get one Gawangan
     * const gawangan = await prisma.gawangan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gawanganFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Gawangans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gawangans
     * const gawangans = await prisma.gawangan.findMany()
     * 
     * // Get first 10 Gawangans
     * const gawangans = await prisma.gawangan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gawanganWithIdOnly = await prisma.gawangan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends gawanganFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Gawangan.
     * @param {gawanganCreateArgs} args - Arguments to create a Gawangan.
     * @example
     * // Create one Gawangan
     * const Gawangan = await prisma.gawangan.create({
     *   data: {
     *     // ... data to create a Gawangan
     *   }
     * })
     * 
    **/
    create<T extends gawanganCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganCreateArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Gawangans.
     *     @param {gawanganCreateManyArgs} args - Arguments to create many Gawangans.
     *     @example
     *     // Create many Gawangans
     *     const gawangan = await prisma.gawangan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gawanganCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gawangan.
     * @param {gawanganDeleteArgs} args - Arguments to delete one Gawangan.
     * @example
     * // Delete one Gawangan
     * const Gawangan = await prisma.gawangan.delete({
     *   where: {
     *     // ... filter to delete one Gawangan
     *   }
     * })
     * 
    **/
    delete<T extends gawanganDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganDeleteArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Gawangan.
     * @param {gawanganUpdateArgs} args - Arguments to update one Gawangan.
     * @example
     * // Update one Gawangan
     * const gawangan = await prisma.gawangan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gawanganUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganUpdateArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Gawangans.
     * @param {gawanganDeleteManyArgs} args - Arguments to filter Gawangans to delete.
     * @example
     * // Delete a few Gawangans
     * const { count } = await prisma.gawangan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gawanganDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gawanganDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gawangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gawangans
     * const gawangan = await prisma.gawangan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gawanganUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gawangan.
     * @param {gawanganUpsertArgs} args - Arguments to update or create a Gawangan.
     * @example
     * // Update or create a Gawangan
     * const gawangan = await prisma.gawangan.upsert({
     *   create: {
     *     // ... data to create a Gawangan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gawangan we want to update
     *   }
     * })
    **/
    upsert<T extends gawanganUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gawanganUpsertArgs<ExtArgs>>
    ): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Gawangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganCountArgs} args - Arguments to filter Gawangans to count.
     * @example
     * // Count the number of Gawangans
     * const count = await prisma.gawangan.count({
     *   where: {
     *     // ... the filter for the Gawangans we want to count
     *   }
     * })
    **/
    count<T extends gawanganCountArgs>(
      args?: Subset<T, gawanganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GawanganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gawangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GawanganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GawanganAggregateArgs>(args: Subset<T, GawanganAggregateArgs>): Prisma.PrismaPromise<GetGawanganAggregateType<T>>

    /**
     * Group by Gawangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gawanganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gawanganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gawanganGroupByArgs['orderBy'] }
        : { orderBy?: gawanganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gawanganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGawanganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gawangan model
   */
  readonly fields: gawanganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gawangan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gawanganClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    outlet<T extends outletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, outletDefaultArgs<ExtArgs>>): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detail_gawangans<T extends gawangan$detail_gawangansArgs<ExtArgs> = {}>(args?: Subset<T, gawangan$detail_gawangansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_gawanganPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pembelian_produk<T extends gawangan$detail_pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, gawangan$detail_pembelian_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the gawangan model
   */ 
  interface gawanganFieldRefs {
    readonly id: FieldRef<"gawangan", 'Int'>
    readonly nama_gawangan: FieldRef<"gawangan", 'String'>
    readonly outlet_id: FieldRef<"gawangan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * gawangan findUnique
   */
  export type gawanganFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter, which gawangan to fetch.
     */
    where: gawanganWhereUniqueInput
  }


  /**
   * gawangan findUniqueOrThrow
   */
  export type gawanganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter, which gawangan to fetch.
     */
    where: gawanganWhereUniqueInput
  }


  /**
   * gawangan findFirst
   */
  export type gawanganFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter, which gawangan to fetch.
     */
    where?: gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gawangans to fetch.
     */
    orderBy?: gawanganOrderByWithRelationInput | gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gawangans.
     */
    cursor?: gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gawangans.
     */
    distinct?: GawanganScalarFieldEnum | GawanganScalarFieldEnum[]
  }


  /**
   * gawangan findFirstOrThrow
   */
  export type gawanganFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter, which gawangan to fetch.
     */
    where?: gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gawangans to fetch.
     */
    orderBy?: gawanganOrderByWithRelationInput | gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gawangans.
     */
    cursor?: gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gawangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gawangans.
     */
    distinct?: GawanganScalarFieldEnum | GawanganScalarFieldEnum[]
  }


  /**
   * gawangan findMany
   */
  export type gawanganFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter, which gawangans to fetch.
     */
    where?: gawanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gawangans to fetch.
     */
    orderBy?: gawanganOrderByWithRelationInput | gawanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gawangans.
     */
    cursor?: gawanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gawangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gawangans.
     */
    skip?: number
    distinct?: GawanganScalarFieldEnum | GawanganScalarFieldEnum[]
  }


  /**
   * gawangan create
   */
  export type gawanganCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * The data needed to create a gawangan.
     */
    data: XOR<gawanganCreateInput, gawanganUncheckedCreateInput>
  }


  /**
   * gawangan createMany
   */
  export type gawanganCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gawangans.
     */
    data: gawanganCreateManyInput | gawanganCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gawangan update
   */
  export type gawanganUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * The data needed to update a gawangan.
     */
    data: XOR<gawanganUpdateInput, gawanganUncheckedUpdateInput>
    /**
     * Choose, which gawangan to update.
     */
    where: gawanganWhereUniqueInput
  }


  /**
   * gawangan updateMany
   */
  export type gawanganUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gawangans.
     */
    data: XOR<gawanganUpdateManyMutationInput, gawanganUncheckedUpdateManyInput>
    /**
     * Filter which gawangans to update
     */
    where?: gawanganWhereInput
  }


  /**
   * gawangan upsert
   */
  export type gawanganUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * The filter to search for the gawangan to update in case it exists.
     */
    where: gawanganWhereUniqueInput
    /**
     * In case the gawangan found by the `where` argument doesn't exist, create a new gawangan with this data.
     */
    create: XOR<gawanganCreateInput, gawanganUncheckedCreateInput>
    /**
     * In case the gawangan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gawanganUpdateInput, gawanganUncheckedUpdateInput>
  }


  /**
   * gawangan delete
   */
  export type gawanganDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    /**
     * Filter which gawangan to delete.
     */
    where: gawanganWhereUniqueInput
  }


  /**
   * gawangan deleteMany
   */
  export type gawanganDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gawangans to delete
     */
    where?: gawanganWhereInput
  }


  /**
   * gawangan.detail_gawangans
   */
  export type gawangan$detail_gawangansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_gawangan
     */
    select?: detail_gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_gawanganInclude<ExtArgs> | null
    where?: detail_gawanganWhereInput
    orderBy?: detail_gawanganOrderByWithRelationInput | detail_gawanganOrderByWithRelationInput[]
    cursor?: detail_gawanganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_gawanganScalarFieldEnum | Detail_gawanganScalarFieldEnum[]
  }


  /**
   * gawangan.detail_pembelian_produk
   */
  export type gawangan$detail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    where?: detail_pembelian_produkWhereInput
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    cursor?: detail_pembelian_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * gawangan without action
   */
  export type gawanganDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
  }



  /**
   * Model outlet
   */

  export type AggregateOutlet = {
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  export type OutletAvgAggregateOutputType = {
    id: number | null
  }

  export type OutletSumAggregateOutputType = {
    id: number | null
  }

  export type OutletMinAggregateOutputType = {
    id: number | null
    nama_outlet: string | null
    alamat: string | null
    nama_pic: string | null
    kontak_pic: string | null
  }

  export type OutletMaxAggregateOutputType = {
    id: number | null
    nama_outlet: string | null
    alamat: string | null
    nama_pic: string | null
    kontak_pic: string | null
  }

  export type OutletCountAggregateOutputType = {
    id: number
    nama_outlet: number
    alamat: number
    nama_pic: number
    kontak_pic: number
    _all: number
  }


  export type OutletAvgAggregateInputType = {
    id?: true
  }

  export type OutletSumAggregateInputType = {
    id?: true
  }

  export type OutletMinAggregateInputType = {
    id?: true
    nama_outlet?: true
    alamat?: true
    nama_pic?: true
    kontak_pic?: true
  }

  export type OutletMaxAggregateInputType = {
    id?: true
    nama_outlet?: true
    alamat?: true
    nama_pic?: true
    kontak_pic?: true
  }

  export type OutletCountAggregateInputType = {
    id?: true
    nama_outlet?: true
    alamat?: true
    nama_pic?: true
    kontak_pic?: true
    _all?: true
  }

  export type OutletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which outlet to aggregate.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: outletOrderByWithRelationInput | outletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned outlets
    **/
    _count?: true | OutletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletMaxAggregateInputType
  }

  export type GetOutletAggregateType<T extends OutletAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlet[P]>
      : GetScalarType<T[P], AggregateOutlet[P]>
  }




  export type outletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: outletWhereInput
    orderBy?: outletOrderByWithAggregationInput | outletOrderByWithAggregationInput[]
    by: OutletScalarFieldEnum[] | OutletScalarFieldEnum
    having?: outletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletCountAggregateInputType | true
    _avg?: OutletAvgAggregateInputType
    _sum?: OutletSumAggregateInputType
    _min?: OutletMinAggregateInputType
    _max?: OutletMaxAggregateInputType
  }

  export type OutletGroupByOutputType = {
    id: number
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  type GetOutletGroupByPayload<T extends outletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletGroupByOutputType[P]>
            : GetScalarType<T[P], OutletGroupByOutputType[P]>
        }
      >
    >


  export type outletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_outlet?: boolean
    alamat?: boolean
    nama_pic?: boolean
    kontak_pic?: boolean
    gawangan?: boolean | outlet$gawanganArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type outletSelectScalar = {
    id?: boolean
    nama_outlet?: boolean
    alamat?: boolean
    nama_pic?: boolean
    kontak_pic?: boolean
  }

  export type outletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gawangan?: boolean | outlet$gawanganArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $outletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "outlet"
    objects: {
      gawangan: Prisma.$gawanganPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_outlet: string
      alamat: string
      nama_pic: string
      kontak_pic: string
    }, ExtArgs["result"]["outlet"]>
    composites: {}
  }


  type outletGetPayload<S extends boolean | null | undefined | outletDefaultArgs> = $Result.GetResult<Prisma.$outletPayload, S>

  type outletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<outletFindManyArgs, 'select' | 'include'> & {
      select?: OutletCountAggregateInputType | true
    }

  export interface outletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['outlet'], meta: { name: 'outlet' } }
    /**
     * Find zero or one Outlet that matches the filter.
     * @param {outletFindUniqueArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends outletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, outletFindUniqueArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Outlet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {outletFindUniqueOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends outletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, outletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Outlet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindFirstArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends outletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, outletFindFirstArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Outlet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindFirstOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends outletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, outletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Outlets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outlets
     * const outlets = await prisma.outlet.findMany()
     * 
     * // Get first 10 Outlets
     * const outlets = await prisma.outlet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletWithIdOnly = await prisma.outlet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends outletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, outletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Outlet.
     * @param {outletCreateArgs} args - Arguments to create a Outlet.
     * @example
     * // Create one Outlet
     * const Outlet = await prisma.outlet.create({
     *   data: {
     *     // ... data to create a Outlet
     *   }
     * })
     * 
    **/
    create<T extends outletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, outletCreateArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Outlets.
     *     @param {outletCreateManyArgs} args - Arguments to create many Outlets.
     *     @example
     *     // Create many Outlets
     *     const outlet = await prisma.outlet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends outletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, outletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Outlet.
     * @param {outletDeleteArgs} args - Arguments to delete one Outlet.
     * @example
     * // Delete one Outlet
     * const Outlet = await prisma.outlet.delete({
     *   where: {
     *     // ... filter to delete one Outlet
     *   }
     * })
     * 
    **/
    delete<T extends outletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, outletDeleteArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Outlet.
     * @param {outletUpdateArgs} args - Arguments to update one Outlet.
     * @example
     * // Update one Outlet
     * const outlet = await prisma.outlet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends outletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, outletUpdateArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Outlets.
     * @param {outletDeleteManyArgs} args - Arguments to filter Outlets to delete.
     * @example
     * // Delete a few Outlets
     * const { count } = await prisma.outlet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends outletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, outletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends outletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, outletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Outlet.
     * @param {outletUpsertArgs} args - Arguments to update or create a Outlet.
     * @example
     * // Update or create a Outlet
     * const outlet = await prisma.outlet.upsert({
     *   create: {
     *     // ... data to create a Outlet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outlet we want to update
     *   }
     * })
    **/
    upsert<T extends outletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, outletUpsertArgs<ExtArgs>>
    ): Prisma__outletClient<$Result.GetResult<Prisma.$outletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletCountArgs} args - Arguments to filter Outlets to count.
     * @example
     * // Count the number of Outlets
     * const count = await prisma.outlet.count({
     *   where: {
     *     // ... the filter for the Outlets we want to count
     *   }
     * })
    **/
    count<T extends outletCountArgs>(
      args?: Subset<T, outletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletAggregateArgs>(args: Subset<T, OutletAggregateArgs>): Prisma.PrismaPromise<GetOutletAggregateType<T>>

    /**
     * Group by Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends outletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: outletGroupByArgs['orderBy'] }
        : { orderBy?: outletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, outletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the outlet model
   */
  readonly fields: outletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for outlet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__outletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    gawangan<T extends outlet$gawanganArgs<ExtArgs> = {}>(args?: Subset<T, outlet$gawanganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the outlet model
   */ 
  interface outletFieldRefs {
    readonly id: FieldRef<"outlet", 'Int'>
    readonly nama_outlet: FieldRef<"outlet", 'String'>
    readonly alamat: FieldRef<"outlet", 'String'>
    readonly nama_pic: FieldRef<"outlet", 'String'>
    readonly kontak_pic: FieldRef<"outlet", 'String'>
  }
    

  // Custom InputTypes

  /**
   * outlet findUnique
   */
  export type outletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter, which outlet to fetch.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet findUniqueOrThrow
   */
  export type outletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter, which outlet to fetch.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet findFirst
   */
  export type outletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter, which outlet to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: outletOrderByWithRelationInput | outletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }


  /**
   * outlet findFirstOrThrow
   */
  export type outletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter, which outlet to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: outletOrderByWithRelationInput | outletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }


  /**
   * outlet findMany
   */
  export type outletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter, which outlets to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: outletOrderByWithRelationInput | outletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }


  /**
   * outlet create
   */
  export type outletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * The data needed to create a outlet.
     */
    data: XOR<outletCreateInput, outletUncheckedCreateInput>
  }


  /**
   * outlet createMany
   */
  export type outletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many outlets.
     */
    data: outletCreateManyInput | outletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * outlet update
   */
  export type outletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * The data needed to update a outlet.
     */
    data: XOR<outletUpdateInput, outletUncheckedUpdateInput>
    /**
     * Choose, which outlet to update.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet updateMany
   */
  export type outletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update outlets.
     */
    data: XOR<outletUpdateManyMutationInput, outletUncheckedUpdateManyInput>
    /**
     * Filter which outlets to update
     */
    where?: outletWhereInput
  }


  /**
   * outlet upsert
   */
  export type outletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * The filter to search for the outlet to update in case it exists.
     */
    where: outletWhereUniqueInput
    /**
     * In case the outlet found by the `where` argument doesn't exist, create a new outlet with this data.
     */
    create: XOR<outletCreateInput, outletUncheckedCreateInput>
    /**
     * In case the outlet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<outletUpdateInput, outletUncheckedUpdateInput>
  }


  /**
   * outlet delete
   */
  export type outletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
    /**
     * Filter which outlet to delete.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet deleteMany
   */
  export type outletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which outlets to delete
     */
    where?: outletWhereInput
  }


  /**
   * outlet.gawangan
   */
  export type outlet$gawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gawangan
     */
    select?: gawanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gawanganInclude<ExtArgs> | null
    where?: gawanganWhereInput
    orderBy?: gawanganOrderByWithRelationInput | gawanganOrderByWithRelationInput[]
    cursor?: gawanganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GawanganScalarFieldEnum | GawanganScalarFieldEnum[]
  }


  /**
   * outlet without action
   */
  export type outletDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude<ExtArgs> | null
  }



  /**
   * Model pembelian_produk
   */

  export type AggregatePembelian_produk = {
    _count: Pembelian_produkCountAggregateOutputType | null
    _avg: Pembelian_produkAvgAggregateOutputType | null
    _sum: Pembelian_produkSumAggregateOutputType | null
    _min: Pembelian_produkMinAggregateOutputType | null
    _max: Pembelian_produkMaxAggregateOutputType | null
  }

  export type Pembelian_produkAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Pembelian_produkSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Pembelian_produkMinAggregateOutputType = {
    id: number | null
    tanggal_pembelian: Date | null
    nama_pembeli: string | null
    kontak_pembeli: string | null
    user_id: number | null
  }

  export type Pembelian_produkMaxAggregateOutputType = {
    id: number | null
    tanggal_pembelian: Date | null
    nama_pembeli: string | null
    kontak_pembeli: string | null
    user_id: number | null
  }

  export type Pembelian_produkCountAggregateOutputType = {
    id: number
    tanggal_pembelian: number
    nama_pembeli: number
    kontak_pembeli: number
    user_id: number
    _all: number
  }


  export type Pembelian_produkAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Pembelian_produkSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Pembelian_produkMinAggregateInputType = {
    id?: true
    tanggal_pembelian?: true
    nama_pembeli?: true
    kontak_pembeli?: true
    user_id?: true
  }

  export type Pembelian_produkMaxAggregateInputType = {
    id?: true
    tanggal_pembelian?: true
    nama_pembeli?: true
    kontak_pembeli?: true
    user_id?: true
  }

  export type Pembelian_produkCountAggregateInputType = {
    id?: true
    tanggal_pembelian?: true
    nama_pembeli?: true
    kontak_pembeli?: true
    user_id?: true
    _all?: true
  }

  export type Pembelian_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pembelian_produk to aggregate.
     */
    where?: pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembelian_produks to fetch.
     */
    orderBy?: pembelian_produkOrderByWithRelationInput | pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pembelian_produks
    **/
    _count?: true | Pembelian_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pembelian_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pembelian_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pembelian_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pembelian_produkMaxAggregateInputType
  }

  export type GetPembelian_produkAggregateType<T extends Pembelian_produkAggregateArgs> = {
        [P in keyof T & keyof AggregatePembelian_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePembelian_produk[P]>
      : GetScalarType<T[P], AggregatePembelian_produk[P]>
  }




  export type pembelian_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: pembelian_produkWhereInput
    orderBy?: pembelian_produkOrderByWithAggregationInput | pembelian_produkOrderByWithAggregationInput[]
    by: Pembelian_produkScalarFieldEnum[] | Pembelian_produkScalarFieldEnum
    having?: pembelian_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pembelian_produkCountAggregateInputType | true
    _avg?: Pembelian_produkAvgAggregateInputType
    _sum?: Pembelian_produkSumAggregateInputType
    _min?: Pembelian_produkMinAggregateInputType
    _max?: Pembelian_produkMaxAggregateInputType
  }

  export type Pembelian_produkGroupByOutputType = {
    id: number
    tanggal_pembelian: Date
    nama_pembeli: string
    kontak_pembeli: string
    user_id: number
    _count: Pembelian_produkCountAggregateOutputType | null
    _avg: Pembelian_produkAvgAggregateOutputType | null
    _sum: Pembelian_produkSumAggregateOutputType | null
    _min: Pembelian_produkMinAggregateOutputType | null
    _max: Pembelian_produkMaxAggregateOutputType | null
  }

  type GetPembelian_produkGroupByPayload<T extends pembelian_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pembelian_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pembelian_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pembelian_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Pembelian_produkGroupByOutputType[P]>
        }
      >
    >


  export type pembelian_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal_pembelian?: boolean
    nama_pembeli?: boolean
    kontak_pembeli?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    detail_diskon?: boolean | pembelian_produk$detail_diskonArgs<ExtArgs>
    detail_pembelian_produk?: boolean | pembelian_produk$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | Pembelian_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembelian_produk"]>

  export type pembelian_produkSelectScalar = {
    id?: boolean
    tanggal_pembelian?: boolean
    nama_pembeli?: boolean
    kontak_pembeli?: boolean
    user_id?: boolean
  }

  export type pembelian_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    detail_diskon?: boolean | pembelian_produk$detail_diskonArgs<ExtArgs>
    detail_pembelian_produk?: boolean | pembelian_produk$detail_pembelian_produkArgs<ExtArgs>
    _count?: boolean | Pembelian_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pembelian_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "pembelian_produk"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      detail_diskon: Prisma.$detail_diskonPayload<ExtArgs>[]
      detail_pembelian_produk: Prisma.$detail_pembelian_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      tanggal_pembelian: Date
      nama_pembeli: string
      kontak_pembeli: string
      user_id: number
    }, ExtArgs["result"]["pembelian_produk"]>
    composites: {}
  }


  type pembelian_produkGetPayload<S extends boolean | null | undefined | pembelian_produkDefaultArgs> = $Result.GetResult<Prisma.$pembelian_produkPayload, S>

  type pembelian_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<pembelian_produkFindManyArgs, 'select' | 'include'> & {
      select?: Pembelian_produkCountAggregateInputType | true
    }

  export interface pembelian_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pembelian_produk'], meta: { name: 'pembelian_produk' } }
    /**
     * Find zero or one Pembelian_produk that matches the filter.
     * @param {pembelian_produkFindUniqueArgs} args - Arguments to find a Pembelian_produk
     * @example
     * // Get one Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pembelian_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pembelian_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pembelian_produkFindUniqueOrThrowArgs} args - Arguments to find a Pembelian_produk
     * @example
     * // Get one Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pembelian_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pembelian_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkFindFirstArgs} args - Arguments to find a Pembelian_produk
     * @example
     * // Get one Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pembelian_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkFindFirstArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pembelian_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkFindFirstOrThrowArgs} args - Arguments to find a Pembelian_produk
     * @example
     * // Get one Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pembelian_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pembelian_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pembelian_produks
     * const pembelian_produks = await prisma.pembelian_produk.findMany()
     * 
     * // Get first 10 Pembelian_produks
     * const pembelian_produks = await prisma.pembelian_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pembelian_produkWithIdOnly = await prisma.pembelian_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pembelian_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pembelian_produk.
     * @param {pembelian_produkCreateArgs} args - Arguments to create a Pembelian_produk.
     * @example
     * // Create one Pembelian_produk
     * const Pembelian_produk = await prisma.pembelian_produk.create({
     *   data: {
     *     // ... data to create a Pembelian_produk
     *   }
     * })
     * 
    **/
    create<T extends pembelian_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkCreateArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pembelian_produks.
     *     @param {pembelian_produkCreateManyArgs} args - Arguments to create many Pembelian_produks.
     *     @example
     *     // Create many Pembelian_produks
     *     const pembelian_produk = await prisma.pembelian_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pembelian_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pembelian_produk.
     * @param {pembelian_produkDeleteArgs} args - Arguments to delete one Pembelian_produk.
     * @example
     * // Delete one Pembelian_produk
     * const Pembelian_produk = await prisma.pembelian_produk.delete({
     *   where: {
     *     // ... filter to delete one Pembelian_produk
     *   }
     * })
     * 
    **/
    delete<T extends pembelian_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkDeleteArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pembelian_produk.
     * @param {pembelian_produkUpdateArgs} args - Arguments to update one Pembelian_produk.
     * @example
     * // Update one Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pembelian_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkUpdateArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pembelian_produks.
     * @param {pembelian_produkDeleteManyArgs} args - Arguments to filter Pembelian_produks to delete.
     * @example
     * // Delete a few Pembelian_produks
     * const { count } = await prisma.pembelian_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pembelian_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pembelian_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pembelian_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pembelian_produks
     * const pembelian_produk = await prisma.pembelian_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pembelian_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pembelian_produk.
     * @param {pembelian_produkUpsertArgs} args - Arguments to update or create a Pembelian_produk.
     * @example
     * // Update or create a Pembelian_produk
     * const pembelian_produk = await prisma.pembelian_produk.upsert({
     *   create: {
     *     // ... data to create a Pembelian_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pembelian_produk we want to update
     *   }
     * })
    **/
    upsert<T extends pembelian_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pembelian_produkUpsertArgs<ExtArgs>>
    ): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pembelian_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkCountArgs} args - Arguments to filter Pembelian_produks to count.
     * @example
     * // Count the number of Pembelian_produks
     * const count = await prisma.pembelian_produk.count({
     *   where: {
     *     // ... the filter for the Pembelian_produks we want to count
     *   }
     * })
    **/
    count<T extends pembelian_produkCountArgs>(
      args?: Subset<T, pembelian_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pembelian_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pembelian_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pembelian_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pembelian_produkAggregateArgs>(args: Subset<T, Pembelian_produkAggregateArgs>): Prisma.PrismaPromise<GetPembelian_produkAggregateType<T>>

    /**
     * Group by Pembelian_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pembelian_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pembelian_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pembelian_produkGroupByArgs['orderBy'] }
        : { orderBy?: pembelian_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pembelian_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPembelian_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pembelian_produk model
   */
  readonly fields: pembelian_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pembelian_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pembelian_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detail_diskon<T extends pembelian_produk$detail_diskonArgs<ExtArgs> = {}>(args?: Subset<T, pembelian_produk$detail_diskonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_pembelian_produk<T extends pembelian_produk$detail_pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, pembelian_produk$detail_pembelian_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pembelian_produk model
   */ 
  interface pembelian_produkFieldRefs {
    readonly id: FieldRef<"pembelian_produk", 'Int'>
    readonly tanggal_pembelian: FieldRef<"pembelian_produk", 'DateTime'>
    readonly nama_pembeli: FieldRef<"pembelian_produk", 'String'>
    readonly kontak_pembeli: FieldRef<"pembelian_produk", 'String'>
    readonly user_id: FieldRef<"pembelian_produk", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * pembelian_produk findUnique
   */
  export type pembelian_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which pembelian_produk to fetch.
     */
    where: pembelian_produkWhereUniqueInput
  }


  /**
   * pembelian_produk findUniqueOrThrow
   */
  export type pembelian_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which pembelian_produk to fetch.
     */
    where: pembelian_produkWhereUniqueInput
  }


  /**
   * pembelian_produk findFirst
   */
  export type pembelian_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which pembelian_produk to fetch.
     */
    where?: pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembelian_produks to fetch.
     */
    orderBy?: pembelian_produkOrderByWithRelationInput | pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pembelian_produks.
     */
    cursor?: pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pembelian_produks.
     */
    distinct?: Pembelian_produkScalarFieldEnum | Pembelian_produkScalarFieldEnum[]
  }


  /**
   * pembelian_produk findFirstOrThrow
   */
  export type pembelian_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which pembelian_produk to fetch.
     */
    where?: pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembelian_produks to fetch.
     */
    orderBy?: pembelian_produkOrderByWithRelationInput | pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pembelian_produks.
     */
    cursor?: pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pembelian_produks.
     */
    distinct?: Pembelian_produkScalarFieldEnum | Pembelian_produkScalarFieldEnum[]
  }


  /**
   * pembelian_produk findMany
   */
  export type pembelian_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which pembelian_produks to fetch.
     */
    where?: pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pembelian_produks to fetch.
     */
    orderBy?: pembelian_produkOrderByWithRelationInput | pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pembelian_produks.
     */
    cursor?: pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pembelian_produks.
     */
    skip?: number
    distinct?: Pembelian_produkScalarFieldEnum | Pembelian_produkScalarFieldEnum[]
  }


  /**
   * pembelian_produk create
   */
  export type pembelian_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a pembelian_produk.
     */
    data: XOR<pembelian_produkCreateInput, pembelian_produkUncheckedCreateInput>
  }


  /**
   * pembelian_produk createMany
   */
  export type pembelian_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pembelian_produks.
     */
    data: pembelian_produkCreateManyInput | pembelian_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pembelian_produk update
   */
  export type pembelian_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a pembelian_produk.
     */
    data: XOR<pembelian_produkUpdateInput, pembelian_produkUncheckedUpdateInput>
    /**
     * Choose, which pembelian_produk to update.
     */
    where: pembelian_produkWhereUniqueInput
  }


  /**
   * pembelian_produk updateMany
   */
  export type pembelian_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pembelian_produks.
     */
    data: XOR<pembelian_produkUpdateManyMutationInput, pembelian_produkUncheckedUpdateManyInput>
    /**
     * Filter which pembelian_produks to update
     */
    where?: pembelian_produkWhereInput
  }


  /**
   * pembelian_produk upsert
   */
  export type pembelian_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the pembelian_produk to update in case it exists.
     */
    where: pembelian_produkWhereUniqueInput
    /**
     * In case the pembelian_produk found by the `where` argument doesn't exist, create a new pembelian_produk with this data.
     */
    create: XOR<pembelian_produkCreateInput, pembelian_produkUncheckedCreateInput>
    /**
     * In case the pembelian_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pembelian_produkUpdateInput, pembelian_produkUncheckedUpdateInput>
  }


  /**
   * pembelian_produk delete
   */
  export type pembelian_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter which pembelian_produk to delete.
     */
    where: pembelian_produkWhereUniqueInput
  }


  /**
   * pembelian_produk deleteMany
   */
  export type pembelian_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pembelian_produks to delete
     */
    where?: pembelian_produkWhereInput
  }


  /**
   * pembelian_produk.detail_diskon
   */
  export type pembelian_produk$detail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    where?: detail_diskonWhereInput
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    cursor?: detail_diskonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * pembelian_produk.detail_pembelian_produk
   */
  export type pembelian_produk$detail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    where?: detail_pembelian_produkWhereInput
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    cursor?: detail_pembelian_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * pembelian_produk without action
   */
  export type pembelian_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
  }



  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    nama_lengkap: string | null
    kontak: string | null
    email: string | null
    username: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    nama_lengkap: string | null
    kontak: string | null
    email: string | null
    username: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nama_lengkap: number
    kontak: number
    email: number
    username: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    nama_lengkap?: true
    kontak?: true
    email?: true
    username?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nama_lengkap?: true
    kontak?: true
    email?: true
    username?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nama_lengkap?: true
    kontak?: true
    email?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_lengkap?: boolean
    kontak?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    pembelian_produk?: boolean | user$pembelian_produkArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    nama_lengkap?: boolean
    kontak?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembelian_produk?: boolean | user$pembelian_produkArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      pembelian_produk: Prisma.$pembelian_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_lengkap: string
      kontak: string
      email: string
      username: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pembelian_produk<T extends user$pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, user$pembelian_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly nama_lengkap: FieldRef<"user", 'String'>
    readonly kontak: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.pembelian_produk
   */
  export type user$pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    where?: pembelian_produkWhereInput
    orderBy?: pembelian_produkOrderByWithRelationInput | pembelian_produkOrderByWithRelationInput[]
    cursor?: pembelian_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pembelian_produkScalarFieldEnum | Pembelian_produkScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model detail_pembelian_produk
   */

  export type AggregateDetail_pembelian_produk = {
    _count: Detail_pembelian_produkCountAggregateOutputType | null
    _avg: Detail_pembelian_produkAvgAggregateOutputType | null
    _sum: Detail_pembelian_produkSumAggregateOutputType | null
    _min: Detail_pembelian_produkMinAggregateOutputType | null
    _max: Detail_pembelian_produkMaxAggregateOutputType | null
  }

  export type Detail_pembelian_produkAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    gawangan_id: number | null
  }

  export type Detail_pembelian_produkSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    gawangan_id: number | null
  }

  export type Detail_pembelian_produkMinAggregateOutputType = {
    id: number | null
    jumlah: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    gawangan_id: number | null
  }

  export type Detail_pembelian_produkMaxAggregateOutputType = {
    id: number | null
    jumlah: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    gawangan_id: number | null
  }

  export type Detail_pembelian_produkCountAggregateOutputType = {
    id: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
    _all: number
  }


  export type Detail_pembelian_produkAvgAggregateInputType = {
    id?: true
    jumlah?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    gawangan_id?: true
  }

  export type Detail_pembelian_produkSumAggregateInputType = {
    id?: true
    jumlah?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    gawangan_id?: true
  }

  export type Detail_pembelian_produkMinAggregateInputType = {
    id?: true
    jumlah?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    gawangan_id?: true
  }

  export type Detail_pembelian_produkMaxAggregateInputType = {
    id?: true
    jumlah?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    gawangan_id?: true
  }

  export type Detail_pembelian_produkCountAggregateInputType = {
    id?: true
    jumlah?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    gawangan_id?: true
    _all?: true
  }

  export type Detail_pembelian_produkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pembelian_produk to aggregate.
     */
    where?: detail_pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pembelian_produks to fetch.
     */
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_pembelian_produks
    **/
    _count?: true | Detail_pembelian_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_pembelian_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_pembelian_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_pembelian_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_pembelian_produkMaxAggregateInputType
  }

  export type GetDetail_pembelian_produkAggregateType<T extends Detail_pembelian_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_pembelian_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_pembelian_produk[P]>
      : GetScalarType<T[P], AggregateDetail_pembelian_produk[P]>
  }




  export type detail_pembelian_produkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_pembelian_produkWhereInput
    orderBy?: detail_pembelian_produkOrderByWithAggregationInput | detail_pembelian_produkOrderByWithAggregationInput[]
    by: Detail_pembelian_produkScalarFieldEnum[] | Detail_pembelian_produkScalarFieldEnum
    having?: detail_pembelian_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_pembelian_produkCountAggregateInputType | true
    _avg?: Detail_pembelian_produkAvgAggregateInputType
    _sum?: Detail_pembelian_produkSumAggregateInputType
    _min?: Detail_pembelian_produkMinAggregateInputType
    _max?: Detail_pembelian_produkMaxAggregateInputType
  }

  export type Detail_pembelian_produkGroupByOutputType = {
    id: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
    _count: Detail_pembelian_produkCountAggregateOutputType | null
    _avg: Detail_pembelian_produkAvgAggregateOutputType | null
    _sum: Detail_pembelian_produkSumAggregateOutputType | null
    _min: Detail_pembelian_produkMinAggregateOutputType | null
    _max: Detail_pembelian_produkMaxAggregateOutputType | null
  }

  type GetDetail_pembelian_produkGroupByPayload<T extends detail_pembelian_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_pembelian_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_pembelian_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_pembelian_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_pembelian_produkGroupByOutputType[P]>
        }
      >
    >


  export type detail_pembelian_produkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jumlah?: boolean
    diskon_id?: boolean
    produk_item_id?: boolean
    pembelian_produk_id?: boolean
    gawangan_id?: boolean
    diskon?: boolean | diskonDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
    pembelian_produk?: boolean | pembelian_produkDefaultArgs<ExtArgs>
    gawangan?: boolean | gawanganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_pembelian_produk"]>

  export type detail_pembelian_produkSelectScalar = {
    id?: boolean
    jumlah?: boolean
    diskon_id?: boolean
    produk_item_id?: boolean
    pembelian_produk_id?: boolean
    gawangan_id?: boolean
  }

  export type detail_pembelian_produkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    diskon?: boolean | diskonDefaultArgs<ExtArgs>
    produk_item?: boolean | produk_itemDefaultArgs<ExtArgs>
    pembelian_produk?: boolean | pembelian_produkDefaultArgs<ExtArgs>
    gawangan?: boolean | gawanganDefaultArgs<ExtArgs>
  }


  export type $detail_pembelian_produkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_pembelian_produk"
    objects: {
      diskon: Prisma.$diskonPayload<ExtArgs>
      produk_item: Prisma.$produk_itemPayload<ExtArgs>
      pembelian_produk: Prisma.$pembelian_produkPayload<ExtArgs>
      gawangan: Prisma.$gawanganPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      jumlah: number
      diskon_id: number
      produk_item_id: number
      pembelian_produk_id: number
      gawangan_id: number
    }, ExtArgs["result"]["detail_pembelian_produk"]>
    composites: {}
  }


  type detail_pembelian_produkGetPayload<S extends boolean | null | undefined | detail_pembelian_produkDefaultArgs> = $Result.GetResult<Prisma.$detail_pembelian_produkPayload, S>

  type detail_pembelian_produkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_pembelian_produkFindManyArgs, 'select' | 'include'> & {
      select?: Detail_pembelian_produkCountAggregateInputType | true
    }

  export interface detail_pembelian_produkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_pembelian_produk'], meta: { name: 'detail_pembelian_produk' } }
    /**
     * Find zero or one Detail_pembelian_produk that matches the filter.
     * @param {detail_pembelian_produkFindUniqueArgs} args - Arguments to find a Detail_pembelian_produk
     * @example
     * // Get one Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_pembelian_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_pembelian_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_pembelian_produkFindUniqueOrThrowArgs} args - Arguments to find a Detail_pembelian_produk
     * @example
     * // Get one Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_pembelian_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_pembelian_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkFindFirstArgs} args - Arguments to find a Detail_pembelian_produk
     * @example
     * // Get one Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_pembelian_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkFindFirstArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_pembelian_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkFindFirstOrThrowArgs} args - Arguments to find a Detail_pembelian_produk
     * @example
     * // Get one Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_pembelian_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_pembelian_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_pembelian_produks
     * const detail_pembelian_produks = await prisma.detail_pembelian_produk.findMany()
     * 
     * // Get first 10 Detail_pembelian_produks
     * const detail_pembelian_produks = await prisma.detail_pembelian_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_pembelian_produkWithIdOnly = await prisma.detail_pembelian_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_pembelian_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_pembelian_produk.
     * @param {detail_pembelian_produkCreateArgs} args - Arguments to create a Detail_pembelian_produk.
     * @example
     * // Create one Detail_pembelian_produk
     * const Detail_pembelian_produk = await prisma.detail_pembelian_produk.create({
     *   data: {
     *     // ... data to create a Detail_pembelian_produk
     *   }
     * })
     * 
    **/
    create<T extends detail_pembelian_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkCreateArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_pembelian_produks.
     *     @param {detail_pembelian_produkCreateManyArgs} args - Arguments to create many Detail_pembelian_produks.
     *     @example
     *     // Create many Detail_pembelian_produks
     *     const detail_pembelian_produk = await prisma.detail_pembelian_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_pembelian_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_pembelian_produk.
     * @param {detail_pembelian_produkDeleteArgs} args - Arguments to delete one Detail_pembelian_produk.
     * @example
     * // Delete one Detail_pembelian_produk
     * const Detail_pembelian_produk = await prisma.detail_pembelian_produk.delete({
     *   where: {
     *     // ... filter to delete one Detail_pembelian_produk
     *   }
     * })
     * 
    **/
    delete<T extends detail_pembelian_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkDeleteArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_pembelian_produk.
     * @param {detail_pembelian_produkUpdateArgs} args - Arguments to update one Detail_pembelian_produk.
     * @example
     * // Update one Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_pembelian_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkUpdateArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_pembelian_produks.
     * @param {detail_pembelian_produkDeleteManyArgs} args - Arguments to filter Detail_pembelian_produks to delete.
     * @example
     * // Delete a few Detail_pembelian_produks
     * const { count } = await prisma.detail_pembelian_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_pembelian_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_pembelian_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_pembelian_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_pembelian_produks
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_pembelian_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_pembelian_produk.
     * @param {detail_pembelian_produkUpsertArgs} args - Arguments to update or create a Detail_pembelian_produk.
     * @example
     * // Update or create a Detail_pembelian_produk
     * const detail_pembelian_produk = await prisma.detail_pembelian_produk.upsert({
     *   create: {
     *     // ... data to create a Detail_pembelian_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_pembelian_produk we want to update
     *   }
     * })
    **/
    upsert<T extends detail_pembelian_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_pembelian_produkUpsertArgs<ExtArgs>>
    ): Prisma__detail_pembelian_produkClient<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_pembelian_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkCountArgs} args - Arguments to filter Detail_pembelian_produks to count.
     * @example
     * // Count the number of Detail_pembelian_produks
     * const count = await prisma.detail_pembelian_produk.count({
     *   where: {
     *     // ... the filter for the Detail_pembelian_produks we want to count
     *   }
     * })
    **/
    count<T extends detail_pembelian_produkCountArgs>(
      args?: Subset<T, detail_pembelian_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_pembelian_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_pembelian_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_pembelian_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_pembelian_produkAggregateArgs>(args: Subset<T, Detail_pembelian_produkAggregateArgs>): Prisma.PrismaPromise<GetDetail_pembelian_produkAggregateType<T>>

    /**
     * Group by Detail_pembelian_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_pembelian_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_pembelian_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_pembelian_produkGroupByArgs['orderBy'] }
        : { orderBy?: detail_pembelian_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_pembelian_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_pembelian_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_pembelian_produk model
   */
  readonly fields: detail_pembelian_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_pembelian_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_pembelian_produkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    diskon<T extends diskonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, diskonDefaultArgs<ExtArgs>>): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produk_item<T extends produk_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produk_itemDefaultArgs<ExtArgs>>): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pembelian_produk<T extends pembelian_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pembelian_produkDefaultArgs<ExtArgs>>): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    gawangan<T extends gawanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gawanganDefaultArgs<ExtArgs>>): Prisma__gawanganClient<$Result.GetResult<Prisma.$gawanganPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_pembelian_produk model
   */ 
  interface detail_pembelian_produkFieldRefs {
    readonly id: FieldRef<"detail_pembelian_produk", 'Int'>
    readonly jumlah: FieldRef<"detail_pembelian_produk", 'Int'>
    readonly diskon_id: FieldRef<"detail_pembelian_produk", 'Int'>
    readonly produk_item_id: FieldRef<"detail_pembelian_produk", 'Int'>
    readonly pembelian_produk_id: FieldRef<"detail_pembelian_produk", 'Int'>
    readonly gawangan_id: FieldRef<"detail_pembelian_produk", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * detail_pembelian_produk findUnique
   */
  export type detail_pembelian_produkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pembelian_produk to fetch.
     */
    where: detail_pembelian_produkWhereUniqueInput
  }


  /**
   * detail_pembelian_produk findUniqueOrThrow
   */
  export type detail_pembelian_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pembelian_produk to fetch.
     */
    where: detail_pembelian_produkWhereUniqueInput
  }


  /**
   * detail_pembelian_produk findFirst
   */
  export type detail_pembelian_produkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pembelian_produk to fetch.
     */
    where?: detail_pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pembelian_produks to fetch.
     */
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pembelian_produks.
     */
    cursor?: detail_pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pembelian_produks.
     */
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * detail_pembelian_produk findFirstOrThrow
   */
  export type detail_pembelian_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pembelian_produk to fetch.
     */
    where?: detail_pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pembelian_produks to fetch.
     */
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_pembelian_produks.
     */
    cursor?: detail_pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pembelian_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_pembelian_produks.
     */
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * detail_pembelian_produk findMany
   */
  export type detail_pembelian_produkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_pembelian_produks to fetch.
     */
    where?: detail_pembelian_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_pembelian_produks to fetch.
     */
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_pembelian_produks.
     */
    cursor?: detail_pembelian_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_pembelian_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_pembelian_produks.
     */
    skip?: number
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * detail_pembelian_produk create
   */
  export type detail_pembelian_produkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_pembelian_produk.
     */
    data: XOR<detail_pembelian_produkCreateInput, detail_pembelian_produkUncheckedCreateInput>
  }


  /**
   * detail_pembelian_produk createMany
   */
  export type detail_pembelian_produkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_pembelian_produks.
     */
    data: detail_pembelian_produkCreateManyInput | detail_pembelian_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_pembelian_produk update
   */
  export type detail_pembelian_produkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_pembelian_produk.
     */
    data: XOR<detail_pembelian_produkUpdateInput, detail_pembelian_produkUncheckedUpdateInput>
    /**
     * Choose, which detail_pembelian_produk to update.
     */
    where: detail_pembelian_produkWhereUniqueInput
  }


  /**
   * detail_pembelian_produk updateMany
   */
  export type detail_pembelian_produkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_pembelian_produks.
     */
    data: XOR<detail_pembelian_produkUpdateManyMutationInput, detail_pembelian_produkUncheckedUpdateManyInput>
    /**
     * Filter which detail_pembelian_produks to update
     */
    where?: detail_pembelian_produkWhereInput
  }


  /**
   * detail_pembelian_produk upsert
   */
  export type detail_pembelian_produkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_pembelian_produk to update in case it exists.
     */
    where: detail_pembelian_produkWhereUniqueInput
    /**
     * In case the detail_pembelian_produk found by the `where` argument doesn't exist, create a new detail_pembelian_produk with this data.
     */
    create: XOR<detail_pembelian_produkCreateInput, detail_pembelian_produkUncheckedCreateInput>
    /**
     * In case the detail_pembelian_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_pembelian_produkUpdateInput, detail_pembelian_produkUncheckedUpdateInput>
  }


  /**
   * detail_pembelian_produk delete
   */
  export type detail_pembelian_produkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    /**
     * Filter which detail_pembelian_produk to delete.
     */
    where: detail_pembelian_produkWhereUniqueInput
  }


  /**
   * detail_pembelian_produk deleteMany
   */
  export type detail_pembelian_produkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_pembelian_produks to delete
     */
    where?: detail_pembelian_produkWhereInput
  }


  /**
   * detail_pembelian_produk without action
   */
  export type detail_pembelian_produkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
  }



  /**
   * Model diskon
   */

  export type AggregateDiskon = {
    _count: DiskonCountAggregateOutputType | null
    _avg: DiskonAvgAggregateOutputType | null
    _sum: DiskonSumAggregateOutputType | null
    _min: DiskonMinAggregateOutputType | null
    _max: DiskonMaxAggregateOutputType | null
  }

  export type DiskonAvgAggregateOutputType = {
    id: number | null
    jumlah_diskon: number | null
  }

  export type DiskonSumAggregateOutputType = {
    id: number | null
    jumlah_diskon: number | null
  }

  export type DiskonMinAggregateOutputType = {
    id: number | null
    nama_diskon: string | null
    tipe_diskon: $Enums.TipeDiskon | null
    jumlah_diskon: number | null
    tanggal_mulai: Date | null
    tanggal_selesai: Date | null
  }

  export type DiskonMaxAggregateOutputType = {
    id: number | null
    nama_diskon: string | null
    tipe_diskon: $Enums.TipeDiskon | null
    jumlah_diskon: number | null
    tanggal_mulai: Date | null
    tanggal_selesai: Date | null
  }

  export type DiskonCountAggregateOutputType = {
    id: number
    nama_diskon: number
    tipe_diskon: number
    jumlah_diskon: number
    tanggal_mulai: number
    tanggal_selesai: number
    _all: number
  }


  export type DiskonAvgAggregateInputType = {
    id?: true
    jumlah_diskon?: true
  }

  export type DiskonSumAggregateInputType = {
    id?: true
    jumlah_diskon?: true
  }

  export type DiskonMinAggregateInputType = {
    id?: true
    nama_diskon?: true
    tipe_diskon?: true
    jumlah_diskon?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
  }

  export type DiskonMaxAggregateInputType = {
    id?: true
    nama_diskon?: true
    tipe_diskon?: true
    jumlah_diskon?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
  }

  export type DiskonCountAggregateInputType = {
    id?: true
    nama_diskon?: true
    tipe_diskon?: true
    jumlah_diskon?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
    _all?: true
  }

  export type DiskonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which diskon to aggregate.
     */
    where?: diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskons to fetch.
     */
    orderBy?: diskonOrderByWithRelationInput | diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diskons
    **/
    _count?: true | DiskonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiskonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiskonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiskonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiskonMaxAggregateInputType
  }

  export type GetDiskonAggregateType<T extends DiskonAggregateArgs> = {
        [P in keyof T & keyof AggregateDiskon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiskon[P]>
      : GetScalarType<T[P], AggregateDiskon[P]>
  }




  export type diskonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: diskonWhereInput
    orderBy?: diskonOrderByWithAggregationInput | diskonOrderByWithAggregationInput[]
    by: DiskonScalarFieldEnum[] | DiskonScalarFieldEnum
    having?: diskonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiskonCountAggregateInputType | true
    _avg?: DiskonAvgAggregateInputType
    _sum?: DiskonSumAggregateInputType
    _min?: DiskonMinAggregateInputType
    _max?: DiskonMaxAggregateInputType
  }

  export type DiskonGroupByOutputType = {
    id: number
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date
    tanggal_selesai: Date
    _count: DiskonCountAggregateOutputType | null
    _avg: DiskonAvgAggregateOutputType | null
    _sum: DiskonSumAggregateOutputType | null
    _min: DiskonMinAggregateOutputType | null
    _max: DiskonMaxAggregateOutputType | null
  }

  type GetDiskonGroupByPayload<T extends diskonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiskonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiskonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiskonGroupByOutputType[P]>
            : GetScalarType<T[P], DiskonGroupByOutputType[P]>
        }
      >
    >


  export type diskonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_diskon?: boolean
    tipe_diskon?: boolean
    jumlah_diskon?: boolean
    tanggal_mulai?: boolean
    tanggal_selesai?: boolean
    detail_pembelian_produk?: boolean | diskon$detail_pembelian_produkArgs<ExtArgs>
    detail_diskon?: boolean | diskon$detail_diskonArgs<ExtArgs>
    _count?: boolean | DiskonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diskon"]>

  export type diskonSelectScalar = {
    id?: boolean
    nama_diskon?: boolean
    tipe_diskon?: boolean
    jumlah_diskon?: boolean
    tanggal_mulai?: boolean
    tanggal_selesai?: boolean
  }

  export type diskonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    detail_pembelian_produk?: boolean | diskon$detail_pembelian_produkArgs<ExtArgs>
    detail_diskon?: boolean | diskon$detail_diskonArgs<ExtArgs>
    _count?: boolean | DiskonCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $diskonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "diskon"
    objects: {
      detail_pembelian_produk: Prisma.$detail_pembelian_produkPayload<ExtArgs>[]
      detail_diskon: Prisma.$detail_diskonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nama_diskon: string
      tipe_diskon: $Enums.TipeDiskon
      jumlah_diskon: number
      tanggal_mulai: Date
      tanggal_selesai: Date
    }, ExtArgs["result"]["diskon"]>
    composites: {}
  }


  type diskonGetPayload<S extends boolean | null | undefined | diskonDefaultArgs> = $Result.GetResult<Prisma.$diskonPayload, S>

  type diskonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<diskonFindManyArgs, 'select' | 'include'> & {
      select?: DiskonCountAggregateInputType | true
    }

  export interface diskonDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diskon'], meta: { name: 'diskon' } }
    /**
     * Find zero or one Diskon that matches the filter.
     * @param {diskonFindUniqueArgs} args - Arguments to find a Diskon
     * @example
     * // Get one Diskon
     * const diskon = await prisma.diskon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends diskonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, diskonFindUniqueArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diskon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {diskonFindUniqueOrThrowArgs} args - Arguments to find a Diskon
     * @example
     * // Get one Diskon
     * const diskon = await prisma.diskon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends diskonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diskon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonFindFirstArgs} args - Arguments to find a Diskon
     * @example
     * // Get one Diskon
     * const diskon = await prisma.diskon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends diskonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonFindFirstArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diskon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonFindFirstOrThrowArgs} args - Arguments to find a Diskon
     * @example
     * // Get one Diskon
     * const diskon = await prisma.diskon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends diskonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diskons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diskons
     * const diskons = await prisma.diskon.findMany()
     * 
     * // Get first 10 Diskons
     * const diskons = await prisma.diskon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diskonWithIdOnly = await prisma.diskon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends diskonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diskon.
     * @param {diskonCreateArgs} args - Arguments to create a Diskon.
     * @example
     * // Create one Diskon
     * const Diskon = await prisma.diskon.create({
     *   data: {
     *     // ... data to create a Diskon
     *   }
     * })
     * 
    **/
    create<T extends diskonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, diskonCreateArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diskons.
     *     @param {diskonCreateManyArgs} args - Arguments to create many Diskons.
     *     @example
     *     // Create many Diskons
     *     const diskon = await prisma.diskon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends diskonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diskon.
     * @param {diskonDeleteArgs} args - Arguments to delete one Diskon.
     * @example
     * // Delete one Diskon
     * const Diskon = await prisma.diskon.delete({
     *   where: {
     *     // ... filter to delete one Diskon
     *   }
     * })
     * 
    **/
    delete<T extends diskonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, diskonDeleteArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diskon.
     * @param {diskonUpdateArgs} args - Arguments to update one Diskon.
     * @example
     * // Update one Diskon
     * const diskon = await prisma.diskon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends diskonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, diskonUpdateArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diskons.
     * @param {diskonDeleteManyArgs} args - Arguments to filter Diskons to delete.
     * @example
     * // Delete a few Diskons
     * const { count } = await prisma.diskon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends diskonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, diskonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diskons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diskons
     * const diskon = await prisma.diskon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends diskonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, diskonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diskon.
     * @param {diskonUpsertArgs} args - Arguments to update or create a Diskon.
     * @example
     * // Update or create a Diskon
     * const diskon = await prisma.diskon.upsert({
     *   create: {
     *     // ... data to create a Diskon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diskon we want to update
     *   }
     * })
    **/
    upsert<T extends diskonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, diskonUpsertArgs<ExtArgs>>
    ): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diskons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonCountArgs} args - Arguments to filter Diskons to count.
     * @example
     * // Count the number of Diskons
     * const count = await prisma.diskon.count({
     *   where: {
     *     // ... the filter for the Diskons we want to count
     *   }
     * })
    **/
    count<T extends diskonCountArgs>(
      args?: Subset<T, diskonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiskonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diskon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiskonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiskonAggregateArgs>(args: Subset<T, DiskonAggregateArgs>): Prisma.PrismaPromise<GetDiskonAggregateType<T>>

    /**
     * Group by Diskon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diskonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diskonGroupByArgs['orderBy'] }
        : { orderBy?: diskonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diskonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiskonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diskon model
   */
  readonly fields: diskonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diskon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diskonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_pembelian_produk<T extends diskon$detail_pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, diskon$detail_pembelian_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_pembelian_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_diskon<T extends diskon$detail_diskonArgs<ExtArgs> = {}>(args?: Subset<T, diskon$detail_diskonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the diskon model
   */ 
  interface diskonFieldRefs {
    readonly id: FieldRef<"diskon", 'Int'>
    readonly nama_diskon: FieldRef<"diskon", 'String'>
    readonly tipe_diskon: FieldRef<"diskon", 'TipeDiskon'>
    readonly jumlah_diskon: FieldRef<"diskon", 'Float'>
    readonly tanggal_mulai: FieldRef<"diskon", 'DateTime'>
    readonly tanggal_selesai: FieldRef<"diskon", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * diskon findUnique
   */
  export type diskonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter, which diskon to fetch.
     */
    where: diskonWhereUniqueInput
  }


  /**
   * diskon findUniqueOrThrow
   */
  export type diskonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter, which diskon to fetch.
     */
    where: diskonWhereUniqueInput
  }


  /**
   * diskon findFirst
   */
  export type diskonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter, which diskon to fetch.
     */
    where?: diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskons to fetch.
     */
    orderBy?: diskonOrderByWithRelationInput | diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diskons.
     */
    cursor?: diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diskons.
     */
    distinct?: DiskonScalarFieldEnum | DiskonScalarFieldEnum[]
  }


  /**
   * diskon findFirstOrThrow
   */
  export type diskonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter, which diskon to fetch.
     */
    where?: diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskons to fetch.
     */
    orderBy?: diskonOrderByWithRelationInput | diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diskons.
     */
    cursor?: diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diskons.
     */
    distinct?: DiskonScalarFieldEnum | DiskonScalarFieldEnum[]
  }


  /**
   * diskon findMany
   */
  export type diskonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter, which diskons to fetch.
     */
    where?: diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskons to fetch.
     */
    orderBy?: diskonOrderByWithRelationInput | diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diskons.
     */
    cursor?: diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskons.
     */
    skip?: number
    distinct?: DiskonScalarFieldEnum | DiskonScalarFieldEnum[]
  }


  /**
   * diskon create
   */
  export type diskonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * The data needed to create a diskon.
     */
    data: XOR<diskonCreateInput, diskonUncheckedCreateInput>
  }


  /**
   * diskon createMany
   */
  export type diskonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diskons.
     */
    data: diskonCreateManyInput | diskonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * diskon update
   */
  export type diskonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * The data needed to update a diskon.
     */
    data: XOR<diskonUpdateInput, diskonUncheckedUpdateInput>
    /**
     * Choose, which diskon to update.
     */
    where: diskonWhereUniqueInput
  }


  /**
   * diskon updateMany
   */
  export type diskonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diskons.
     */
    data: XOR<diskonUpdateManyMutationInput, diskonUncheckedUpdateManyInput>
    /**
     * Filter which diskons to update
     */
    where?: diskonWhereInput
  }


  /**
   * diskon upsert
   */
  export type diskonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * The filter to search for the diskon to update in case it exists.
     */
    where: diskonWhereUniqueInput
    /**
     * In case the diskon found by the `where` argument doesn't exist, create a new diskon with this data.
     */
    create: XOR<diskonCreateInput, diskonUncheckedCreateInput>
    /**
     * In case the diskon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diskonUpdateInput, diskonUncheckedUpdateInput>
  }


  /**
   * diskon delete
   */
  export type diskonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
    /**
     * Filter which diskon to delete.
     */
    where: diskonWhereUniqueInput
  }


  /**
   * diskon deleteMany
   */
  export type diskonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which diskons to delete
     */
    where?: diskonWhereInput
  }


  /**
   * diskon.detail_pembelian_produk
   */
  export type diskon$detail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_pembelian_produk
     */
    select?: detail_pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_pembelian_produkInclude<ExtArgs> | null
    where?: detail_pembelian_produkWhereInput
    orderBy?: detail_pembelian_produkOrderByWithRelationInput | detail_pembelian_produkOrderByWithRelationInput[]
    cursor?: detail_pembelian_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_pembelian_produkScalarFieldEnum | Detail_pembelian_produkScalarFieldEnum[]
  }


  /**
   * diskon.detail_diskon
   */
  export type diskon$detail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    where?: detail_diskonWhereInput
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    cursor?: detail_diskonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * diskon without action
   */
  export type diskonDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskon
     */
    select?: diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diskonInclude<ExtArgs> | null
  }



  /**
   * Model detail_diskon
   */

  export type AggregateDetail_diskon = {
    _count: Detail_diskonCountAggregateOutputType | null
    _avg: Detail_diskonAvgAggregateOutputType | null
    _sum: Detail_diskonSumAggregateOutputType | null
    _min: Detail_diskonMinAggregateOutputType | null
    _max: Detail_diskonMaxAggregateOutputType | null
  }

  export type Detail_diskonAvgAggregateOutputType = {
    id: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    jumlah: number | null
    jumlah_diskon: number | null
  }

  export type Detail_diskonSumAggregateOutputType = {
    id: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    jumlah: number | null
    jumlah_diskon: number | null
  }

  export type Detail_diskonMinAggregateOutputType = {
    id: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    jumlah: number | null
    jumlah_diskon: number | null
  }

  export type Detail_diskonMaxAggregateOutputType = {
    id: number | null
    diskon_id: number | null
    produk_item_id: number | null
    pembelian_produk_id: number | null
    jumlah: number | null
    jumlah_diskon: number | null
  }

  export type Detail_diskonCountAggregateOutputType = {
    id: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
    jumlah: number
    jumlah_diskon: number
    _all: number
  }


  export type Detail_diskonAvgAggregateInputType = {
    id?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    jumlah?: true
    jumlah_diskon?: true
  }

  export type Detail_diskonSumAggregateInputType = {
    id?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    jumlah?: true
    jumlah_diskon?: true
  }

  export type Detail_diskonMinAggregateInputType = {
    id?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    jumlah?: true
    jumlah_diskon?: true
  }

  export type Detail_diskonMaxAggregateInputType = {
    id?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    jumlah?: true
    jumlah_diskon?: true
  }

  export type Detail_diskonCountAggregateInputType = {
    id?: true
    diskon_id?: true
    produk_item_id?: true
    pembelian_produk_id?: true
    jumlah?: true
    jumlah_diskon?: true
    _all?: true
  }

  export type Detail_diskonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_diskon to aggregate.
     */
    where?: detail_diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_diskons to fetch.
     */
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_diskons
    **/
    _count?: true | Detail_diskonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_diskonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_diskonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_diskonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_diskonMaxAggregateInputType
  }

  export type GetDetail_diskonAggregateType<T extends Detail_diskonAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_diskon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_diskon[P]>
      : GetScalarType<T[P], AggregateDetail_diskon[P]>
  }




  export type detail_diskonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detail_diskonWhereInput
    orderBy?: detail_diskonOrderByWithAggregationInput | detail_diskonOrderByWithAggregationInput[]
    by: Detail_diskonScalarFieldEnum[] | Detail_diskonScalarFieldEnum
    having?: detail_diskonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_diskonCountAggregateInputType | true
    _avg?: Detail_diskonAvgAggregateInputType
    _sum?: Detail_diskonSumAggregateInputType
    _min?: Detail_diskonMinAggregateInputType
    _max?: Detail_diskonMaxAggregateInputType
  }

  export type Detail_diskonGroupByOutputType = {
    id: number
    diskon_id: number
    produk_item_id: number | null
    pembelian_produk_id: number | null
    jumlah: number
    jumlah_diskon: number
    _count: Detail_diskonCountAggregateOutputType | null
    _avg: Detail_diskonAvgAggregateOutputType | null
    _sum: Detail_diskonSumAggregateOutputType | null
    _min: Detail_diskonMinAggregateOutputType | null
    _max: Detail_diskonMaxAggregateOutputType | null
  }

  type GetDetail_diskonGroupByPayload<T extends detail_diskonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_diskonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_diskonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_diskonGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_diskonGroupByOutputType[P]>
        }
      >
    >


  export type detail_diskonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diskon_id?: boolean
    produk_item_id?: boolean
    pembelian_produk_id?: boolean
    jumlah?: boolean
    jumlah_diskon?: boolean
    diskon?: boolean | diskonDefaultArgs<ExtArgs>
    produk_item?: boolean | detail_diskon$produk_itemArgs<ExtArgs>
    pembelian_produk?: boolean | detail_diskon$pembelian_produkArgs<ExtArgs>
  }, ExtArgs["result"]["detail_diskon"]>

  export type detail_diskonSelectScalar = {
    id?: boolean
    diskon_id?: boolean
    produk_item_id?: boolean
    pembelian_produk_id?: boolean
    jumlah?: boolean
    jumlah_diskon?: boolean
  }

  export type detail_diskonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    diskon?: boolean | diskonDefaultArgs<ExtArgs>
    produk_item?: boolean | detail_diskon$produk_itemArgs<ExtArgs>
    pembelian_produk?: boolean | detail_diskon$pembelian_produkArgs<ExtArgs>
  }


  export type $detail_diskonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "detail_diskon"
    objects: {
      diskon: Prisma.$diskonPayload<ExtArgs>
      produk_item: Prisma.$produk_itemPayload<ExtArgs> | null
      pembelian_produk: Prisma.$pembelian_produkPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      diskon_id: number
      produk_item_id: number | null
      pembelian_produk_id: number | null
      jumlah: number
      jumlah_diskon: number
    }, ExtArgs["result"]["detail_diskon"]>
    composites: {}
  }


  type detail_diskonGetPayload<S extends boolean | null | undefined | detail_diskonDefaultArgs> = $Result.GetResult<Prisma.$detail_diskonPayload, S>

  type detail_diskonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detail_diskonFindManyArgs, 'select' | 'include'> & {
      select?: Detail_diskonCountAggregateInputType | true
    }

  export interface detail_diskonDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_diskon'], meta: { name: 'detail_diskon' } }
    /**
     * Find zero or one Detail_diskon that matches the filter.
     * @param {detail_diskonFindUniqueArgs} args - Arguments to find a Detail_diskon
     * @example
     * // Get one Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_diskonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_diskon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_diskonFindUniqueOrThrowArgs} args - Arguments to find a Detail_diskon
     * @example
     * // Get one Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_diskonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_diskon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonFindFirstArgs} args - Arguments to find a Detail_diskon
     * @example
     * // Get one Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_diskonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonFindFirstArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_diskon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonFindFirstOrThrowArgs} args - Arguments to find a Detail_diskon
     * @example
     * // Get one Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_diskonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_diskons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_diskons
     * const detail_diskons = await prisma.detail_diskon.findMany()
     * 
     * // Get first 10 Detail_diskons
     * const detail_diskons = await prisma.detail_diskon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_diskonWithIdOnly = await prisma.detail_diskon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_diskonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_diskon.
     * @param {detail_diskonCreateArgs} args - Arguments to create a Detail_diskon.
     * @example
     * // Create one Detail_diskon
     * const Detail_diskon = await prisma.detail_diskon.create({
     *   data: {
     *     // ... data to create a Detail_diskon
     *   }
     * })
     * 
    **/
    create<T extends detail_diskonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonCreateArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_diskons.
     *     @param {detail_diskonCreateManyArgs} args - Arguments to create many Detail_diskons.
     *     @example
     *     // Create many Detail_diskons
     *     const detail_diskon = await prisma.detail_diskon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_diskonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_diskon.
     * @param {detail_diskonDeleteArgs} args - Arguments to delete one Detail_diskon.
     * @example
     * // Delete one Detail_diskon
     * const Detail_diskon = await prisma.detail_diskon.delete({
     *   where: {
     *     // ... filter to delete one Detail_diskon
     *   }
     * })
     * 
    **/
    delete<T extends detail_diskonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonDeleteArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_diskon.
     * @param {detail_diskonUpdateArgs} args - Arguments to update one Detail_diskon.
     * @example
     * // Update one Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_diskonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonUpdateArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_diskons.
     * @param {detail_diskonDeleteManyArgs} args - Arguments to filter Detail_diskons to delete.
     * @example
     * // Delete a few Detail_diskons
     * const { count } = await prisma.detail_diskon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_diskonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_diskonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_diskons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_diskons
     * const detail_diskon = await prisma.detail_diskon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_diskonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_diskon.
     * @param {detail_diskonUpsertArgs} args - Arguments to update or create a Detail_diskon.
     * @example
     * // Update or create a Detail_diskon
     * const detail_diskon = await prisma.detail_diskon.upsert({
     *   create: {
     *     // ... data to create a Detail_diskon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_diskon we want to update
     *   }
     * })
    **/
    upsert<T extends detail_diskonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_diskonUpsertArgs<ExtArgs>>
    ): Prisma__detail_diskonClient<$Result.GetResult<Prisma.$detail_diskonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_diskons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonCountArgs} args - Arguments to filter Detail_diskons to count.
     * @example
     * // Count the number of Detail_diskons
     * const count = await prisma.detail_diskon.count({
     *   where: {
     *     // ... the filter for the Detail_diskons we want to count
     *   }
     * })
    **/
    count<T extends detail_diskonCountArgs>(
      args?: Subset<T, detail_diskonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_diskonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_diskon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_diskonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_diskonAggregateArgs>(args: Subset<T, Detail_diskonAggregateArgs>): Prisma.PrismaPromise<GetDetail_diskonAggregateType<T>>

    /**
     * Group by Detail_diskon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_diskonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_diskonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_diskonGroupByArgs['orderBy'] }
        : { orderBy?: detail_diskonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_diskonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_diskonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_diskon model
   */
  readonly fields: detail_diskonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_diskon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_diskonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    diskon<T extends diskonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, diskonDefaultArgs<ExtArgs>>): Prisma__diskonClient<$Result.GetResult<Prisma.$diskonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produk_item<T extends detail_diskon$produk_itemArgs<ExtArgs> = {}>(args?: Subset<T, detail_diskon$produk_itemArgs<ExtArgs>>): Prisma__produk_itemClient<$Result.GetResult<Prisma.$produk_itemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    pembelian_produk<T extends detail_diskon$pembelian_produkArgs<ExtArgs> = {}>(args?: Subset<T, detail_diskon$pembelian_produkArgs<ExtArgs>>): Prisma__pembelian_produkClient<$Result.GetResult<Prisma.$pembelian_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_diskon model
   */ 
  interface detail_diskonFieldRefs {
    readonly id: FieldRef<"detail_diskon", 'Int'>
    readonly diskon_id: FieldRef<"detail_diskon", 'Int'>
    readonly produk_item_id: FieldRef<"detail_diskon", 'Int'>
    readonly pembelian_produk_id: FieldRef<"detail_diskon", 'Int'>
    readonly jumlah: FieldRef<"detail_diskon", 'Float'>
    readonly jumlah_diskon: FieldRef<"detail_diskon", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * detail_diskon findUnique
   */
  export type detail_diskonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter, which detail_diskon to fetch.
     */
    where: detail_diskonWhereUniqueInput
  }


  /**
   * detail_diskon findUniqueOrThrow
   */
  export type detail_diskonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter, which detail_diskon to fetch.
     */
    where: detail_diskonWhereUniqueInput
  }


  /**
   * detail_diskon findFirst
   */
  export type detail_diskonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter, which detail_diskon to fetch.
     */
    where?: detail_diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_diskons to fetch.
     */
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_diskons.
     */
    cursor?: detail_diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_diskons.
     */
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * detail_diskon findFirstOrThrow
   */
  export type detail_diskonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter, which detail_diskon to fetch.
     */
    where?: detail_diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_diskons to fetch.
     */
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_diskons.
     */
    cursor?: detail_diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_diskons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_diskons.
     */
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * detail_diskon findMany
   */
  export type detail_diskonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter, which detail_diskons to fetch.
     */
    where?: detail_diskonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_diskons to fetch.
     */
    orderBy?: detail_diskonOrderByWithRelationInput | detail_diskonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_diskons.
     */
    cursor?: detail_diskonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_diskons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_diskons.
     */
    skip?: number
    distinct?: Detail_diskonScalarFieldEnum | Detail_diskonScalarFieldEnum[]
  }


  /**
   * detail_diskon create
   */
  export type detail_diskonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_diskon.
     */
    data: XOR<detail_diskonCreateInput, detail_diskonUncheckedCreateInput>
  }


  /**
   * detail_diskon createMany
   */
  export type detail_diskonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_diskons.
     */
    data: detail_diskonCreateManyInput | detail_diskonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_diskon update
   */
  export type detail_diskonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_diskon.
     */
    data: XOR<detail_diskonUpdateInput, detail_diskonUncheckedUpdateInput>
    /**
     * Choose, which detail_diskon to update.
     */
    where: detail_diskonWhereUniqueInput
  }


  /**
   * detail_diskon updateMany
   */
  export type detail_diskonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_diskons.
     */
    data: XOR<detail_diskonUpdateManyMutationInput, detail_diskonUncheckedUpdateManyInput>
    /**
     * Filter which detail_diskons to update
     */
    where?: detail_diskonWhereInput
  }


  /**
   * detail_diskon upsert
   */
  export type detail_diskonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_diskon to update in case it exists.
     */
    where: detail_diskonWhereUniqueInput
    /**
     * In case the detail_diskon found by the `where` argument doesn't exist, create a new detail_diskon with this data.
     */
    create: XOR<detail_diskonCreateInput, detail_diskonUncheckedCreateInput>
    /**
     * In case the detail_diskon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_diskonUpdateInput, detail_diskonUncheckedUpdateInput>
  }


  /**
   * detail_diskon delete
   */
  export type detail_diskonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
    /**
     * Filter which detail_diskon to delete.
     */
    where: detail_diskonWhereUniqueInput
  }


  /**
   * detail_diskon deleteMany
   */
  export type detail_diskonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_diskons to delete
     */
    where?: detail_diskonWhereInput
  }


  /**
   * detail_diskon.produk_item
   */
  export type detail_diskon$produk_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_item
     */
    select?: produk_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produk_itemInclude<ExtArgs> | null
    where?: produk_itemWhereInput
  }


  /**
   * detail_diskon.pembelian_produk
   */
  export type detail_diskon$pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pembelian_produk
     */
    select?: pembelian_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pembelian_produkInclude<ExtArgs> | null
    where?: pembelian_produkWhereInput
  }


  /**
   * detail_diskon without action
   */
  export type detail_diskonDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_diskon
     */
    select?: detail_diskonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_diskonInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Produk_itemScalarFieldEnum: {
    id: 'id',
    kode_produk: 'kode_produk',
    sku: 'sku',
    nama_produk: 'nama_produk',
    stok: 'stok',
    harga_jual: 'harga_jual',
    produksi_id: 'produksi_id'
  };

  export type Produk_itemScalarFieldEnum = (typeof Produk_itemScalarFieldEnum)[keyof typeof Produk_itemScalarFieldEnum]


  export const ProduksiScalarFieldEnum: {
    id: 'id',
    mulai: 'mulai',
    selesai: 'selesai',
    kode_produk: 'kode_produk',
    jumlah: 'jumlah',
    ukuran: 'ukuran',
    warna: 'warna',
    biaya: 'biaya',
    pembuat_id: 'pembuat_id',
    kategori_produk_id: 'kategori_produk_id'
  };

  export type ProduksiScalarFieldEnum = (typeof ProduksiScalarFieldEnum)[keyof typeof ProduksiScalarFieldEnum]


  export const Kategori_produkScalarFieldEnum: {
    id: 'id',
    kategori: 'kategori'
  };

  export type Kategori_produkScalarFieldEnum = (typeof Kategori_produkScalarFieldEnum)[keyof typeof Kategori_produkScalarFieldEnum]


  export const PembuatScalarFieldEnum: {
    id: 'id',
    nama_pembuat: 'nama_pembuat'
  };

  export type PembuatScalarFieldEnum = (typeof PembuatScalarFieldEnum)[keyof typeof PembuatScalarFieldEnum]


  export const Bahan_produksiScalarFieldEnum: {
    id: 'id',
    stok_terpakai: 'stok_terpakai',
    produksi_id: 'produksi_id',
    stok_bahan_id: 'stok_bahan_id'
  };

  export type Bahan_produksiScalarFieldEnum = (typeof Bahan_produksiScalarFieldEnum)[keyof typeof Bahan_produksiScalarFieldEnum]


  export const Stok_bahanScalarFieldEnum: {
    id: 'id',
    kode_bahan: 'kode_bahan',
    nama_bahan: 'nama_bahan',
    ukuran: 'ukuran',
    satuan: 'satuan',
    stok: 'stok'
  };

  export type Stok_bahanScalarFieldEnum = (typeof Stok_bahanScalarFieldEnum)[keyof typeof Stok_bahanScalarFieldEnum]


  export const Detail_pengecekan_produkScalarFieldEnum: {
    id: 'id',
    pengecekan_produk_id: 'pengecekan_produk_id',
    produk_item_id: 'produk_item_id',
    kondisi_produk_id: 'kondisi_produk_id',
    jumlah: 'jumlah'
  };

  export type Detail_pengecekan_produkScalarFieldEnum = (typeof Detail_pengecekan_produkScalarFieldEnum)[keyof typeof Detail_pengecekan_produkScalarFieldEnum]


  export const Pengecekan_produkScalarFieldEnum: {
    id: 'id',
    nama_pic: 'nama_pic',
    tanggal: 'tanggal'
  };

  export type Pengecekan_produkScalarFieldEnum = (typeof Pengecekan_produkScalarFieldEnum)[keyof typeof Pengecekan_produkScalarFieldEnum]


  export const Kondisi_produkScalarFieldEnum: {
    id: 'id',
    kondisi: 'kondisi'
  };

  export type Kondisi_produkScalarFieldEnum = (typeof Kondisi_produkScalarFieldEnum)[keyof typeof Kondisi_produkScalarFieldEnum]


  export const Detail_pengecekan_bahanScalarFieldEnum: {
    id: 'id',
    pengecekan_bahan_id: 'pengecekan_bahan_id',
    stok_bahan_id: 'stok_bahan_id',
    kondisi_bahan_id: 'kondisi_bahan_id',
    jumlah: 'jumlah'
  };

  export type Detail_pengecekan_bahanScalarFieldEnum = (typeof Detail_pengecekan_bahanScalarFieldEnum)[keyof typeof Detail_pengecekan_bahanScalarFieldEnum]


  export const Pengecekan_bahanScalarFieldEnum: {
    id: 'id',
    nama_pic: 'nama_pic',
    tanggal: 'tanggal'
  };

  export type Pengecekan_bahanScalarFieldEnum = (typeof Pengecekan_bahanScalarFieldEnum)[keyof typeof Pengecekan_bahanScalarFieldEnum]


  export const Kondisi_bahanScalarFieldEnum: {
    id: 'id',
    kondisi: 'kondisi',
    pengecekan_bahan_id: 'pengecekan_bahan_id'
  };

  export type Kondisi_bahanScalarFieldEnum = (typeof Kondisi_bahanScalarFieldEnum)[keyof typeof Kondisi_bahanScalarFieldEnum]


  export const Detail_pemesanan_bahanScalarFieldEnum: {
    id: 'id',
    stok_bahan_id: 'stok_bahan_id',
    pemesanan_bahan_id: 'pemesanan_bahan_id',
    jumlah: 'jumlah',
    harga: 'harga'
  };

  export type Detail_pemesanan_bahanScalarFieldEnum = (typeof Detail_pemesanan_bahanScalarFieldEnum)[keyof typeof Detail_pemesanan_bahanScalarFieldEnum]


  export const Pemesanan_bahanScalarFieldEnum: {
    id: 'id',
    tanggal_pesan: 'tanggal_pesan',
    tanggal_terima: 'tanggal_terima',
    pic_pemesan: 'pic_pemesan',
    kontak_pic_pemesan: 'kontak_pic_pemesan',
    supplier_id: 'supplier_id'
  };

  export type Pemesanan_bahanScalarFieldEnum = (typeof Pemesanan_bahanScalarFieldEnum)[keyof typeof Pemesanan_bahanScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    nama_supplier: 'nama_supplier',
    alamat: 'alamat',
    kontak: 'kontak',
    nama_pic: 'nama_pic',
    kontak_pic: 'kontak_pic'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const Detail_gawanganScalarFieldEnum: {
    id: 'id',
    gawangan_id: 'gawangan_id',
    produk_item_id: 'produk_item_id',
    jumlah: 'jumlah'
  };

  export type Detail_gawanganScalarFieldEnum = (typeof Detail_gawanganScalarFieldEnum)[keyof typeof Detail_gawanganScalarFieldEnum]


  export const GawanganScalarFieldEnum: {
    id: 'id',
    nama_gawangan: 'nama_gawangan',
    outlet_id: 'outlet_id'
  };

  export type GawanganScalarFieldEnum = (typeof GawanganScalarFieldEnum)[keyof typeof GawanganScalarFieldEnum]


  export const OutletScalarFieldEnum: {
    id: 'id',
    nama_outlet: 'nama_outlet',
    alamat: 'alamat',
    nama_pic: 'nama_pic',
    kontak_pic: 'kontak_pic'
  };

  export type OutletScalarFieldEnum = (typeof OutletScalarFieldEnum)[keyof typeof OutletScalarFieldEnum]


  export const Pembelian_produkScalarFieldEnum: {
    id: 'id',
    tanggal_pembelian: 'tanggal_pembelian',
    nama_pembeli: 'nama_pembeli',
    kontak_pembeli: 'kontak_pembeli',
    user_id: 'user_id'
  };

  export type Pembelian_produkScalarFieldEnum = (typeof Pembelian_produkScalarFieldEnum)[keyof typeof Pembelian_produkScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    nama_lengkap: 'nama_lengkap',
    kontak: 'kontak',
    email: 'email',
    username: 'username',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Detail_pembelian_produkScalarFieldEnum: {
    id: 'id',
    jumlah: 'jumlah',
    diskon_id: 'diskon_id',
    produk_item_id: 'produk_item_id',
    pembelian_produk_id: 'pembelian_produk_id',
    gawangan_id: 'gawangan_id'
  };

  export type Detail_pembelian_produkScalarFieldEnum = (typeof Detail_pembelian_produkScalarFieldEnum)[keyof typeof Detail_pembelian_produkScalarFieldEnum]


  export const DiskonScalarFieldEnum: {
    id: 'id',
    nama_diskon: 'nama_diskon',
    tipe_diskon: 'tipe_diskon',
    jumlah_diskon: 'jumlah_diskon',
    tanggal_mulai: 'tanggal_mulai',
    tanggal_selesai: 'tanggal_selesai'
  };

  export type DiskonScalarFieldEnum = (typeof DiskonScalarFieldEnum)[keyof typeof DiskonScalarFieldEnum]


  export const Detail_diskonScalarFieldEnum: {
    id: 'id',
    diskon_id: 'diskon_id',
    produk_item_id: 'produk_item_id',
    pembelian_produk_id: 'pembelian_produk_id',
    jumlah: 'jumlah',
    jumlah_diskon: 'jumlah_diskon'
  };

  export type Detail_diskonScalarFieldEnum = (typeof Detail_diskonScalarFieldEnum)[keyof typeof Detail_diskonScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipeDiskon'
   */
  export type EnumTipeDiskonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipeDiskon'>
    


  /**
   * Reference to a field of type 'TipeDiskon[]'
   */
  export type ListEnumTipeDiskonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipeDiskon[]'>
    
  /**
   * Deep Input Types
   */


  export type produk_itemWhereInput = {
    AND?: produk_itemWhereInput | produk_itemWhereInput[]
    OR?: produk_itemWhereInput[]
    NOT?: produk_itemWhereInput | produk_itemWhereInput[]
    id?: IntFilter<"produk_item"> | number
    kode_produk?: StringFilter<"produk_item"> | string
    sku?: StringFilter<"produk_item"> | string
    nama_produk?: StringFilter<"produk_item"> | string
    stok?: IntFilter<"produk_item"> | number
    harga_jual?: FloatFilter<"produk_item"> | number
    produksi_id?: IntFilter<"produk_item"> | number
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
    detail_diskon?: Detail_diskonListRelationFilter
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
    detail_gawangan?: Detail_gawanganListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }

  export type produk_itemOrderByWithRelationInput = {
    id?: SortOrder
    kode_produk?: SortOrder
    sku?: SortOrder
    nama_produk?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
    produksi?: produksiOrderByWithRelationInput
    detail_diskon?: detail_diskonOrderByRelationAggregateInput
    detail_pengecekan_produk?: detail_pengecekan_produkOrderByRelationAggregateInput
    detail_gawangan?: detail_gawanganOrderByRelationAggregateInput
    detail_pembelian_produk?: detail_pembelian_produkOrderByRelationAggregateInput
  }

  export type produk_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produk_itemWhereInput | produk_itemWhereInput[]
    OR?: produk_itemWhereInput[]
    NOT?: produk_itemWhereInput | produk_itemWhereInput[]
    kode_produk?: StringFilter<"produk_item"> | string
    sku?: StringFilter<"produk_item"> | string
    nama_produk?: StringFilter<"produk_item"> | string
    stok?: IntFilter<"produk_item"> | number
    harga_jual?: FloatFilter<"produk_item"> | number
    produksi_id?: IntFilter<"produk_item"> | number
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
    detail_diskon?: Detail_diskonListRelationFilter
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
    detail_gawangan?: Detail_gawanganListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }, "id">

  export type produk_itemOrderByWithAggregationInput = {
    id?: SortOrder
    kode_produk?: SortOrder
    sku?: SortOrder
    nama_produk?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
    _count?: produk_itemCountOrderByAggregateInput
    _avg?: produk_itemAvgOrderByAggregateInput
    _max?: produk_itemMaxOrderByAggregateInput
    _min?: produk_itemMinOrderByAggregateInput
    _sum?: produk_itemSumOrderByAggregateInput
  }

  export type produk_itemScalarWhereWithAggregatesInput = {
    AND?: produk_itemScalarWhereWithAggregatesInput | produk_itemScalarWhereWithAggregatesInput[]
    OR?: produk_itemScalarWhereWithAggregatesInput[]
    NOT?: produk_itemScalarWhereWithAggregatesInput | produk_itemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produk_item"> | number
    kode_produk?: StringWithAggregatesFilter<"produk_item"> | string
    sku?: StringWithAggregatesFilter<"produk_item"> | string
    nama_produk?: StringWithAggregatesFilter<"produk_item"> | string
    stok?: IntWithAggregatesFilter<"produk_item"> | number
    harga_jual?: FloatWithAggregatesFilter<"produk_item"> | number
    produksi_id?: IntWithAggregatesFilter<"produk_item"> | number
  }

  export type produksiWhereInput = {
    AND?: produksiWhereInput | produksiWhereInput[]
    OR?: produksiWhereInput[]
    NOT?: produksiWhereInput | produksiWhereInput[]
    id?: IntFilter<"produksi"> | number
    mulai?: DateTimeFilter<"produksi"> | Date | string
    selesai?: DateTimeFilter<"produksi"> | Date | string
    kode_produk?: StringFilter<"produksi"> | string
    jumlah?: IntFilter<"produksi"> | number
    ukuran?: StringFilter<"produksi"> | string
    warna?: StringFilter<"produksi"> | string
    biaya?: FloatFilter<"produksi"> | number
    pembuat_id?: IntFilter<"produksi"> | number
    kategori_produk_id?: IntFilter<"produksi"> | number
    pembuat?: XOR<PembuatRelationFilter, pembuatWhereInput>
    kategori_produk?: XOR<Kategori_produkRelationFilter, kategori_produkWhereInput>
    produk_item?: Produk_itemListRelationFilter
    bahan_produksi?: Bahan_produksiListRelationFilter
  }

  export type produksiOrderByWithRelationInput = {
    id?: SortOrder
    mulai?: SortOrder
    selesai?: SortOrder
    kode_produk?: SortOrder
    jumlah?: SortOrder
    ukuran?: SortOrder
    warna?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
    pembuat?: pembuatOrderByWithRelationInput
    kategori_produk?: kategori_produkOrderByWithRelationInput
    produk_item?: produk_itemOrderByRelationAggregateInput
    bahan_produksi?: bahan_produksiOrderByRelationAggregateInput
  }

  export type produksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produksiWhereInput | produksiWhereInput[]
    OR?: produksiWhereInput[]
    NOT?: produksiWhereInput | produksiWhereInput[]
    mulai?: DateTimeFilter<"produksi"> | Date | string
    selesai?: DateTimeFilter<"produksi"> | Date | string
    kode_produk?: StringFilter<"produksi"> | string
    jumlah?: IntFilter<"produksi"> | number
    ukuran?: StringFilter<"produksi"> | string
    warna?: StringFilter<"produksi"> | string
    biaya?: FloatFilter<"produksi"> | number
    pembuat_id?: IntFilter<"produksi"> | number
    kategori_produk_id?: IntFilter<"produksi"> | number
    pembuat?: XOR<PembuatRelationFilter, pembuatWhereInput>
    kategori_produk?: XOR<Kategori_produkRelationFilter, kategori_produkWhereInput>
    produk_item?: Produk_itemListRelationFilter
    bahan_produksi?: Bahan_produksiListRelationFilter
  }, "id">

  export type produksiOrderByWithAggregationInput = {
    id?: SortOrder
    mulai?: SortOrder
    selesai?: SortOrder
    kode_produk?: SortOrder
    jumlah?: SortOrder
    ukuran?: SortOrder
    warna?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
    _count?: produksiCountOrderByAggregateInput
    _avg?: produksiAvgOrderByAggregateInput
    _max?: produksiMaxOrderByAggregateInput
    _min?: produksiMinOrderByAggregateInput
    _sum?: produksiSumOrderByAggregateInput
  }

  export type produksiScalarWhereWithAggregatesInput = {
    AND?: produksiScalarWhereWithAggregatesInput | produksiScalarWhereWithAggregatesInput[]
    OR?: produksiScalarWhereWithAggregatesInput[]
    NOT?: produksiScalarWhereWithAggregatesInput | produksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produksi"> | number
    mulai?: DateTimeWithAggregatesFilter<"produksi"> | Date | string
    selesai?: DateTimeWithAggregatesFilter<"produksi"> | Date | string
    kode_produk?: StringWithAggregatesFilter<"produksi"> | string
    jumlah?: IntWithAggregatesFilter<"produksi"> | number
    ukuran?: StringWithAggregatesFilter<"produksi"> | string
    warna?: StringWithAggregatesFilter<"produksi"> | string
    biaya?: FloatWithAggregatesFilter<"produksi"> | number
    pembuat_id?: IntWithAggregatesFilter<"produksi"> | number
    kategori_produk_id?: IntWithAggregatesFilter<"produksi"> | number
  }

  export type kategori_produkWhereInput = {
    AND?: kategori_produkWhereInput | kategori_produkWhereInput[]
    OR?: kategori_produkWhereInput[]
    NOT?: kategori_produkWhereInput | kategori_produkWhereInput[]
    id?: IntFilter<"kategori_produk"> | number
    kategori?: StringFilter<"kategori_produk"> | string
    produksi?: ProduksiListRelationFilter
  }

  export type kategori_produkOrderByWithRelationInput = {
    id?: SortOrder
    kategori?: SortOrder
    produksi?: produksiOrderByRelationAggregateInput
  }

  export type kategori_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kategori_produkWhereInput | kategori_produkWhereInput[]
    OR?: kategori_produkWhereInput[]
    NOT?: kategori_produkWhereInput | kategori_produkWhereInput[]
    kategori?: StringFilter<"kategori_produk"> | string
    produksi?: ProduksiListRelationFilter
  }, "id">

  export type kategori_produkOrderByWithAggregationInput = {
    id?: SortOrder
    kategori?: SortOrder
    _count?: kategori_produkCountOrderByAggregateInput
    _avg?: kategori_produkAvgOrderByAggregateInput
    _max?: kategori_produkMaxOrderByAggregateInput
    _min?: kategori_produkMinOrderByAggregateInput
    _sum?: kategori_produkSumOrderByAggregateInput
  }

  export type kategori_produkScalarWhereWithAggregatesInput = {
    AND?: kategori_produkScalarWhereWithAggregatesInput | kategori_produkScalarWhereWithAggregatesInput[]
    OR?: kategori_produkScalarWhereWithAggregatesInput[]
    NOT?: kategori_produkScalarWhereWithAggregatesInput | kategori_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kategori_produk"> | number
    kategori?: StringWithAggregatesFilter<"kategori_produk"> | string
  }

  export type pembuatWhereInput = {
    AND?: pembuatWhereInput | pembuatWhereInput[]
    OR?: pembuatWhereInput[]
    NOT?: pembuatWhereInput | pembuatWhereInput[]
    id?: IntFilter<"pembuat"> | number
    nama_pembuat?: StringFilter<"pembuat"> | string
    produksi?: ProduksiListRelationFilter
  }

  export type pembuatOrderByWithRelationInput = {
    id?: SortOrder
    nama_pembuat?: SortOrder
    produksi?: produksiOrderByRelationAggregateInput
  }

  export type pembuatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pembuatWhereInput | pembuatWhereInput[]
    OR?: pembuatWhereInput[]
    NOT?: pembuatWhereInput | pembuatWhereInput[]
    nama_pembuat?: StringFilter<"pembuat"> | string
    produksi?: ProduksiListRelationFilter
  }, "id">

  export type pembuatOrderByWithAggregationInput = {
    id?: SortOrder
    nama_pembuat?: SortOrder
    _count?: pembuatCountOrderByAggregateInput
    _avg?: pembuatAvgOrderByAggregateInput
    _max?: pembuatMaxOrderByAggregateInput
    _min?: pembuatMinOrderByAggregateInput
    _sum?: pembuatSumOrderByAggregateInput
  }

  export type pembuatScalarWhereWithAggregatesInput = {
    AND?: pembuatScalarWhereWithAggregatesInput | pembuatScalarWhereWithAggregatesInput[]
    OR?: pembuatScalarWhereWithAggregatesInput[]
    NOT?: pembuatScalarWhereWithAggregatesInput | pembuatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pembuat"> | number
    nama_pembuat?: StringWithAggregatesFilter<"pembuat"> | string
  }

  export type bahan_produksiWhereInput = {
    AND?: bahan_produksiWhereInput | bahan_produksiWhereInput[]
    OR?: bahan_produksiWhereInput[]
    NOT?: bahan_produksiWhereInput | bahan_produksiWhereInput[]
    id?: IntFilter<"bahan_produksi"> | number
    stok_terpakai?: FloatFilter<"bahan_produksi"> | number
    produksi_id?: IntFilter<"bahan_produksi"> | number
    stok_bahan_id?: IntFilter<"bahan_produksi"> | number
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
  }

  export type bahan_produksiOrderByWithRelationInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
    produksi?: produksiOrderByWithRelationInput
    stok_bahan?: stok_bahanOrderByWithRelationInput
  }

  export type bahan_produksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bahan_produksiWhereInput | bahan_produksiWhereInput[]
    OR?: bahan_produksiWhereInput[]
    NOT?: bahan_produksiWhereInput | bahan_produksiWhereInput[]
    stok_terpakai?: FloatFilter<"bahan_produksi"> | number
    produksi_id?: IntFilter<"bahan_produksi"> | number
    stok_bahan_id?: IntFilter<"bahan_produksi"> | number
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
  }, "id">

  export type bahan_produksiOrderByWithAggregationInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
    _count?: bahan_produksiCountOrderByAggregateInput
    _avg?: bahan_produksiAvgOrderByAggregateInput
    _max?: bahan_produksiMaxOrderByAggregateInput
    _min?: bahan_produksiMinOrderByAggregateInput
    _sum?: bahan_produksiSumOrderByAggregateInput
  }

  export type bahan_produksiScalarWhereWithAggregatesInput = {
    AND?: bahan_produksiScalarWhereWithAggregatesInput | bahan_produksiScalarWhereWithAggregatesInput[]
    OR?: bahan_produksiScalarWhereWithAggregatesInput[]
    NOT?: bahan_produksiScalarWhereWithAggregatesInput | bahan_produksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bahan_produksi"> | number
    stok_terpakai?: FloatWithAggregatesFilter<"bahan_produksi"> | number
    produksi_id?: IntWithAggregatesFilter<"bahan_produksi"> | number
    stok_bahan_id?: IntWithAggregatesFilter<"bahan_produksi"> | number
  }

  export type stok_bahanWhereInput = {
    AND?: stok_bahanWhereInput | stok_bahanWhereInput[]
    OR?: stok_bahanWhereInput[]
    NOT?: stok_bahanWhereInput | stok_bahanWhereInput[]
    id?: IntFilter<"stok_bahan"> | number
    kode_bahan?: StringFilter<"stok_bahan"> | string
    nama_bahan?: StringFilter<"stok_bahan"> | string
    ukuran?: FloatFilter<"stok_bahan"> | number
    satuan?: StringFilter<"stok_bahan"> | string
    stok?: IntFilter<"stok_bahan"> | number
    bahan_produksi?: Bahan_produksiListRelationFilter
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
    detail_pemesanan_bahan?: Detail_pemesanan_bahanListRelationFilter
  }

  export type stok_bahanOrderByWithRelationInput = {
    id?: SortOrder
    kode_bahan?: SortOrder
    nama_bahan?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    stok?: SortOrder
    bahan_produksi?: bahan_produksiOrderByRelationAggregateInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanOrderByRelationAggregateInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanOrderByRelationAggregateInput
  }

  export type stok_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: stok_bahanWhereInput | stok_bahanWhereInput[]
    OR?: stok_bahanWhereInput[]
    NOT?: stok_bahanWhereInput | stok_bahanWhereInput[]
    kode_bahan?: StringFilter<"stok_bahan"> | string
    nama_bahan?: StringFilter<"stok_bahan"> | string
    ukuran?: FloatFilter<"stok_bahan"> | number
    satuan?: StringFilter<"stok_bahan"> | string
    stok?: IntFilter<"stok_bahan"> | number
    bahan_produksi?: Bahan_produksiListRelationFilter
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
    detail_pemesanan_bahan?: Detail_pemesanan_bahanListRelationFilter
  }, "id">

  export type stok_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    kode_bahan?: SortOrder
    nama_bahan?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    stok?: SortOrder
    _count?: stok_bahanCountOrderByAggregateInput
    _avg?: stok_bahanAvgOrderByAggregateInput
    _max?: stok_bahanMaxOrderByAggregateInput
    _min?: stok_bahanMinOrderByAggregateInput
    _sum?: stok_bahanSumOrderByAggregateInput
  }

  export type stok_bahanScalarWhereWithAggregatesInput = {
    AND?: stok_bahanScalarWhereWithAggregatesInput | stok_bahanScalarWhereWithAggregatesInput[]
    OR?: stok_bahanScalarWhereWithAggregatesInput[]
    NOT?: stok_bahanScalarWhereWithAggregatesInput | stok_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"stok_bahan"> | number
    kode_bahan?: StringWithAggregatesFilter<"stok_bahan"> | string
    nama_bahan?: StringWithAggregatesFilter<"stok_bahan"> | string
    ukuran?: FloatWithAggregatesFilter<"stok_bahan"> | number
    satuan?: StringWithAggregatesFilter<"stok_bahan"> | string
    stok?: IntWithAggregatesFilter<"stok_bahan"> | number
  }

  export type detail_pengecekan_produkWhereInput = {
    AND?: detail_pengecekan_produkWhereInput | detail_pengecekan_produkWhereInput[]
    OR?: detail_pengecekan_produkWhereInput[]
    NOT?: detail_pengecekan_produkWhereInput | detail_pengecekan_produkWhereInput[]
    id?: IntFilter<"detail_pengecekan_produk"> | number
    pengecekan_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    produk_item_id?: IntFilter<"detail_pengecekan_produk"> | number
    kondisi_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    jumlah?: FloatFilter<"detail_pengecekan_produk"> | number
    pengecekan_produk?: XOR<Pengecekan_produkRelationFilter, pengecekan_produkWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
    kondisi_produk?: XOR<Kondisi_produkRelationFilter, kondisi_produkWhereInput>
  }

  export type detail_pengecekan_produkOrderByWithRelationInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
    pengecekan_produk?: pengecekan_produkOrderByWithRelationInput
    produk_item?: produk_itemOrderByWithRelationInput
    kondisi_produk?: kondisi_produkOrderByWithRelationInput
  }

  export type detail_pengecekan_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_pengecekan_produkWhereInput | detail_pengecekan_produkWhereInput[]
    OR?: detail_pengecekan_produkWhereInput[]
    NOT?: detail_pengecekan_produkWhereInput | detail_pengecekan_produkWhereInput[]
    pengecekan_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    produk_item_id?: IntFilter<"detail_pengecekan_produk"> | number
    kondisi_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    jumlah?: FloatFilter<"detail_pengecekan_produk"> | number
    pengecekan_produk?: XOR<Pengecekan_produkRelationFilter, pengecekan_produkWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
    kondisi_produk?: XOR<Kondisi_produkRelationFilter, kondisi_produkWhereInput>
  }, "id">

  export type detail_pengecekan_produkOrderByWithAggregationInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
    _count?: detail_pengecekan_produkCountOrderByAggregateInput
    _avg?: detail_pengecekan_produkAvgOrderByAggregateInput
    _max?: detail_pengecekan_produkMaxOrderByAggregateInput
    _min?: detail_pengecekan_produkMinOrderByAggregateInput
    _sum?: detail_pengecekan_produkSumOrderByAggregateInput
  }

  export type detail_pengecekan_produkScalarWhereWithAggregatesInput = {
    AND?: detail_pengecekan_produkScalarWhereWithAggregatesInput | detail_pengecekan_produkScalarWhereWithAggregatesInput[]
    OR?: detail_pengecekan_produkScalarWhereWithAggregatesInput[]
    NOT?: detail_pengecekan_produkScalarWhereWithAggregatesInput | detail_pengecekan_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_pengecekan_produk"> | number
    pengecekan_produk_id?: IntWithAggregatesFilter<"detail_pengecekan_produk"> | number
    produk_item_id?: IntWithAggregatesFilter<"detail_pengecekan_produk"> | number
    kondisi_produk_id?: IntWithAggregatesFilter<"detail_pengecekan_produk"> | number
    jumlah?: FloatWithAggregatesFilter<"detail_pengecekan_produk"> | number
  }

  export type pengecekan_produkWhereInput = {
    AND?: pengecekan_produkWhereInput | pengecekan_produkWhereInput[]
    OR?: pengecekan_produkWhereInput[]
    NOT?: pengecekan_produkWhereInput | pengecekan_produkWhereInput[]
    id?: IntFilter<"pengecekan_produk"> | number
    nama_pic?: StringFilter<"pengecekan_produk"> | string
    tanggal?: DateTimeFilter<"pengecekan_produk"> | Date | string
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
  }

  export type pengecekan_produkOrderByWithRelationInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
    detail_pengecekan_produk?: detail_pengecekan_produkOrderByRelationAggregateInput
  }

  export type pengecekan_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pengecekan_produkWhereInput | pengecekan_produkWhereInput[]
    OR?: pengecekan_produkWhereInput[]
    NOT?: pengecekan_produkWhereInput | pengecekan_produkWhereInput[]
    nama_pic?: StringFilter<"pengecekan_produk"> | string
    tanggal?: DateTimeFilter<"pengecekan_produk"> | Date | string
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
  }, "id">

  export type pengecekan_produkOrderByWithAggregationInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
    _count?: pengecekan_produkCountOrderByAggregateInput
    _avg?: pengecekan_produkAvgOrderByAggregateInput
    _max?: pengecekan_produkMaxOrderByAggregateInput
    _min?: pengecekan_produkMinOrderByAggregateInput
    _sum?: pengecekan_produkSumOrderByAggregateInput
  }

  export type pengecekan_produkScalarWhereWithAggregatesInput = {
    AND?: pengecekan_produkScalarWhereWithAggregatesInput | pengecekan_produkScalarWhereWithAggregatesInput[]
    OR?: pengecekan_produkScalarWhereWithAggregatesInput[]
    NOT?: pengecekan_produkScalarWhereWithAggregatesInput | pengecekan_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pengecekan_produk"> | number
    nama_pic?: StringWithAggregatesFilter<"pengecekan_produk"> | string
    tanggal?: DateTimeWithAggregatesFilter<"pengecekan_produk"> | Date | string
  }

  export type kondisi_produkWhereInput = {
    AND?: kondisi_produkWhereInput | kondisi_produkWhereInput[]
    OR?: kondisi_produkWhereInput[]
    NOT?: kondisi_produkWhereInput | kondisi_produkWhereInput[]
    id?: IntFilter<"kondisi_produk"> | number
    kondisi?: StringFilter<"kondisi_produk"> | string
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
  }

  export type kondisi_produkOrderByWithRelationInput = {
    id?: SortOrder
    kondisi?: SortOrder
    detail_pengecekan_produk?: detail_pengecekan_produkOrderByRelationAggregateInput
  }

  export type kondisi_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kondisi_produkWhereInput | kondisi_produkWhereInput[]
    OR?: kondisi_produkWhereInput[]
    NOT?: kondisi_produkWhereInput | kondisi_produkWhereInput[]
    kondisi?: StringFilter<"kondisi_produk"> | string
    detail_pengecekan_produk?: Detail_pengecekan_produkListRelationFilter
  }, "id">

  export type kondisi_produkOrderByWithAggregationInput = {
    id?: SortOrder
    kondisi?: SortOrder
    _count?: kondisi_produkCountOrderByAggregateInput
    _avg?: kondisi_produkAvgOrderByAggregateInput
    _max?: kondisi_produkMaxOrderByAggregateInput
    _min?: kondisi_produkMinOrderByAggregateInput
    _sum?: kondisi_produkSumOrderByAggregateInput
  }

  export type kondisi_produkScalarWhereWithAggregatesInput = {
    AND?: kondisi_produkScalarWhereWithAggregatesInput | kondisi_produkScalarWhereWithAggregatesInput[]
    OR?: kondisi_produkScalarWhereWithAggregatesInput[]
    NOT?: kondisi_produkScalarWhereWithAggregatesInput | kondisi_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kondisi_produk"> | number
    kondisi?: StringWithAggregatesFilter<"kondisi_produk"> | string
  }

  export type detail_pengecekan_bahanWhereInput = {
    AND?: detail_pengecekan_bahanWhereInput | detail_pengecekan_bahanWhereInput[]
    OR?: detail_pengecekan_bahanWhereInput[]
    NOT?: detail_pengecekan_bahanWhereInput | detail_pengecekan_bahanWhereInput[]
    id?: IntFilter<"detail_pengecekan_bahan"> | number
    pengecekan_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    stok_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    kondisi_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    jumlah?: FloatFilter<"detail_pengecekan_bahan"> | number
    pengecekan_bahan?: XOR<Pengecekan_bahanRelationFilter, pengecekan_bahanWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
    kondisi_bahan?: XOR<Kondisi_bahanRelationFilter, kondisi_bahanWhereInput>
  }

  export type detail_pengecekan_bahanOrderByWithRelationInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
    pengecekan_bahan?: pengecekan_bahanOrderByWithRelationInput
    stok_bahan?: stok_bahanOrderByWithRelationInput
    kondisi_bahan?: kondisi_bahanOrderByWithRelationInput
  }

  export type detail_pengecekan_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_pengecekan_bahanWhereInput | detail_pengecekan_bahanWhereInput[]
    OR?: detail_pengecekan_bahanWhereInput[]
    NOT?: detail_pengecekan_bahanWhereInput | detail_pengecekan_bahanWhereInput[]
    pengecekan_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    stok_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    kondisi_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    jumlah?: FloatFilter<"detail_pengecekan_bahan"> | number
    pengecekan_bahan?: XOR<Pengecekan_bahanRelationFilter, pengecekan_bahanWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
    kondisi_bahan?: XOR<Kondisi_bahanRelationFilter, kondisi_bahanWhereInput>
  }, "id">

  export type detail_pengecekan_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
    _count?: detail_pengecekan_bahanCountOrderByAggregateInput
    _avg?: detail_pengecekan_bahanAvgOrderByAggregateInput
    _max?: detail_pengecekan_bahanMaxOrderByAggregateInput
    _min?: detail_pengecekan_bahanMinOrderByAggregateInput
    _sum?: detail_pengecekan_bahanSumOrderByAggregateInput
  }

  export type detail_pengecekan_bahanScalarWhereWithAggregatesInput = {
    AND?: detail_pengecekan_bahanScalarWhereWithAggregatesInput | detail_pengecekan_bahanScalarWhereWithAggregatesInput[]
    OR?: detail_pengecekan_bahanScalarWhereWithAggregatesInput[]
    NOT?: detail_pengecekan_bahanScalarWhereWithAggregatesInput | detail_pengecekan_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_pengecekan_bahan"> | number
    pengecekan_bahan_id?: IntWithAggregatesFilter<"detail_pengecekan_bahan"> | number
    stok_bahan_id?: IntWithAggregatesFilter<"detail_pengecekan_bahan"> | number
    kondisi_bahan_id?: IntWithAggregatesFilter<"detail_pengecekan_bahan"> | number
    jumlah?: FloatWithAggregatesFilter<"detail_pengecekan_bahan"> | number
  }

  export type pengecekan_bahanWhereInput = {
    AND?: pengecekan_bahanWhereInput | pengecekan_bahanWhereInput[]
    OR?: pengecekan_bahanWhereInput[]
    NOT?: pengecekan_bahanWhereInput | pengecekan_bahanWhereInput[]
    id?: IntFilter<"pengecekan_bahan"> | number
    nama_pic?: StringFilter<"pengecekan_bahan"> | string
    tanggal?: DateTimeFilter<"pengecekan_bahan"> | Date | string
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
  }

  export type pengecekan_bahanOrderByWithRelationInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
    detail_pengecekan_bahan?: detail_pengecekan_bahanOrderByRelationAggregateInput
  }

  export type pengecekan_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pengecekan_bahanWhereInput | pengecekan_bahanWhereInput[]
    OR?: pengecekan_bahanWhereInput[]
    NOT?: pengecekan_bahanWhereInput | pengecekan_bahanWhereInput[]
    nama_pic?: StringFilter<"pengecekan_bahan"> | string
    tanggal?: DateTimeFilter<"pengecekan_bahan"> | Date | string
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
  }, "id">

  export type pengecekan_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
    _count?: pengecekan_bahanCountOrderByAggregateInput
    _avg?: pengecekan_bahanAvgOrderByAggregateInput
    _max?: pengecekan_bahanMaxOrderByAggregateInput
    _min?: pengecekan_bahanMinOrderByAggregateInput
    _sum?: pengecekan_bahanSumOrderByAggregateInput
  }

  export type pengecekan_bahanScalarWhereWithAggregatesInput = {
    AND?: pengecekan_bahanScalarWhereWithAggregatesInput | pengecekan_bahanScalarWhereWithAggregatesInput[]
    OR?: pengecekan_bahanScalarWhereWithAggregatesInput[]
    NOT?: pengecekan_bahanScalarWhereWithAggregatesInput | pengecekan_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pengecekan_bahan"> | number
    nama_pic?: StringWithAggregatesFilter<"pengecekan_bahan"> | string
    tanggal?: DateTimeWithAggregatesFilter<"pengecekan_bahan"> | Date | string
  }

  export type kondisi_bahanWhereInput = {
    AND?: kondisi_bahanWhereInput | kondisi_bahanWhereInput[]
    OR?: kondisi_bahanWhereInput[]
    NOT?: kondisi_bahanWhereInput | kondisi_bahanWhereInput[]
    id?: IntFilter<"kondisi_bahan"> | number
    kondisi?: StringFilter<"kondisi_bahan"> | string
    pengecekan_bahan_id?: IntFilter<"kondisi_bahan"> | number
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
  }

  export type kondisi_bahanOrderByWithRelationInput = {
    id?: SortOrder
    kondisi?: SortOrder
    pengecekan_bahan_id?: SortOrder
    detail_pengecekan_bahan?: detail_pengecekan_bahanOrderByRelationAggregateInput
  }

  export type kondisi_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kondisi_bahanWhereInput | kondisi_bahanWhereInput[]
    OR?: kondisi_bahanWhereInput[]
    NOT?: kondisi_bahanWhereInput | kondisi_bahanWhereInput[]
    kondisi?: StringFilter<"kondisi_bahan"> | string
    pengecekan_bahan_id?: IntFilter<"kondisi_bahan"> | number
    detail_pengecekan_bahan?: Detail_pengecekan_bahanListRelationFilter
  }, "id">

  export type kondisi_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    kondisi?: SortOrder
    pengecekan_bahan_id?: SortOrder
    _count?: kondisi_bahanCountOrderByAggregateInput
    _avg?: kondisi_bahanAvgOrderByAggregateInput
    _max?: kondisi_bahanMaxOrderByAggregateInput
    _min?: kondisi_bahanMinOrderByAggregateInput
    _sum?: kondisi_bahanSumOrderByAggregateInput
  }

  export type kondisi_bahanScalarWhereWithAggregatesInput = {
    AND?: kondisi_bahanScalarWhereWithAggregatesInput | kondisi_bahanScalarWhereWithAggregatesInput[]
    OR?: kondisi_bahanScalarWhereWithAggregatesInput[]
    NOT?: kondisi_bahanScalarWhereWithAggregatesInput | kondisi_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kondisi_bahan"> | number
    kondisi?: StringWithAggregatesFilter<"kondisi_bahan"> | string
    pengecekan_bahan_id?: IntWithAggregatesFilter<"kondisi_bahan"> | number
  }

  export type detail_pemesanan_bahanWhereInput = {
    AND?: detail_pemesanan_bahanWhereInput | detail_pemesanan_bahanWhereInput[]
    OR?: detail_pemesanan_bahanWhereInput[]
    NOT?: detail_pemesanan_bahanWhereInput | detail_pemesanan_bahanWhereInput[]
    id?: IntFilter<"detail_pemesanan_bahan"> | number
    stok_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    jumlah?: FloatFilter<"detail_pemesanan_bahan"> | number
    harga?: FloatFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan?: XOR<Pemesanan_bahanRelationFilter, pemesanan_bahanWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
  }

  export type detail_pemesanan_bahanOrderByWithRelationInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
    pemesanan_bahan?: pemesanan_bahanOrderByWithRelationInput
    stok_bahan?: stok_bahanOrderByWithRelationInput
  }

  export type detail_pemesanan_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_pemesanan_bahanWhereInput | detail_pemesanan_bahanWhereInput[]
    OR?: detail_pemesanan_bahanWhereInput[]
    NOT?: detail_pemesanan_bahanWhereInput | detail_pemesanan_bahanWhereInput[]
    stok_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    jumlah?: FloatFilter<"detail_pemesanan_bahan"> | number
    harga?: FloatFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan?: XOR<Pemesanan_bahanRelationFilter, pemesanan_bahanWhereInput>
    stok_bahan?: XOR<Stok_bahanRelationFilter, stok_bahanWhereInput>
  }, "id">

  export type detail_pemesanan_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
    _count?: detail_pemesanan_bahanCountOrderByAggregateInput
    _avg?: detail_pemesanan_bahanAvgOrderByAggregateInput
    _max?: detail_pemesanan_bahanMaxOrderByAggregateInput
    _min?: detail_pemesanan_bahanMinOrderByAggregateInput
    _sum?: detail_pemesanan_bahanSumOrderByAggregateInput
  }

  export type detail_pemesanan_bahanScalarWhereWithAggregatesInput = {
    AND?: detail_pemesanan_bahanScalarWhereWithAggregatesInput | detail_pemesanan_bahanScalarWhereWithAggregatesInput[]
    OR?: detail_pemesanan_bahanScalarWhereWithAggregatesInput[]
    NOT?: detail_pemesanan_bahanScalarWhereWithAggregatesInput | detail_pemesanan_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_pemesanan_bahan"> | number
    stok_bahan_id?: IntWithAggregatesFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan_id?: IntWithAggregatesFilter<"detail_pemesanan_bahan"> | number
    jumlah?: FloatWithAggregatesFilter<"detail_pemesanan_bahan"> | number
    harga?: FloatWithAggregatesFilter<"detail_pemesanan_bahan"> | number
  }

  export type pemesanan_bahanWhereInput = {
    AND?: pemesanan_bahanWhereInput | pemesanan_bahanWhereInput[]
    OR?: pemesanan_bahanWhereInput[]
    NOT?: pemesanan_bahanWhereInput | pemesanan_bahanWhereInput[]
    id?: IntFilter<"pemesanan_bahan"> | number
    tanggal_pesan?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    kontak_pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    supplier_id?: IntFilter<"pemesanan_bahan"> | number
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
    detail_pemesanan_bahan?: Detail_pemesanan_bahanListRelationFilter
  }

  export type pemesanan_bahanOrderByWithRelationInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    pic_pemesan?: SortOrder
    kontak_pic_pemesan?: SortOrder
    supplier_id?: SortOrder
    supplier?: supplierOrderByWithRelationInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanOrderByRelationAggregateInput
  }

  export type pemesanan_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pemesanan_bahanWhereInput | pemesanan_bahanWhereInput[]
    OR?: pemesanan_bahanWhereInput[]
    NOT?: pemesanan_bahanWhereInput | pemesanan_bahanWhereInput[]
    tanggal_pesan?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    kontak_pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    supplier_id?: IntFilter<"pemesanan_bahan"> | number
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
    detail_pemesanan_bahan?: Detail_pemesanan_bahanListRelationFilter
  }, "id">

  export type pemesanan_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    pic_pemesan?: SortOrder
    kontak_pic_pemesan?: SortOrder
    supplier_id?: SortOrder
    _count?: pemesanan_bahanCountOrderByAggregateInput
    _avg?: pemesanan_bahanAvgOrderByAggregateInput
    _max?: pemesanan_bahanMaxOrderByAggregateInput
    _min?: pemesanan_bahanMinOrderByAggregateInput
    _sum?: pemesanan_bahanSumOrderByAggregateInput
  }

  export type pemesanan_bahanScalarWhereWithAggregatesInput = {
    AND?: pemesanan_bahanScalarWhereWithAggregatesInput | pemesanan_bahanScalarWhereWithAggregatesInput[]
    OR?: pemesanan_bahanScalarWhereWithAggregatesInput[]
    NOT?: pemesanan_bahanScalarWhereWithAggregatesInput | pemesanan_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pemesanan_bahan"> | number
    tanggal_pesan?: DateTimeWithAggregatesFilter<"pemesanan_bahan"> | Date | string
    tanggal_terima?: DateTimeWithAggregatesFilter<"pemesanan_bahan"> | Date | string
    pic_pemesan?: StringWithAggregatesFilter<"pemesanan_bahan"> | string
    kontak_pic_pemesan?: StringWithAggregatesFilter<"pemesanan_bahan"> | string
    supplier_id?: IntWithAggregatesFilter<"pemesanan_bahan"> | number
  }

  export type supplierWhereInput = {
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    id?: IntFilter<"supplier"> | number
    nama_supplier?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    nama_pic?: StringFilter<"supplier"> | string
    kontak_pic?: StringFilter<"supplier"> | string
    pemesanan_bahan?: Pemesanan_bahanListRelationFilter
  }

  export type supplierOrderByWithRelationInput = {
    id?: SortOrder
    nama_supplier?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
    pemesanan_bahan?: pemesanan_bahanOrderByRelationAggregateInput
  }

  export type supplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    nama_supplier?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    nama_pic?: StringFilter<"supplier"> | string
    kontak_pic?: StringFilter<"supplier"> | string
    pemesanan_bahan?: Pemesanan_bahanListRelationFilter
  }, "id">

  export type supplierOrderByWithAggregationInput = {
    id?: SortOrder
    nama_supplier?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    OR?: supplierScalarWhereWithAggregatesInput[]
    NOT?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplier"> | number
    nama_supplier?: StringWithAggregatesFilter<"supplier"> | string
    alamat?: StringWithAggregatesFilter<"supplier"> | string
    kontak?: StringWithAggregatesFilter<"supplier"> | string
    nama_pic?: StringWithAggregatesFilter<"supplier"> | string
    kontak_pic?: StringWithAggregatesFilter<"supplier"> | string
  }

  export type detail_gawanganWhereInput = {
    AND?: detail_gawanganWhereInput | detail_gawanganWhereInput[]
    OR?: detail_gawanganWhereInput[]
    NOT?: detail_gawanganWhereInput | detail_gawanganWhereInput[]
    id?: IntFilter<"detail_gawangan"> | number
    gawangan_id?: IntFilter<"detail_gawangan"> | number
    produk_item_id?: IntFilter<"detail_gawangan"> | number
    jumlah?: IntFilter<"detail_gawangan"> | number
    gawangan?: XOR<GawanganRelationFilter, gawanganWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
  }

  export type detail_gawanganOrderByWithRelationInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
    gawangan?: gawanganOrderByWithRelationInput
    produk_item?: produk_itemOrderByWithRelationInput
  }

  export type detail_gawanganWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_gawanganWhereInput | detail_gawanganWhereInput[]
    OR?: detail_gawanganWhereInput[]
    NOT?: detail_gawanganWhereInput | detail_gawanganWhereInput[]
    gawangan_id?: IntFilter<"detail_gawangan"> | number
    produk_item_id?: IntFilter<"detail_gawangan"> | number
    jumlah?: IntFilter<"detail_gawangan"> | number
    gawangan?: XOR<GawanganRelationFilter, gawanganWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
  }, "id">

  export type detail_gawanganOrderByWithAggregationInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
    _count?: detail_gawanganCountOrderByAggregateInput
    _avg?: detail_gawanganAvgOrderByAggregateInput
    _max?: detail_gawanganMaxOrderByAggregateInput
    _min?: detail_gawanganMinOrderByAggregateInput
    _sum?: detail_gawanganSumOrderByAggregateInput
  }

  export type detail_gawanganScalarWhereWithAggregatesInput = {
    AND?: detail_gawanganScalarWhereWithAggregatesInput | detail_gawanganScalarWhereWithAggregatesInput[]
    OR?: detail_gawanganScalarWhereWithAggregatesInput[]
    NOT?: detail_gawanganScalarWhereWithAggregatesInput | detail_gawanganScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_gawangan"> | number
    gawangan_id?: IntWithAggregatesFilter<"detail_gawangan"> | number
    produk_item_id?: IntWithAggregatesFilter<"detail_gawangan"> | number
    jumlah?: IntWithAggregatesFilter<"detail_gawangan"> | number
  }

  export type gawanganWhereInput = {
    AND?: gawanganWhereInput | gawanganWhereInput[]
    OR?: gawanganWhereInput[]
    NOT?: gawanganWhereInput | gawanganWhereInput[]
    id?: IntFilter<"gawangan"> | number
    nama_gawangan?: StringFilter<"gawangan"> | string
    outlet_id?: IntFilter<"gawangan"> | number
    outlet?: XOR<OutletRelationFilter, outletWhereInput>
    detail_gawangans?: Detail_gawanganListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }

  export type gawanganOrderByWithRelationInput = {
    id?: SortOrder
    nama_gawangan?: SortOrder
    outlet_id?: SortOrder
    outlet?: outletOrderByWithRelationInput
    detail_gawangans?: detail_gawanganOrderByRelationAggregateInput
    detail_pembelian_produk?: detail_pembelian_produkOrderByRelationAggregateInput
  }

  export type gawanganWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: gawanganWhereInput | gawanganWhereInput[]
    OR?: gawanganWhereInput[]
    NOT?: gawanganWhereInput | gawanganWhereInput[]
    nama_gawangan?: StringFilter<"gawangan"> | string
    outlet_id?: IntFilter<"gawangan"> | number
    outlet?: XOR<OutletRelationFilter, outletWhereInput>
    detail_gawangans?: Detail_gawanganListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }, "id">

  export type gawanganOrderByWithAggregationInput = {
    id?: SortOrder
    nama_gawangan?: SortOrder
    outlet_id?: SortOrder
    _count?: gawanganCountOrderByAggregateInput
    _avg?: gawanganAvgOrderByAggregateInput
    _max?: gawanganMaxOrderByAggregateInput
    _min?: gawanganMinOrderByAggregateInput
    _sum?: gawanganSumOrderByAggregateInput
  }

  export type gawanganScalarWhereWithAggregatesInput = {
    AND?: gawanganScalarWhereWithAggregatesInput | gawanganScalarWhereWithAggregatesInput[]
    OR?: gawanganScalarWhereWithAggregatesInput[]
    NOT?: gawanganScalarWhereWithAggregatesInput | gawanganScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"gawangan"> | number
    nama_gawangan?: StringWithAggregatesFilter<"gawangan"> | string
    outlet_id?: IntWithAggregatesFilter<"gawangan"> | number
  }

  export type outletWhereInput = {
    AND?: outletWhereInput | outletWhereInput[]
    OR?: outletWhereInput[]
    NOT?: outletWhereInput | outletWhereInput[]
    id?: IntFilter<"outlet"> | number
    nama_outlet?: StringFilter<"outlet"> | string
    alamat?: StringFilter<"outlet"> | string
    nama_pic?: StringFilter<"outlet"> | string
    kontak_pic?: StringFilter<"outlet"> | string
    gawangan?: GawanganListRelationFilter
  }

  export type outletOrderByWithRelationInput = {
    id?: SortOrder
    nama_outlet?: SortOrder
    alamat?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
    gawangan?: gawanganOrderByRelationAggregateInput
  }

  export type outletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: outletWhereInput | outletWhereInput[]
    OR?: outletWhereInput[]
    NOT?: outletWhereInput | outletWhereInput[]
    nama_outlet?: StringFilter<"outlet"> | string
    alamat?: StringFilter<"outlet"> | string
    nama_pic?: StringFilter<"outlet"> | string
    kontak_pic?: StringFilter<"outlet"> | string
    gawangan?: GawanganListRelationFilter
  }, "id">

  export type outletOrderByWithAggregationInput = {
    id?: SortOrder
    nama_outlet?: SortOrder
    alamat?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
    _count?: outletCountOrderByAggregateInput
    _avg?: outletAvgOrderByAggregateInput
    _max?: outletMaxOrderByAggregateInput
    _min?: outletMinOrderByAggregateInput
    _sum?: outletSumOrderByAggregateInput
  }

  export type outletScalarWhereWithAggregatesInput = {
    AND?: outletScalarWhereWithAggregatesInput | outletScalarWhereWithAggregatesInput[]
    OR?: outletScalarWhereWithAggregatesInput[]
    NOT?: outletScalarWhereWithAggregatesInput | outletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"outlet"> | number
    nama_outlet?: StringWithAggregatesFilter<"outlet"> | string
    alamat?: StringWithAggregatesFilter<"outlet"> | string
    nama_pic?: StringWithAggregatesFilter<"outlet"> | string
    kontak_pic?: StringWithAggregatesFilter<"outlet"> | string
  }

  export type pembelian_produkWhereInput = {
    AND?: pembelian_produkWhereInput | pembelian_produkWhereInput[]
    OR?: pembelian_produkWhereInput[]
    NOT?: pembelian_produkWhereInput | pembelian_produkWhereInput[]
    id?: IntFilter<"pembelian_produk"> | number
    tanggal_pembelian?: DateTimeFilter<"pembelian_produk"> | Date | string
    nama_pembeli?: StringFilter<"pembelian_produk"> | string
    kontak_pembeli?: StringFilter<"pembelian_produk"> | string
    user_id?: IntFilter<"pembelian_produk"> | number
    user?: XOR<UserRelationFilter, userWhereInput>
    detail_diskon?: Detail_diskonListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }

  export type pembelian_produkOrderByWithRelationInput = {
    id?: SortOrder
    tanggal_pembelian?: SortOrder
    nama_pembeli?: SortOrder
    kontak_pembeli?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    detail_diskon?: detail_diskonOrderByRelationAggregateInput
    detail_pembelian_produk?: detail_pembelian_produkOrderByRelationAggregateInput
  }

  export type pembelian_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pembelian_produkWhereInput | pembelian_produkWhereInput[]
    OR?: pembelian_produkWhereInput[]
    NOT?: pembelian_produkWhereInput | pembelian_produkWhereInput[]
    tanggal_pembelian?: DateTimeFilter<"pembelian_produk"> | Date | string
    nama_pembeli?: StringFilter<"pembelian_produk"> | string
    kontak_pembeli?: StringFilter<"pembelian_produk"> | string
    user_id?: IntFilter<"pembelian_produk"> | number
    user?: XOR<UserRelationFilter, userWhereInput>
    detail_diskon?: Detail_diskonListRelationFilter
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
  }, "id">

  export type pembelian_produkOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal_pembelian?: SortOrder
    nama_pembeli?: SortOrder
    kontak_pembeli?: SortOrder
    user_id?: SortOrder
    _count?: pembelian_produkCountOrderByAggregateInput
    _avg?: pembelian_produkAvgOrderByAggregateInput
    _max?: pembelian_produkMaxOrderByAggregateInput
    _min?: pembelian_produkMinOrderByAggregateInput
    _sum?: pembelian_produkSumOrderByAggregateInput
  }

  export type pembelian_produkScalarWhereWithAggregatesInput = {
    AND?: pembelian_produkScalarWhereWithAggregatesInput | pembelian_produkScalarWhereWithAggregatesInput[]
    OR?: pembelian_produkScalarWhereWithAggregatesInput[]
    NOT?: pembelian_produkScalarWhereWithAggregatesInput | pembelian_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pembelian_produk"> | number
    tanggal_pembelian?: DateTimeWithAggregatesFilter<"pembelian_produk"> | Date | string
    nama_pembeli?: StringWithAggregatesFilter<"pembelian_produk"> | string
    kontak_pembeli?: StringWithAggregatesFilter<"pembelian_produk"> | string
    user_id?: IntWithAggregatesFilter<"pembelian_produk"> | number
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    nama_lengkap?: StringFilter<"user"> | string
    kontak?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    pembelian_produk?: Pembelian_produkListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    nama_lengkap?: SortOrder
    kontak?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    pembelian_produk?: pembelian_produkOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    nama_lengkap?: StringFilter<"user"> | string
    kontak?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    pembelian_produk?: Pembelian_produkListRelationFilter
  }, "id">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    nama_lengkap?: SortOrder
    kontak?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    nama_lengkap?: StringWithAggregatesFilter<"user"> | string
    kontak?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    username?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
  }

  export type detail_pembelian_produkWhereInput = {
    AND?: detail_pembelian_produkWhereInput | detail_pembelian_produkWhereInput[]
    OR?: detail_pembelian_produkWhereInput[]
    NOT?: detail_pembelian_produkWhereInput | detail_pembelian_produkWhereInput[]
    id?: IntFilter<"detail_pembelian_produk"> | number
    jumlah?: IntFilter<"detail_pembelian_produk"> | number
    diskon_id?: IntFilter<"detail_pembelian_produk"> | number
    produk_item_id?: IntFilter<"detail_pembelian_produk"> | number
    pembelian_produk_id?: IntFilter<"detail_pembelian_produk"> | number
    gawangan_id?: IntFilter<"detail_pembelian_produk"> | number
    diskon?: XOR<DiskonRelationFilter, diskonWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
    pembelian_produk?: XOR<Pembelian_produkRelationFilter, pembelian_produkWhereInput>
    gawangan?: XOR<GawanganRelationFilter, gawanganWhereInput>
  }

  export type detail_pembelian_produkOrderByWithRelationInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
    diskon?: diskonOrderByWithRelationInput
    produk_item?: produk_itemOrderByWithRelationInput
    pembelian_produk?: pembelian_produkOrderByWithRelationInput
    gawangan?: gawanganOrderByWithRelationInput
  }

  export type detail_pembelian_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_pembelian_produkWhereInput | detail_pembelian_produkWhereInput[]
    OR?: detail_pembelian_produkWhereInput[]
    NOT?: detail_pembelian_produkWhereInput | detail_pembelian_produkWhereInput[]
    jumlah?: IntFilter<"detail_pembelian_produk"> | number
    diskon_id?: IntFilter<"detail_pembelian_produk"> | number
    produk_item_id?: IntFilter<"detail_pembelian_produk"> | number
    pembelian_produk_id?: IntFilter<"detail_pembelian_produk"> | number
    gawangan_id?: IntFilter<"detail_pembelian_produk"> | number
    diskon?: XOR<DiskonRelationFilter, diskonWhereInput>
    produk_item?: XOR<Produk_itemRelationFilter, produk_itemWhereInput>
    pembelian_produk?: XOR<Pembelian_produkRelationFilter, pembelian_produkWhereInput>
    gawangan?: XOR<GawanganRelationFilter, gawanganWhereInput>
  }, "id">

  export type detail_pembelian_produkOrderByWithAggregationInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
    _count?: detail_pembelian_produkCountOrderByAggregateInput
    _avg?: detail_pembelian_produkAvgOrderByAggregateInput
    _max?: detail_pembelian_produkMaxOrderByAggregateInput
    _min?: detail_pembelian_produkMinOrderByAggregateInput
    _sum?: detail_pembelian_produkSumOrderByAggregateInput
  }

  export type detail_pembelian_produkScalarWhereWithAggregatesInput = {
    AND?: detail_pembelian_produkScalarWhereWithAggregatesInput | detail_pembelian_produkScalarWhereWithAggregatesInput[]
    OR?: detail_pembelian_produkScalarWhereWithAggregatesInput[]
    NOT?: detail_pembelian_produkScalarWhereWithAggregatesInput | detail_pembelian_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
    jumlah?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
    diskon_id?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
    produk_item_id?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
    pembelian_produk_id?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
    gawangan_id?: IntWithAggregatesFilter<"detail_pembelian_produk"> | number
  }

  export type diskonWhereInput = {
    AND?: diskonWhereInput | diskonWhereInput[]
    OR?: diskonWhereInput[]
    NOT?: diskonWhereInput | diskonWhereInput[]
    id?: IntFilter<"diskon"> | number
    nama_diskon?: StringFilter<"diskon"> | string
    tipe_diskon?: EnumTipeDiskonFilter<"diskon"> | $Enums.TipeDiskon
    jumlah_diskon?: FloatFilter<"diskon"> | number
    tanggal_mulai?: DateTimeFilter<"diskon"> | Date | string
    tanggal_selesai?: DateTimeFilter<"diskon"> | Date | string
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
    detail_diskon?: Detail_diskonListRelationFilter
  }

  export type diskonOrderByWithRelationInput = {
    id?: SortOrder
    nama_diskon?: SortOrder
    tipe_diskon?: SortOrder
    jumlah_diskon?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
    detail_pembelian_produk?: detail_pembelian_produkOrderByRelationAggregateInput
    detail_diskon?: detail_diskonOrderByRelationAggregateInput
  }

  export type diskonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: diskonWhereInput | diskonWhereInput[]
    OR?: diskonWhereInput[]
    NOT?: diskonWhereInput | diskonWhereInput[]
    nama_diskon?: StringFilter<"diskon"> | string
    tipe_diskon?: EnumTipeDiskonFilter<"diskon"> | $Enums.TipeDiskon
    jumlah_diskon?: FloatFilter<"diskon"> | number
    tanggal_mulai?: DateTimeFilter<"diskon"> | Date | string
    tanggal_selesai?: DateTimeFilter<"diskon"> | Date | string
    detail_pembelian_produk?: Detail_pembelian_produkListRelationFilter
    detail_diskon?: Detail_diskonListRelationFilter
  }, "id">

  export type diskonOrderByWithAggregationInput = {
    id?: SortOrder
    nama_diskon?: SortOrder
    tipe_diskon?: SortOrder
    jumlah_diskon?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
    _count?: diskonCountOrderByAggregateInput
    _avg?: diskonAvgOrderByAggregateInput
    _max?: diskonMaxOrderByAggregateInput
    _min?: diskonMinOrderByAggregateInput
    _sum?: diskonSumOrderByAggregateInput
  }

  export type diskonScalarWhereWithAggregatesInput = {
    AND?: diskonScalarWhereWithAggregatesInput | diskonScalarWhereWithAggregatesInput[]
    OR?: diskonScalarWhereWithAggregatesInput[]
    NOT?: diskonScalarWhereWithAggregatesInput | diskonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"diskon"> | number
    nama_diskon?: StringWithAggregatesFilter<"diskon"> | string
    tipe_diskon?: EnumTipeDiskonWithAggregatesFilter<"diskon"> | $Enums.TipeDiskon
    jumlah_diskon?: FloatWithAggregatesFilter<"diskon"> | number
    tanggal_mulai?: DateTimeWithAggregatesFilter<"diskon"> | Date | string
    tanggal_selesai?: DateTimeWithAggregatesFilter<"diskon"> | Date | string
  }

  export type detail_diskonWhereInput = {
    AND?: detail_diskonWhereInput | detail_diskonWhereInput[]
    OR?: detail_diskonWhereInput[]
    NOT?: detail_diskonWhereInput | detail_diskonWhereInput[]
    id?: IntFilter<"detail_diskon"> | number
    diskon_id?: IntFilter<"detail_diskon"> | number
    produk_item_id?: IntNullableFilter<"detail_diskon"> | number | null
    pembelian_produk_id?: IntNullableFilter<"detail_diskon"> | number | null
    jumlah?: FloatFilter<"detail_diskon"> | number
    jumlah_diskon?: FloatFilter<"detail_diskon"> | number
    diskon?: XOR<DiskonRelationFilter, diskonWhereInput>
    produk_item?: XOR<Produk_itemNullableRelationFilter, produk_itemWhereInput> | null
    pembelian_produk?: XOR<Pembelian_produkNullableRelationFilter, pembelian_produkWhereInput> | null
  }

  export type detail_diskonOrderByWithRelationInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrderInput | SortOrder
    pembelian_produk_id?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
    diskon?: diskonOrderByWithRelationInput
    produk_item?: produk_itemOrderByWithRelationInput
    pembelian_produk?: pembelian_produkOrderByWithRelationInput
  }

  export type detail_diskonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_diskonWhereInput | detail_diskonWhereInput[]
    OR?: detail_diskonWhereInput[]
    NOT?: detail_diskonWhereInput | detail_diskonWhereInput[]
    diskon_id?: IntFilter<"detail_diskon"> | number
    produk_item_id?: IntNullableFilter<"detail_diskon"> | number | null
    pembelian_produk_id?: IntNullableFilter<"detail_diskon"> | number | null
    jumlah?: FloatFilter<"detail_diskon"> | number
    jumlah_diskon?: FloatFilter<"detail_diskon"> | number
    diskon?: XOR<DiskonRelationFilter, diskonWhereInput>
    produk_item?: XOR<Produk_itemNullableRelationFilter, produk_itemWhereInput> | null
    pembelian_produk?: XOR<Pembelian_produkNullableRelationFilter, pembelian_produkWhereInput> | null
  }, "id">

  export type detail_diskonOrderByWithAggregationInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrderInput | SortOrder
    pembelian_produk_id?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
    _count?: detail_diskonCountOrderByAggregateInput
    _avg?: detail_diskonAvgOrderByAggregateInput
    _max?: detail_diskonMaxOrderByAggregateInput
    _min?: detail_diskonMinOrderByAggregateInput
    _sum?: detail_diskonSumOrderByAggregateInput
  }

  export type detail_diskonScalarWhereWithAggregatesInput = {
    AND?: detail_diskonScalarWhereWithAggregatesInput | detail_diskonScalarWhereWithAggregatesInput[]
    OR?: detail_diskonScalarWhereWithAggregatesInput[]
    NOT?: detail_diskonScalarWhereWithAggregatesInput | detail_diskonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_diskon"> | number
    diskon_id?: IntWithAggregatesFilter<"detail_diskon"> | number
    produk_item_id?: IntNullableWithAggregatesFilter<"detail_diskon"> | number | null
    pembelian_produk_id?: IntNullableWithAggregatesFilter<"detail_diskon"> | number | null
    jumlah?: FloatWithAggregatesFilter<"detail_diskon"> | number
    jumlah_diskon?: FloatWithAggregatesFilter<"detail_diskon"> | number
  }

  export type produk_itemCreateInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi: produksiCreateNestedOneWithoutProduk_itemInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUpdateInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutProduk_itemNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemCreateManyInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
  }

  export type produk_itemUpdateManyMutationInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type produk_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
  }

  export type produksiCreateInput = {
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat: pembuatCreateNestedOneWithoutProduksiInput
    kategori_produk: kategori_produkCreateNestedOneWithoutProduksiInput
    produk_item?: produk_itemCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
    produk_item?: produk_itemUncheckedCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiUpdateInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat?: pembuatUpdateOneRequiredWithoutProduksiNestedInput
    kategori_produk?: kategori_produkUpdateOneRequiredWithoutProduksiNestedInput
    produk_item?: produk_itemUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUncheckedUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiCreateManyInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
  }

  export type produksiUpdateManyMutationInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
  }

  export type produksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type kategori_produkCreateInput = {
    kategori: string
    produksi?: produksiCreateNestedManyWithoutKategori_produkInput
  }

  export type kategori_produkUncheckedCreateInput = {
    id?: number
    kategori: string
    produksi?: produksiUncheckedCreateNestedManyWithoutKategori_produkInput
  }

  export type kategori_produkUpdateInput = {
    kategori?: StringFieldUpdateOperationsInput | string
    produksi?: produksiUpdateManyWithoutKategori_produkNestedInput
  }

  export type kategori_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kategori?: StringFieldUpdateOperationsInput | string
    produksi?: produksiUncheckedUpdateManyWithoutKategori_produkNestedInput
  }

  export type kategori_produkCreateManyInput = {
    id?: number
    kategori: string
  }

  export type kategori_produkUpdateManyMutationInput = {
    kategori?: StringFieldUpdateOperationsInput | string
  }

  export type kategori_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kategori?: StringFieldUpdateOperationsInput | string
  }

  export type pembuatCreateInput = {
    nama_pembuat: string
    produksi?: produksiCreateNestedManyWithoutPembuatInput
  }

  export type pembuatUncheckedCreateInput = {
    id?: number
    nama_pembuat: string
    produksi?: produksiUncheckedCreateNestedManyWithoutPembuatInput
  }

  export type pembuatUpdateInput = {
    nama_pembuat?: StringFieldUpdateOperationsInput | string
    produksi?: produksiUpdateManyWithoutPembuatNestedInput
  }

  export type pembuatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pembuat?: StringFieldUpdateOperationsInput | string
    produksi?: produksiUncheckedUpdateManyWithoutPembuatNestedInput
  }

  export type pembuatCreateManyInput = {
    id?: number
    nama_pembuat: string
  }

  export type pembuatUpdateManyMutationInput = {
    nama_pembuat?: StringFieldUpdateOperationsInput | string
  }

  export type pembuatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pembuat?: StringFieldUpdateOperationsInput | string
  }

  export type bahan_produksiCreateInput = {
    stok_terpakai: number
    produksi: produksiCreateNestedOneWithoutBahan_produksiInput
    stok_bahan: stok_bahanCreateNestedOneWithoutBahan_produksiInput
  }

  export type bahan_produksiUncheckedCreateInput = {
    id?: number
    stok_terpakai: number
    produksi_id: number
    stok_bahan_id: number
  }

  export type bahan_produksiUpdateInput = {
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutBahan_produksiNestedInput
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutBahan_produksiNestedInput
  }

  export type bahan_produksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type bahan_produksiCreateManyInput = {
    id?: number
    stok_terpakai: number
    produksi_id: number
    stok_bahan_id: number
  }

  export type bahan_produksiUpdateManyMutationInput = {
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
  }

  export type bahan_produksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type stok_bahanCreateInput = {
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutStok_bahanInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanUncheckedCreateInput = {
    id?: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutStok_bahanInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanUpdateInput = {
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUpdateManyWithoutStok_bahanNestedInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUpdateManyWithoutStok_bahanNestedInput
  }

  export type stok_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutStok_bahanNestedInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
  }

  export type stok_bahanCreateManyInput = {
    id?: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
  }

  export type stok_bahanUpdateManyMutationInput = {
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
  }

  export type stok_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkCreateInput = {
    jumlah: number
    pengecekan_produk: pengecekan_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_pengecekan_produkInput
    kondisi_produk: kondisi_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
  }

  export type detail_pengecekan_produkUncheckedCreateInput = {
    id?: number
    pengecekan_produk_id: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkUpdateInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_produk?: pengecekan_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
    kondisi_produk?: kondisi_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
  }

  export type detail_pengecekan_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkCreateManyInput = {
    id?: number
    pengecekan_produk_id: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkUpdateManyMutationInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type pengecekan_produkCreateInput = {
    nama_pic: string
    tanggal: Date | string
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutPengecekan_produkInput
  }

  export type pengecekan_produkUncheckedCreateInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutPengecekan_produkInput
  }

  export type pengecekan_produkUpdateInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutPengecekan_produkNestedInput
  }

  export type pengecekan_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutPengecekan_produkNestedInput
  }

  export type pengecekan_produkCreateManyInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_produkUpdateManyMutationInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pengecekan_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kondisi_produkCreateInput = {
    kondisi: string
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutKondisi_produkInput
  }

  export type kondisi_produkUncheckedCreateInput = {
    id?: number
    kondisi: string
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutKondisi_produkInput
  }

  export type kondisi_produkUpdateInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutKondisi_produkNestedInput
  }

  export type kondisi_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutKondisi_produkNestedInput
  }

  export type kondisi_produkCreateManyInput = {
    id?: number
    kondisi: string
  }

  export type kondisi_produkUpdateManyMutationInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
  }

  export type kondisi_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
  }

  export type detail_pengecekan_bahanCreateInput = {
    jumlah: number
    pengecekan_bahan: pengecekan_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
    stok_bahan: stok_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
    kondisi_bahan: kondisi_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
  }

  export type detail_pengecekan_bahanUncheckedCreateInput = {
    id?: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanUpdateInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_bahan?: pengecekan_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
    kondisi_bahan?: kondisi_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
  }

  export type detail_pengecekan_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanCreateManyInput = {
    id?: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanUpdateManyMutationInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type pengecekan_bahanCreateInput = {
    nama_pic: string
    tanggal: Date | string
    detail_pengecekan_bahan?: detail_pengecekan_bahanCreateNestedManyWithoutPengecekan_bahanInput
  }

  export type pengecekan_bahanUncheckedCreateInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedCreateNestedManyWithoutPengecekan_bahanInput
  }

  export type pengecekan_bahanUpdateInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pengecekan_bahan?: detail_pengecekan_bahanUpdateManyWithoutPengecekan_bahanNestedInput
  }

  export type pengecekan_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedUpdateManyWithoutPengecekan_bahanNestedInput
  }

  export type pengecekan_bahanCreateManyInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_bahanUpdateManyMutationInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pengecekan_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kondisi_bahanCreateInput = {
    kondisi: string
    pengecekan_bahan_id: number
    detail_pengecekan_bahan?: detail_pengecekan_bahanCreateNestedManyWithoutKondisi_bahanInput
  }

  export type kondisi_bahanUncheckedCreateInput = {
    id?: number
    kondisi: string
    pengecekan_bahan_id: number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedCreateNestedManyWithoutKondisi_bahanInput
  }

  export type kondisi_bahanUpdateInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUpdateManyWithoutKondisi_bahanNestedInput
  }

  export type kondisi_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedUpdateManyWithoutKondisi_bahanNestedInput
  }

  export type kondisi_bahanCreateManyInput = {
    id?: number
    kondisi: string
    pengecekan_bahan_id: number
  }

  export type kondisi_bahanUpdateManyMutationInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type kondisi_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanCreateInput = {
    jumlah: number
    harga: number
    pemesanan_bahan: pemesanan_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput
    stok_bahan: stok_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput
  }

  export type detail_pemesanan_bahanUncheckedCreateInput = {
    id?: number
    stok_bahan_id: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
  }

  export type detail_pemesanan_bahanUpdateInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
    pemesanan_bahan?: pemesanan_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput
  }

  export type detail_pemesanan_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    pemesanan_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanCreateManyInput = {
    id?: number
    stok_bahan_id: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
  }

  export type detail_pemesanan_bahanUpdateManyMutationInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    pemesanan_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type pemesanan_bahanCreateInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier: supplierCreateNestedOneWithoutPemesanan_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanCreateNestedManyWithoutPemesanan_bahanInput
  }

  export type pemesanan_bahanUncheckedCreateInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier_id: number
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedCreateNestedManyWithoutPemesanan_bahanInput
  }

  export type pemesanan_bahanUpdateInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    supplier?: supplierUpdateOneRequiredWithoutPemesanan_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUpdateManyWithoutPemesanan_bahanNestedInput
  }

  export type pemesanan_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    supplier_id?: IntFieldUpdateOperationsInput | number
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedUpdateManyWithoutPemesanan_bahanNestedInput
  }

  export type pemesanan_bahanCreateManyInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier_id: number
  }

  export type pemesanan_bahanUpdateManyMutationInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
  }

  export type pemesanan_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    supplier_id?: IntFieldUpdateOperationsInput | number
  }

  export type supplierCreateInput = {
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
    pemesanan_bahan?: pemesanan_bahanCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    id?: number
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
    pemesanan_bahan?: pemesanan_bahanUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
    pemesanan_bahan?: pemesanan_bahanUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
    pemesanan_bahan?: pemesanan_bahanUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateManyInput = {
    id?: number
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
  }

  export type supplierUpdateManyMutationInput = {
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type supplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type detail_gawanganCreateInput = {
    jumlah: number
    gawangan: gawanganCreateNestedOneWithoutDetail_gawangansInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_gawanganInput
  }

  export type detail_gawanganUncheckedCreateInput = {
    id?: number
    gawangan_id: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_gawanganUpdateInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_gawangansNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_gawanganNestedInput
  }

  export type detail_gawanganUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_gawanganCreateManyInput = {
    id?: number
    gawangan_id: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_gawanganUpdateManyMutationInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_gawanganUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type gawanganCreateInput = {
    nama_gawangan: string
    outlet: outletCreateNestedOneWithoutGawanganInput
    detail_gawangans?: detail_gawanganCreateNestedManyWithoutGawanganInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutGawanganInput
  }

  export type gawanganUncheckedCreateInput = {
    id?: number
    nama_gawangan: string
    outlet_id: number
    detail_gawangans?: detail_gawanganUncheckedCreateNestedManyWithoutGawanganInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutGawanganInput
  }

  export type gawanganUpdateInput = {
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneRequiredWithoutGawanganNestedInput
    detail_gawangans?: detail_gawanganUpdateManyWithoutGawanganNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet_id?: IntFieldUpdateOperationsInput | number
    detail_gawangans?: detail_gawanganUncheckedUpdateManyWithoutGawanganNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganCreateManyInput = {
    id?: number
    nama_gawangan: string
    outlet_id: number
  }

  export type gawanganUpdateManyMutationInput = {
    nama_gawangan?: StringFieldUpdateOperationsInput | string
  }

  export type gawanganUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet_id?: IntFieldUpdateOperationsInput | number
  }

  export type outletCreateInput = {
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
    gawangan?: gawanganCreateNestedManyWithoutOutletInput
  }

  export type outletUncheckedCreateInput = {
    id?: number
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
    gawangan?: gawanganUncheckedCreateNestedManyWithoutOutletInput
  }

  export type outletUpdateInput = {
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
    gawangan?: gawanganUpdateManyWithoutOutletNestedInput
  }

  export type outletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
    gawangan?: gawanganUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type outletCreateManyInput = {
    id?: number
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
  }

  export type outletUpdateManyMutationInput = {
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type outletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type pembelian_produkCreateInput = {
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user: userCreateNestedOneWithoutPembelian_produkInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutPembelian_produkInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkUncheckedCreateInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutPembelian_produkInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkUpdateInput = {
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutPembelian_produkNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutPembelian_produkNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutPembelian_produkNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkCreateManyInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user_id: number
  }

  export type pembelian_produkUpdateManyMutationInput = {
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
  }

  export type pembelian_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
    pembelian_produk?: pembelian_produkCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
    pembelian_produk?: pembelian_produkUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pembelian_produk?: pembelian_produkUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pembelian_produk?: pembelian_produkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
  }

  export type userUpdateManyMutationInput = {
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type detail_pembelian_produkCreateInput = {
    jumlah: number
    diskon: diskonCreateNestedOneWithoutDetail_pembelian_produkInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_pembelian_produkInput
    pembelian_produk: pembelian_produkCreateNestedOneWithoutDetail_pembelian_produkInput
    gawangan: gawanganCreateNestedOneWithoutDetail_pembelian_produkInput
  }

  export type detail_pembelian_produkUncheckedCreateInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_pembelian_produkUpdateInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    pembelian_produk?: pembelian_produkUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
  }

  export type detail_pembelian_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkCreateManyInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_pembelian_produkUpdateManyMutationInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type diskonCreateInput = {
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutDiskonInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutDiskonInput
  }

  export type diskonUncheckedCreateInput = {
    id?: number
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutDiskonInput
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutDiskonInput
  }

  export type diskonUpdateInput = {
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutDiskonNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutDiskonNestedInput
  }

  export type diskonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutDiskonNestedInput
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutDiskonNestedInput
  }

  export type diskonCreateManyInput = {
    id?: number
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
  }

  export type diskonUpdateManyMutationInput = {
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diskonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type detail_diskonCreateInput = {
    jumlah: number
    jumlah_diskon: number
    diskon: diskonCreateNestedOneWithoutDetail_diskonInput
    produk_item?: produk_itemCreateNestedOneWithoutDetail_diskonInput
    pembelian_produk?: pembelian_produkCreateNestedOneWithoutDetail_diskonInput
  }

  export type detail_diskonUncheckedCreateInput = {
    id?: number
    diskon_id: number
    produk_item_id?: number | null
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_diskonUpdateInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_diskonNestedInput
    produk_item?: produk_itemUpdateOneWithoutDetail_diskonNestedInput
    pembelian_produk?: pembelian_produkUpdateOneWithoutDetail_diskonNestedInput
  }

  export type detail_diskonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_diskonCreateManyInput = {
    id?: number
    diskon_id: number
    produk_item_id?: number | null
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_diskonUpdateManyMutationInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_diskonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProduksiRelationFilter = {
    is?: produksiWhereInput
    isNot?: produksiWhereInput
  }

  export type Detail_diskonListRelationFilter = {
    every?: detail_diskonWhereInput
    some?: detail_diskonWhereInput
    none?: detail_diskonWhereInput
  }

  export type Detail_pengecekan_produkListRelationFilter = {
    every?: detail_pengecekan_produkWhereInput
    some?: detail_pengecekan_produkWhereInput
    none?: detail_pengecekan_produkWhereInput
  }

  export type Detail_gawanganListRelationFilter = {
    every?: detail_gawanganWhereInput
    some?: detail_gawanganWhereInput
    none?: detail_gawanganWhereInput
  }

  export type Detail_pembelian_produkListRelationFilter = {
    every?: detail_pembelian_produkWhereInput
    some?: detail_pembelian_produkWhereInput
    none?: detail_pembelian_produkWhereInput
  }

  export type detail_diskonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_pengecekan_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_gawanganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_pembelian_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type produk_itemCountOrderByAggregateInput = {
    id?: SortOrder
    kode_produk?: SortOrder
    sku?: SortOrder
    nama_produk?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
  }

  export type produk_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
  }

  export type produk_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_produk?: SortOrder
    sku?: SortOrder
    nama_produk?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
  }

  export type produk_itemMinOrderByAggregateInput = {
    id?: SortOrder
    kode_produk?: SortOrder
    sku?: SortOrder
    nama_produk?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
  }

  export type produk_itemSumOrderByAggregateInput = {
    id?: SortOrder
    stok?: SortOrder
    harga_jual?: SortOrder
    produksi_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PembuatRelationFilter = {
    is?: pembuatWhereInput
    isNot?: pembuatWhereInput
  }

  export type Kategori_produkRelationFilter = {
    is?: kategori_produkWhereInput
    isNot?: kategori_produkWhereInput
  }

  export type Produk_itemListRelationFilter = {
    every?: produk_itemWhereInput
    some?: produk_itemWhereInput
    none?: produk_itemWhereInput
  }

  export type Bahan_produksiListRelationFilter = {
    every?: bahan_produksiWhereInput
    some?: bahan_produksiWhereInput
    none?: bahan_produksiWhereInput
  }

  export type produk_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bahan_produksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type produksiCountOrderByAggregateInput = {
    id?: SortOrder
    mulai?: SortOrder
    selesai?: SortOrder
    kode_produk?: SortOrder
    jumlah?: SortOrder
    ukuran?: SortOrder
    warna?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
  }

  export type produksiAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
  }

  export type produksiMaxOrderByAggregateInput = {
    id?: SortOrder
    mulai?: SortOrder
    selesai?: SortOrder
    kode_produk?: SortOrder
    jumlah?: SortOrder
    ukuran?: SortOrder
    warna?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
  }

  export type produksiMinOrderByAggregateInput = {
    id?: SortOrder
    mulai?: SortOrder
    selesai?: SortOrder
    kode_produk?: SortOrder
    jumlah?: SortOrder
    ukuran?: SortOrder
    warna?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
  }

  export type produksiSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    biaya?: SortOrder
    pembuat_id?: SortOrder
    kategori_produk_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProduksiListRelationFilter = {
    every?: produksiWhereInput
    some?: produksiWhereInput
    none?: produksiWhereInput
  }

  export type produksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kategori_produkCountOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
  }

  export type kategori_produkAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kategori_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
  }

  export type kategori_produkMinOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
  }

  export type kategori_produkSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pembuatCountOrderByAggregateInput = {
    id?: SortOrder
    nama_pembuat?: SortOrder
  }

  export type pembuatAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pembuatMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_pembuat?: SortOrder
  }

  export type pembuatMinOrderByAggregateInput = {
    id?: SortOrder
    nama_pembuat?: SortOrder
  }

  export type pembuatSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Stok_bahanRelationFilter = {
    is?: stok_bahanWhereInput
    isNot?: stok_bahanWhereInput
  }

  export type bahan_produksiCountOrderByAggregateInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
  }

  export type bahan_produksiAvgOrderByAggregateInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
  }

  export type bahan_produksiMaxOrderByAggregateInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
  }

  export type bahan_produksiMinOrderByAggregateInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
  }

  export type bahan_produksiSumOrderByAggregateInput = {
    id?: SortOrder
    stok_terpakai?: SortOrder
    produksi_id?: SortOrder
    stok_bahan_id?: SortOrder
  }

  export type Detail_pengecekan_bahanListRelationFilter = {
    every?: detail_pengecekan_bahanWhereInput
    some?: detail_pengecekan_bahanWhereInput
    none?: detail_pengecekan_bahanWhereInput
  }

  export type Detail_pemesanan_bahanListRelationFilter = {
    every?: detail_pemesanan_bahanWhereInput
    some?: detail_pemesanan_bahanWhereInput
    none?: detail_pemesanan_bahanWhereInput
  }

  export type detail_pengecekan_bahanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_pemesanan_bahanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type stok_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    kode_bahan?: SortOrder
    nama_bahan?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    stok?: SortOrder
  }

  export type stok_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    ukuran?: SortOrder
    stok?: SortOrder
  }

  export type stok_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_bahan?: SortOrder
    nama_bahan?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    stok?: SortOrder
  }

  export type stok_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    kode_bahan?: SortOrder
    nama_bahan?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    stok?: SortOrder
  }

  export type stok_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    ukuran?: SortOrder
    stok?: SortOrder
  }

  export type Pengecekan_produkRelationFilter = {
    is?: pengecekan_produkWhereInput
    isNot?: pengecekan_produkWhereInput
  }

  export type Produk_itemRelationFilter = {
    is?: produk_itemWhereInput
    isNot?: produk_itemWhereInput
  }

  export type Kondisi_produkRelationFilter = {
    is?: kondisi_produkWhereInput
    isNot?: kondisi_produkWhereInput
  }

  export type detail_pengecekan_produkCountOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_produkMinOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_produkSumOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_produk_id?: SortOrder
    produk_item_id?: SortOrder
    kondisi_produk_id?: SortOrder
    jumlah?: SortOrder
  }

  export type pengecekan_produkCountOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_produkAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pengecekan_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_produkMinOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_produkSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kondisi_produkCountOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
  }

  export type kondisi_produkAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kondisi_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
  }

  export type kondisi_produkMinOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
  }

  export type kondisi_produkSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Pengecekan_bahanRelationFilter = {
    is?: pengecekan_bahanWhereInput
    isNot?: pengecekan_bahanWhereInput
  }

  export type Kondisi_bahanRelationFilter = {
    is?: kondisi_bahanWhereInput
    isNot?: kondisi_bahanWhereInput
  }

  export type detail_pengecekan_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_pengecekan_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
    stok_bahan_id?: SortOrder
    kondisi_bahan_id?: SortOrder
    jumlah?: SortOrder
  }

  export type pengecekan_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pengecekan_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    nama_pic?: SortOrder
    tanggal?: SortOrder
  }

  export type pengecekan_bahanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kondisi_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
    pengecekan_bahan_id?: SortOrder
  }

  export type kondisi_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
  }

  export type kondisi_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
    pengecekan_bahan_id?: SortOrder
  }

  export type kondisi_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    kondisi?: SortOrder
    pengecekan_bahan_id?: SortOrder
  }

  export type kondisi_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    pengecekan_bahan_id?: SortOrder
  }

  export type Pemesanan_bahanRelationFilter = {
    is?: pemesanan_bahanWhereInput
    isNot?: pemesanan_bahanWhereInput
  }

  export type detail_pemesanan_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
  }

  export type detail_pemesanan_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
  }

  export type detail_pemesanan_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
  }

  export type detail_pemesanan_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
  }

  export type detail_pemesanan_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    stok_bahan_id?: SortOrder
    pemesanan_bahan_id?: SortOrder
    jumlah?: SortOrder
    harga?: SortOrder
  }

  export type SupplierRelationFilter = {
    is?: supplierWhereInput
    isNot?: supplierWhereInput
  }

  export type pemesanan_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    pic_pemesan?: SortOrder
    kontak_pic_pemesan?: SortOrder
    supplier_id?: SortOrder
  }

  export type pemesanan_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    supplier_id?: SortOrder
  }

  export type pemesanan_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    pic_pemesan?: SortOrder
    kontak_pic_pemesan?: SortOrder
    supplier_id?: SortOrder
  }

  export type pemesanan_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    pic_pemesan?: SortOrder
    kontak_pic_pemesan?: SortOrder
    supplier_id?: SortOrder
  }

  export type pemesanan_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    supplier_id?: SortOrder
  }

  export type Pemesanan_bahanListRelationFilter = {
    every?: pemesanan_bahanWhereInput
    some?: pemesanan_bahanWhereInput
    none?: pemesanan_bahanWhereInput
  }

  export type pemesanan_bahanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    id?: SortOrder
    nama_supplier?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_supplier?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    id?: SortOrder
    nama_supplier?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GawanganRelationFilter = {
    is?: gawanganWhereInput
    isNot?: gawanganWhereInput
  }

  export type detail_gawanganCountOrderByAggregateInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_gawanganAvgOrderByAggregateInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_gawanganMaxOrderByAggregateInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_gawanganMinOrderByAggregateInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
  }

  export type detail_gawanganSumOrderByAggregateInput = {
    id?: SortOrder
    gawangan_id?: SortOrder
    produk_item_id?: SortOrder
    jumlah?: SortOrder
  }

  export type OutletRelationFilter = {
    is?: outletWhereInput
    isNot?: outletWhereInput
  }

  export type gawanganCountOrderByAggregateInput = {
    id?: SortOrder
    nama_gawangan?: SortOrder
    outlet_id?: SortOrder
  }

  export type gawanganAvgOrderByAggregateInput = {
    id?: SortOrder
    outlet_id?: SortOrder
  }

  export type gawanganMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_gawangan?: SortOrder
    outlet_id?: SortOrder
  }

  export type gawanganMinOrderByAggregateInput = {
    id?: SortOrder
    nama_gawangan?: SortOrder
    outlet_id?: SortOrder
  }

  export type gawanganSumOrderByAggregateInput = {
    id?: SortOrder
    outlet_id?: SortOrder
  }

  export type GawanganListRelationFilter = {
    every?: gawanganWhereInput
    some?: gawanganWhereInput
    none?: gawanganWhereInput
  }

  export type gawanganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type outletCountOrderByAggregateInput = {
    id?: SortOrder
    nama_outlet?: SortOrder
    alamat?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type outletAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type outletMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_outlet?: SortOrder
    alamat?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type outletMinOrderByAggregateInput = {
    id?: SortOrder
    nama_outlet?: SortOrder
    alamat?: SortOrder
    nama_pic?: SortOrder
    kontak_pic?: SortOrder
  }

  export type outletSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type pembelian_produkCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pembelian?: SortOrder
    nama_pembeli?: SortOrder
    kontak_pembeli?: SortOrder
    user_id?: SortOrder
  }

  export type pembelian_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type pembelian_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pembelian?: SortOrder
    nama_pembeli?: SortOrder
    kontak_pembeli?: SortOrder
    user_id?: SortOrder
  }

  export type pembelian_produkMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pembelian?: SortOrder
    nama_pembeli?: SortOrder
    kontak_pembeli?: SortOrder
    user_id?: SortOrder
  }

  export type pembelian_produkSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Pembelian_produkListRelationFilter = {
    every?: pembelian_produkWhereInput
    some?: pembelian_produkWhereInput
    none?: pembelian_produkWhereInput
  }

  export type pembelian_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    nama_lengkap?: SortOrder
    kontak?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_lengkap?: SortOrder
    kontak?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    nama_lengkap?: SortOrder
    kontak?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiskonRelationFilter = {
    is?: diskonWhereInput
    isNot?: diskonWhereInput
  }

  export type Pembelian_produkRelationFilter = {
    is?: pembelian_produkWhereInput
    isNot?: pembelian_produkWhereInput
  }

  export type detail_pembelian_produkCountOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
  }

  export type detail_pembelian_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
  }

  export type detail_pembelian_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
  }

  export type detail_pembelian_produkMinOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
  }

  export type detail_pembelian_produkSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    gawangan_id?: SortOrder
  }

  export type EnumTipeDiskonFilter<$PrismaModel = never> = {
    equals?: $Enums.TipeDiskon | EnumTipeDiskonFieldRefInput<$PrismaModel>
    in?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    not?: NestedEnumTipeDiskonFilter<$PrismaModel> | $Enums.TipeDiskon
  }

  export type diskonCountOrderByAggregateInput = {
    id?: SortOrder
    nama_diskon?: SortOrder
    tipe_diskon?: SortOrder
    jumlah_diskon?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
  }

  export type diskonAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type diskonMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_diskon?: SortOrder
    tipe_diskon?: SortOrder
    jumlah_diskon?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
  }

  export type diskonMinOrderByAggregateInput = {
    id?: SortOrder
    nama_diskon?: SortOrder
    tipe_diskon?: SortOrder
    jumlah_diskon?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
  }

  export type diskonSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type EnumTipeDiskonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipeDiskon | EnumTipeDiskonFieldRefInput<$PrismaModel>
    in?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    not?: NestedEnumTipeDiskonWithAggregatesFilter<$PrismaModel> | $Enums.TipeDiskon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipeDiskonFilter<$PrismaModel>
    _max?: NestedEnumTipeDiskonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Produk_itemNullableRelationFilter = {
    is?: produk_itemWhereInput | null
    isNot?: produk_itemWhereInput | null
  }

  export type Pembelian_produkNullableRelationFilter = {
    is?: pembelian_produkWhereInput | null
    isNot?: pembelian_produkWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type detail_diskonCountOrderByAggregateInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type detail_diskonAvgOrderByAggregateInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type detail_diskonMaxOrderByAggregateInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type detail_diskonMinOrderByAggregateInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type detail_diskonSumOrderByAggregateInput = {
    id?: SortOrder
    diskon_id?: SortOrder
    produk_item_id?: SortOrder
    pembelian_produk_id?: SortOrder
    jumlah?: SortOrder
    jumlah_diskon?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type produksiCreateNestedOneWithoutProduk_itemInput = {
    create?: XOR<produksiCreateWithoutProduk_itemInput, produksiUncheckedCreateWithoutProduk_itemInput>
    connectOrCreate?: produksiCreateOrConnectWithoutProduk_itemInput
    connect?: produksiWhereUniqueInput
  }

  export type detail_diskonCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput> | detail_diskonCreateWithoutProduk_itemInput[] | detail_diskonUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutProduk_itemInput | detail_diskonCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_diskonCreateManyProduk_itemInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput> | detail_pengecekan_produkCreateWithoutProduk_itemInput[] | detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput | detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_pengecekan_produkCreateManyProduk_itemInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_gawanganCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput> | detail_gawanganCreateWithoutProduk_itemInput[] | detail_gawanganUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutProduk_itemInput | detail_gawanganCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_gawanganCreateManyProduk_itemInputEnvelope
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
  }

  export type detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput> | detail_pembelian_produkCreateWithoutProduk_itemInput[] | detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput | detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_pembelian_produkCreateManyProduk_itemInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput> | detail_diskonCreateWithoutProduk_itemInput[] | detail_diskonUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutProduk_itemInput | detail_diskonCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_diskonCreateManyProduk_itemInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput> | detail_pengecekan_produkCreateWithoutProduk_itemInput[] | detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput | detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_pengecekan_produkCreateManyProduk_itemInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput> | detail_gawanganCreateWithoutProduk_itemInput[] | detail_gawanganUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutProduk_itemInput | detail_gawanganCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_gawanganCreateManyProduk_itemInputEnvelope
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
  }

  export type detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput> | detail_pembelian_produkCreateWithoutProduk_itemInput[] | detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput | detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput[]
    createMany?: detail_pembelian_produkCreateManyProduk_itemInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type produksiUpdateOneRequiredWithoutProduk_itemNestedInput = {
    create?: XOR<produksiCreateWithoutProduk_itemInput, produksiUncheckedCreateWithoutProduk_itemInput>
    connectOrCreate?: produksiCreateOrConnectWithoutProduk_itemInput
    upsert?: produksiUpsertWithoutProduk_itemInput
    connect?: produksiWhereUniqueInput
    update?: XOR<XOR<produksiUpdateToOneWithWhereWithoutProduk_itemInput, produksiUpdateWithoutProduk_itemInput>, produksiUncheckedUpdateWithoutProduk_itemInput>
  }

  export type detail_diskonUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput> | detail_diskonCreateWithoutProduk_itemInput[] | detail_diskonUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutProduk_itemInput | detail_diskonCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutProduk_itemInput | detail_diskonUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_diskonCreateManyProduk_itemInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutProduk_itemInput | detail_diskonUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutProduk_itemInput | detail_diskonUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput> | detail_pengecekan_produkCreateWithoutProduk_itemInput[] | detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput | detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutProduk_itemInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_pengecekan_produkCreateManyProduk_itemInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutProduk_itemInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutProduk_itemInput | detail_pengecekan_produkUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type detail_gawanganUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput> | detail_gawanganCreateWithoutProduk_itemInput[] | detail_gawanganUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutProduk_itemInput | detail_gawanganCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_gawanganUpsertWithWhereUniqueWithoutProduk_itemInput | detail_gawanganUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_gawanganCreateManyProduk_itemInputEnvelope
    set?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    disconnect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    delete?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    update?: detail_gawanganUpdateWithWhereUniqueWithoutProduk_itemInput | detail_gawanganUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_gawanganUpdateManyWithWhereWithoutProduk_itemInput | detail_gawanganUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
  }

  export type detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput> | detail_pembelian_produkCreateWithoutProduk_itemInput[] | detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput | detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutProduk_itemInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_pembelian_produkCreateManyProduk_itemInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutProduk_itemInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutProduk_itemInput | detail_pembelian_produkUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput> | detail_diskonCreateWithoutProduk_itemInput[] | detail_diskonUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutProduk_itemInput | detail_diskonCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutProduk_itemInput | detail_diskonUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_diskonCreateManyProduk_itemInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutProduk_itemInput | detail_diskonUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutProduk_itemInput | detail_diskonUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput> | detail_pengecekan_produkCreateWithoutProduk_itemInput[] | detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput | detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutProduk_itemInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_pengecekan_produkCreateManyProduk_itemInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutProduk_itemInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutProduk_itemInput | detail_pengecekan_produkUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput> | detail_gawanganCreateWithoutProduk_itemInput[] | detail_gawanganUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutProduk_itemInput | detail_gawanganCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_gawanganUpsertWithWhereUniqueWithoutProduk_itemInput | detail_gawanganUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_gawanganCreateManyProduk_itemInputEnvelope
    set?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    disconnect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    delete?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    update?: detail_gawanganUpdateWithWhereUniqueWithoutProduk_itemInput | detail_gawanganUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_gawanganUpdateManyWithWhereWithoutProduk_itemInput | detail_gawanganUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput> | detail_pembelian_produkCreateWithoutProduk_itemInput[] | detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput | detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutProduk_itemInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutProduk_itemInput[]
    createMany?: detail_pembelian_produkCreateManyProduk_itemInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutProduk_itemInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutProduk_itemInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutProduk_itemInput | detail_pembelian_produkUpdateManyWithWhereWithoutProduk_itemInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type pembuatCreateNestedOneWithoutProduksiInput = {
    create?: XOR<pembuatCreateWithoutProduksiInput, pembuatUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: pembuatCreateOrConnectWithoutProduksiInput
    connect?: pembuatWhereUniqueInput
  }

  export type kategori_produkCreateNestedOneWithoutProduksiInput = {
    create?: XOR<kategori_produkCreateWithoutProduksiInput, kategori_produkUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: kategori_produkCreateOrConnectWithoutProduksiInput
    connect?: kategori_produkWhereUniqueInput
  }

  export type produk_itemCreateNestedManyWithoutProduksiInput = {
    create?: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput> | produk_itemCreateWithoutProduksiInput[] | produk_itemUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: produk_itemCreateOrConnectWithoutProduksiInput | produk_itemCreateOrConnectWithoutProduksiInput[]
    createMany?: produk_itemCreateManyProduksiInputEnvelope
    connect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
  }

  export type bahan_produksiCreateNestedManyWithoutProduksiInput = {
    create?: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput> | bahan_produksiCreateWithoutProduksiInput[] | bahan_produksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutProduksiInput | bahan_produksiCreateOrConnectWithoutProduksiInput[]
    createMany?: bahan_produksiCreateManyProduksiInputEnvelope
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
  }

  export type produk_itemUncheckedCreateNestedManyWithoutProduksiInput = {
    create?: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput> | produk_itemCreateWithoutProduksiInput[] | produk_itemUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: produk_itemCreateOrConnectWithoutProduksiInput | produk_itemCreateOrConnectWithoutProduksiInput[]
    createMany?: produk_itemCreateManyProduksiInputEnvelope
    connect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
  }

  export type bahan_produksiUncheckedCreateNestedManyWithoutProduksiInput = {
    create?: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput> | bahan_produksiCreateWithoutProduksiInput[] | bahan_produksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutProduksiInput | bahan_produksiCreateOrConnectWithoutProduksiInput[]
    createMany?: bahan_produksiCreateManyProduksiInputEnvelope
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type pembuatUpdateOneRequiredWithoutProduksiNestedInput = {
    create?: XOR<pembuatCreateWithoutProduksiInput, pembuatUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: pembuatCreateOrConnectWithoutProduksiInput
    upsert?: pembuatUpsertWithoutProduksiInput
    connect?: pembuatWhereUniqueInput
    update?: XOR<XOR<pembuatUpdateToOneWithWhereWithoutProduksiInput, pembuatUpdateWithoutProduksiInput>, pembuatUncheckedUpdateWithoutProduksiInput>
  }

  export type kategori_produkUpdateOneRequiredWithoutProduksiNestedInput = {
    create?: XOR<kategori_produkCreateWithoutProduksiInput, kategori_produkUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: kategori_produkCreateOrConnectWithoutProduksiInput
    upsert?: kategori_produkUpsertWithoutProduksiInput
    connect?: kategori_produkWhereUniqueInput
    update?: XOR<XOR<kategori_produkUpdateToOneWithWhereWithoutProduksiInput, kategori_produkUpdateWithoutProduksiInput>, kategori_produkUncheckedUpdateWithoutProduksiInput>
  }

  export type produk_itemUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput> | produk_itemCreateWithoutProduksiInput[] | produk_itemUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: produk_itemCreateOrConnectWithoutProduksiInput | produk_itemCreateOrConnectWithoutProduksiInput[]
    upsert?: produk_itemUpsertWithWhereUniqueWithoutProduksiInput | produk_itemUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: produk_itemCreateManyProduksiInputEnvelope
    set?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    disconnect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    delete?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    connect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    update?: produk_itemUpdateWithWhereUniqueWithoutProduksiInput | produk_itemUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: produk_itemUpdateManyWithWhereWithoutProduksiInput | produk_itemUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: produk_itemScalarWhereInput | produk_itemScalarWhereInput[]
  }

  export type bahan_produksiUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput> | bahan_produksiCreateWithoutProduksiInput[] | bahan_produksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutProduksiInput | bahan_produksiCreateOrConnectWithoutProduksiInput[]
    upsert?: bahan_produksiUpsertWithWhereUniqueWithoutProduksiInput | bahan_produksiUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: bahan_produksiCreateManyProduksiInputEnvelope
    set?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    disconnect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    delete?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    update?: bahan_produksiUpdateWithWhereUniqueWithoutProduksiInput | bahan_produksiUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: bahan_produksiUpdateManyWithWhereWithoutProduksiInput | bahan_produksiUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
  }

  export type produk_itemUncheckedUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput> | produk_itemCreateWithoutProduksiInput[] | produk_itemUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: produk_itemCreateOrConnectWithoutProduksiInput | produk_itemCreateOrConnectWithoutProduksiInput[]
    upsert?: produk_itemUpsertWithWhereUniqueWithoutProduksiInput | produk_itemUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: produk_itemCreateManyProduksiInputEnvelope
    set?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    disconnect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    delete?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    connect?: produk_itemWhereUniqueInput | produk_itemWhereUniqueInput[]
    update?: produk_itemUpdateWithWhereUniqueWithoutProduksiInput | produk_itemUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: produk_itemUpdateManyWithWhereWithoutProduksiInput | produk_itemUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: produk_itemScalarWhereInput | produk_itemScalarWhereInput[]
  }

  export type bahan_produksiUncheckedUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput> | bahan_produksiCreateWithoutProduksiInput[] | bahan_produksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutProduksiInput | bahan_produksiCreateOrConnectWithoutProduksiInput[]
    upsert?: bahan_produksiUpsertWithWhereUniqueWithoutProduksiInput | bahan_produksiUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: bahan_produksiCreateManyProduksiInputEnvelope
    set?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    disconnect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    delete?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    update?: bahan_produksiUpdateWithWhereUniqueWithoutProduksiInput | bahan_produksiUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: bahan_produksiUpdateManyWithWhereWithoutProduksiInput | bahan_produksiUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
  }

  export type produksiCreateNestedManyWithoutKategori_produkInput = {
    create?: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput> | produksiCreateWithoutKategori_produkInput[] | produksiUncheckedCreateWithoutKategori_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutKategori_produkInput | produksiCreateOrConnectWithoutKategori_produkInput[]
    createMany?: produksiCreateManyKategori_produkInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type produksiUncheckedCreateNestedManyWithoutKategori_produkInput = {
    create?: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput> | produksiCreateWithoutKategori_produkInput[] | produksiUncheckedCreateWithoutKategori_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutKategori_produkInput | produksiCreateOrConnectWithoutKategori_produkInput[]
    createMany?: produksiCreateManyKategori_produkInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type produksiUpdateManyWithoutKategori_produkNestedInput = {
    create?: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput> | produksiCreateWithoutKategori_produkInput[] | produksiUncheckedCreateWithoutKategori_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutKategori_produkInput | produksiCreateOrConnectWithoutKategori_produkInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutKategori_produkInput | produksiUpsertWithWhereUniqueWithoutKategori_produkInput[]
    createMany?: produksiCreateManyKategori_produkInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutKategori_produkInput | produksiUpdateWithWhereUniqueWithoutKategori_produkInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutKategori_produkInput | produksiUpdateManyWithWhereWithoutKategori_produkInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type produksiUncheckedUpdateManyWithoutKategori_produkNestedInput = {
    create?: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput> | produksiCreateWithoutKategori_produkInput[] | produksiUncheckedCreateWithoutKategori_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutKategori_produkInput | produksiCreateOrConnectWithoutKategori_produkInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutKategori_produkInput | produksiUpsertWithWhereUniqueWithoutKategori_produkInput[]
    createMany?: produksiCreateManyKategori_produkInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutKategori_produkInput | produksiUpdateWithWhereUniqueWithoutKategori_produkInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutKategori_produkInput | produksiUpdateManyWithWhereWithoutKategori_produkInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type produksiCreateNestedManyWithoutPembuatInput = {
    create?: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput> | produksiCreateWithoutPembuatInput[] | produksiUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutPembuatInput | produksiCreateOrConnectWithoutPembuatInput[]
    createMany?: produksiCreateManyPembuatInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type produksiUncheckedCreateNestedManyWithoutPembuatInput = {
    create?: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput> | produksiCreateWithoutPembuatInput[] | produksiUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutPembuatInput | produksiCreateOrConnectWithoutPembuatInput[]
    createMany?: produksiCreateManyPembuatInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type produksiUpdateManyWithoutPembuatNestedInput = {
    create?: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput> | produksiCreateWithoutPembuatInput[] | produksiUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutPembuatInput | produksiCreateOrConnectWithoutPembuatInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutPembuatInput | produksiUpsertWithWhereUniqueWithoutPembuatInput[]
    createMany?: produksiCreateManyPembuatInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutPembuatInput | produksiUpdateWithWhereUniqueWithoutPembuatInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutPembuatInput | produksiUpdateManyWithWhereWithoutPembuatInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type produksiUncheckedUpdateManyWithoutPembuatNestedInput = {
    create?: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput> | produksiCreateWithoutPembuatInput[] | produksiUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutPembuatInput | produksiCreateOrConnectWithoutPembuatInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutPembuatInput | produksiUpsertWithWhereUniqueWithoutPembuatInput[]
    createMany?: produksiCreateManyPembuatInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutPembuatInput | produksiUpdateWithWhereUniqueWithoutPembuatInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutPembuatInput | produksiUpdateManyWithWhereWithoutPembuatInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type produksiCreateNestedOneWithoutBahan_produksiInput = {
    create?: XOR<produksiCreateWithoutBahan_produksiInput, produksiUncheckedCreateWithoutBahan_produksiInput>
    connectOrCreate?: produksiCreateOrConnectWithoutBahan_produksiInput
    connect?: produksiWhereUniqueInput
  }

  export type stok_bahanCreateNestedOneWithoutBahan_produksiInput = {
    create?: XOR<stok_bahanCreateWithoutBahan_produksiInput, stok_bahanUncheckedCreateWithoutBahan_produksiInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutBahan_produksiInput
    connect?: stok_bahanWhereUniqueInput
  }

  export type produksiUpdateOneRequiredWithoutBahan_produksiNestedInput = {
    create?: XOR<produksiCreateWithoutBahan_produksiInput, produksiUncheckedCreateWithoutBahan_produksiInput>
    connectOrCreate?: produksiCreateOrConnectWithoutBahan_produksiInput
    upsert?: produksiUpsertWithoutBahan_produksiInput
    connect?: produksiWhereUniqueInput
    update?: XOR<XOR<produksiUpdateToOneWithWhereWithoutBahan_produksiInput, produksiUpdateWithoutBahan_produksiInput>, produksiUncheckedUpdateWithoutBahan_produksiInput>
  }

  export type stok_bahanUpdateOneRequiredWithoutBahan_produksiNestedInput = {
    create?: XOR<stok_bahanCreateWithoutBahan_produksiInput, stok_bahanUncheckedCreateWithoutBahan_produksiInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutBahan_produksiInput
    upsert?: stok_bahanUpsertWithoutBahan_produksiInput
    connect?: stok_bahanWhereUniqueInput
    update?: XOR<XOR<stok_bahanUpdateToOneWithWhereWithoutBahan_produksiInput, stok_bahanUpdateWithoutBahan_produksiInput>, stok_bahanUncheckedUpdateWithoutBahan_produksiInput>
  }

  export type bahan_produksiCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput> | bahan_produksiCreateWithoutStok_bahanInput[] | bahan_produksiUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutStok_bahanInput | bahan_produksiCreateOrConnectWithoutStok_bahanInput[]
    createMany?: bahan_produksiCreateManyStok_bahanInputEnvelope
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pengecekan_bahanCreateWithoutStok_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyStok_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pemesanan_bahanCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pemesanan_bahanCreateWithoutStok_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyStok_bahanInputEnvelope
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
  }

  export type bahan_produksiUncheckedCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput> | bahan_produksiCreateWithoutStok_bahanInput[] | bahan_produksiUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutStok_bahanInput | bahan_produksiCreateOrConnectWithoutStok_bahanInput[]
    createMany?: bahan_produksiCreateManyStok_bahanInputEnvelope
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pengecekan_bahanCreateWithoutStok_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyStok_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pemesanan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pemesanan_bahanCreateWithoutStok_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyStok_bahanInputEnvelope
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
  }

  export type bahan_produksiUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput> | bahan_produksiCreateWithoutStok_bahanInput[] | bahan_produksiUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutStok_bahanInput | bahan_produksiCreateOrConnectWithoutStok_bahanInput[]
    upsert?: bahan_produksiUpsertWithWhereUniqueWithoutStok_bahanInput | bahan_produksiUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: bahan_produksiCreateManyStok_bahanInputEnvelope
    set?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    disconnect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    delete?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    update?: bahan_produksiUpdateWithWhereUniqueWithoutStok_bahanInput | bahan_produksiUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: bahan_produksiUpdateManyWithWhereWithoutStok_bahanInput | bahan_produksiUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
  }

  export type detail_pengecekan_bahanUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pengecekan_bahanCreateWithoutStok_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyStok_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutStok_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type detail_pemesanan_bahanUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pemesanan_bahanCreateWithoutStok_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput[]
    upsert?: detail_pemesanan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput | detail_pemesanan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyStok_bahanInputEnvelope
    set?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    disconnect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    delete?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    update?: detail_pemesanan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput | detail_pemesanan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: detail_pemesanan_bahanUpdateManyWithWhereWithoutStok_bahanInput | detail_pemesanan_bahanUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
  }

  export type bahan_produksiUncheckedUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput> | bahan_produksiCreateWithoutStok_bahanInput[] | bahan_produksiUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: bahan_produksiCreateOrConnectWithoutStok_bahanInput | bahan_produksiCreateOrConnectWithoutStok_bahanInput[]
    upsert?: bahan_produksiUpsertWithWhereUniqueWithoutStok_bahanInput | bahan_produksiUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: bahan_produksiCreateManyStok_bahanInputEnvelope
    set?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    disconnect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    delete?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    connect?: bahan_produksiWhereUniqueInput | bahan_produksiWhereUniqueInput[]
    update?: bahan_produksiUpdateWithWhereUniqueWithoutStok_bahanInput | bahan_produksiUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: bahan_produksiUpdateManyWithWhereWithoutStok_bahanInput | bahan_produksiUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pengecekan_bahanCreateWithoutStok_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyStok_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutStok_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput> | detail_pemesanan_bahanCreateWithoutStok_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput[]
    upsert?: detail_pemesanan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput | detail_pemesanan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyStok_bahanInputEnvelope
    set?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    disconnect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    delete?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    update?: detail_pemesanan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput | detail_pemesanan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput[]
    updateMany?: detail_pemesanan_bahanUpdateManyWithWhereWithoutStok_bahanInput | detail_pemesanan_bahanUpdateManyWithWhereWithoutStok_bahanInput[]
    deleteMany?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
  }

  export type pengecekan_produkCreateNestedOneWithoutDetail_pengecekan_produkInput = {
    create?: XOR<pengecekan_produkCreateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: pengecekan_produkCreateOrConnectWithoutDetail_pengecekan_produkInput
    connect?: pengecekan_produkWhereUniqueInput
  }

  export type produk_itemCreateNestedOneWithoutDetail_pengecekan_produkInput = {
    create?: XOR<produk_itemCreateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_pengecekan_produkInput
    connect?: produk_itemWhereUniqueInput
  }

  export type kondisi_produkCreateNestedOneWithoutDetail_pengecekan_produkInput = {
    create?: XOR<kondisi_produkCreateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: kondisi_produkCreateOrConnectWithoutDetail_pengecekan_produkInput
    connect?: kondisi_produkWhereUniqueInput
  }

  export type pengecekan_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput = {
    create?: XOR<pengecekan_produkCreateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: pengecekan_produkCreateOrConnectWithoutDetail_pengecekan_produkInput
    upsert?: pengecekan_produkUpsertWithoutDetail_pengecekan_produkInput
    connect?: pengecekan_produkWhereUniqueInput
    update?: XOR<XOR<pengecekan_produkUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput, pengecekan_produkUpdateWithoutDetail_pengecekan_produkInput>, pengecekan_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type produk_itemUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput = {
    create?: XOR<produk_itemCreateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_pengecekan_produkInput
    upsert?: produk_itemUpsertWithoutDetail_pengecekan_produkInput
    connect?: produk_itemWhereUniqueInput
    update?: XOR<XOR<produk_itemUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput, produk_itemUpdateWithoutDetail_pengecekan_produkInput>, produk_itemUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type kondisi_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput = {
    create?: XOR<kondisi_produkCreateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    connectOrCreate?: kondisi_produkCreateOrConnectWithoutDetail_pengecekan_produkInput
    upsert?: kondisi_produkUpsertWithoutDetail_pengecekan_produkInput
    connect?: kondisi_produkWhereUniqueInput
    update?: XOR<XOR<kondisi_produkUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput, kondisi_produkUpdateWithoutDetail_pengecekan_produkInput>, kondisi_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type detail_pengecekan_produkCreateNestedManyWithoutPengecekan_produkInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput> | detail_pengecekan_produkCreateWithoutPengecekan_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput | detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyPengecekan_produkInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_pengecekan_produkUncheckedCreateNestedManyWithoutPengecekan_produkInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput> | detail_pengecekan_produkCreateWithoutPengecekan_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput | detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyPengecekan_produkInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_pengecekan_produkUpdateManyWithoutPengecekan_produkNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput> | detail_pengecekan_produkCreateWithoutPengecekan_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput | detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutPengecekan_produkInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutPengecekan_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyPengecekan_produkInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutPengecekan_produkInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutPengecekan_produkInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutPengecekan_produkInput | detail_pengecekan_produkUpdateManyWithWhereWithoutPengecekan_produkInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutPengecekan_produkNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput> | detail_pengecekan_produkCreateWithoutPengecekan_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput | detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutPengecekan_produkInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutPengecekan_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyPengecekan_produkInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutPengecekan_produkInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutPengecekan_produkInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutPengecekan_produkInput | detail_pengecekan_produkUpdateManyWithWhereWithoutPengecekan_produkInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type detail_pengecekan_produkCreateNestedManyWithoutKondisi_produkInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput> | detail_pengecekan_produkCreateWithoutKondisi_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput | detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyKondisi_produkInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_pengecekan_produkUncheckedCreateNestedManyWithoutKondisi_produkInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput> | detail_pengecekan_produkCreateWithoutKondisi_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput | detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyKondisi_produkInputEnvelope
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
  }

  export type detail_pengecekan_produkUpdateManyWithoutKondisi_produkNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput> | detail_pengecekan_produkCreateWithoutKondisi_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput | detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutKondisi_produkInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutKondisi_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyKondisi_produkInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutKondisi_produkInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutKondisi_produkInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutKondisi_produkInput | detail_pengecekan_produkUpdateManyWithWhereWithoutKondisi_produkInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutKondisi_produkNestedInput = {
    create?: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput> | detail_pengecekan_produkCreateWithoutKondisi_produkInput[] | detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput[]
    connectOrCreate?: detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput | detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput[]
    upsert?: detail_pengecekan_produkUpsertWithWhereUniqueWithoutKondisi_produkInput | detail_pengecekan_produkUpsertWithWhereUniqueWithoutKondisi_produkInput[]
    createMany?: detail_pengecekan_produkCreateManyKondisi_produkInputEnvelope
    set?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    disconnect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    delete?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    connect?: detail_pengecekan_produkWhereUniqueInput | detail_pengecekan_produkWhereUniqueInput[]
    update?: detail_pengecekan_produkUpdateWithWhereUniqueWithoutKondisi_produkInput | detail_pengecekan_produkUpdateWithWhereUniqueWithoutKondisi_produkInput[]
    updateMany?: detail_pengecekan_produkUpdateManyWithWhereWithoutKondisi_produkInput | detail_pengecekan_produkUpdateManyWithWhereWithoutKondisi_produkInput[]
    deleteMany?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
  }

  export type pengecekan_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput = {
    create?: XOR<pengecekan_bahanCreateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: pengecekan_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    connect?: pengecekan_bahanWhereUniqueInput
  }

  export type stok_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput = {
    create?: XOR<stok_bahanCreateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    connect?: stok_bahanWhereUniqueInput
  }

  export type kondisi_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput = {
    create?: XOR<kondisi_bahanCreateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: kondisi_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    connect?: kondisi_bahanWhereUniqueInput
  }

  export type pengecekan_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput = {
    create?: XOR<pengecekan_bahanCreateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: pengecekan_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    upsert?: pengecekan_bahanUpsertWithoutDetail_pengecekan_bahanInput
    connect?: pengecekan_bahanWhereUniqueInput
    update?: XOR<XOR<pengecekan_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUpdateWithoutDetail_pengecekan_bahanInput>, pengecekan_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type stok_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput = {
    create?: XOR<stok_bahanCreateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    upsert?: stok_bahanUpsertWithoutDetail_pengecekan_bahanInput
    connect?: stok_bahanWhereUniqueInput
    update?: XOR<XOR<stok_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput, stok_bahanUpdateWithoutDetail_pengecekan_bahanInput>, stok_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type kondisi_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput = {
    create?: XOR<kondisi_bahanCreateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    connectOrCreate?: kondisi_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput
    upsert?: kondisi_bahanUpsertWithoutDetail_pengecekan_bahanInput
    connect?: kondisi_bahanWhereUniqueInput
    update?: XOR<XOR<kondisi_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput, kondisi_bahanUpdateWithoutDetail_pengecekan_bahanInput>, kondisi_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type detail_pengecekan_bahanCreateNestedManyWithoutPengecekan_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput> | detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyPengecekan_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanUncheckedCreateNestedManyWithoutPengecekan_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput> | detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyPengecekan_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanUpdateManyWithoutPengecekan_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput> | detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutPengecekan_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyPengecekan_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutPengecekan_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutPengecekan_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutPengecekan_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput> | detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutPengecekan_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyPengecekan_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutPengecekan_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutPengecekan_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutPengecekan_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type detail_pengecekan_bahanCreateNestedManyWithoutKondisi_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput> | detail_pengecekan_bahanCreateWithoutKondisi_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyKondisi_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanUncheckedCreateNestedManyWithoutKondisi_bahanInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput> | detail_pengecekan_bahanCreateWithoutKondisi_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyKondisi_bahanInputEnvelope
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
  }

  export type detail_pengecekan_bahanUpdateManyWithoutKondisi_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput> | detail_pengecekan_bahanCreateWithoutKondisi_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutKondisi_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutKondisi_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyKondisi_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutKondisi_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutKondisi_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutKondisi_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutKondisi_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutKondisi_bahanNestedInput = {
    create?: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput> | detail_pengecekan_bahanCreateWithoutKondisi_bahanInput[] | detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput[]
    connectOrCreate?: detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput | detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput[]
    upsert?: detail_pengecekan_bahanUpsertWithWhereUniqueWithoutKondisi_bahanInput | detail_pengecekan_bahanUpsertWithWhereUniqueWithoutKondisi_bahanInput[]
    createMany?: detail_pengecekan_bahanCreateManyKondisi_bahanInputEnvelope
    set?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    disconnect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    delete?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    connect?: detail_pengecekan_bahanWhereUniqueInput | detail_pengecekan_bahanWhereUniqueInput[]
    update?: detail_pengecekan_bahanUpdateWithWhereUniqueWithoutKondisi_bahanInput | detail_pengecekan_bahanUpdateWithWhereUniqueWithoutKondisi_bahanInput[]
    updateMany?: detail_pengecekan_bahanUpdateManyWithWhereWithoutKondisi_bahanInput | detail_pengecekan_bahanUpdateManyWithWhereWithoutKondisi_bahanInput[]
    deleteMany?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
  }

  export type pemesanan_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput = {
    create?: XOR<pemesanan_bahanCreateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput
    connect?: pemesanan_bahanWhereUniqueInput
  }

  export type stok_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput = {
    create?: XOR<stok_bahanCreateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput
    connect?: stok_bahanWhereUniqueInput
  }

  export type pemesanan_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput = {
    create?: XOR<pemesanan_bahanCreateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput
    upsert?: pemesanan_bahanUpsertWithoutDetail_pemesanan_bahanInput
    connect?: pemesanan_bahanWhereUniqueInput
    update?: XOR<XOR<pemesanan_bahanUpdateToOneWithWhereWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUpdateWithoutDetail_pemesanan_bahanInput>, pemesanan_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
  }

  export type stok_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput = {
    create?: XOR<stok_bahanCreateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    connectOrCreate?: stok_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput
    upsert?: stok_bahanUpsertWithoutDetail_pemesanan_bahanInput
    connect?: stok_bahanWhereUniqueInput
    update?: XOR<XOR<stok_bahanUpdateToOneWithWhereWithoutDetail_pemesanan_bahanInput, stok_bahanUpdateWithoutDetail_pemesanan_bahanInput>, stok_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
  }

  export type supplierCreateNestedOneWithoutPemesanan_bahanInput = {
    create?: XOR<supplierCreateWithoutPemesanan_bahanInput, supplierUncheckedCreateWithoutPemesanan_bahanInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPemesanan_bahanInput
    connect?: supplierWhereUniqueInput
  }

  export type detail_pemesanan_bahanCreateNestedManyWithoutPemesanan_bahanInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput> | detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyPemesanan_bahanInputEnvelope
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
  }

  export type detail_pemesanan_bahanUncheckedCreateNestedManyWithoutPemesanan_bahanInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput> | detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyPemesanan_bahanInputEnvelope
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
  }

  export type supplierUpdateOneRequiredWithoutPemesanan_bahanNestedInput = {
    create?: XOR<supplierCreateWithoutPemesanan_bahanInput, supplierUncheckedCreateWithoutPemesanan_bahanInput>
    connectOrCreate?: supplierCreateOrConnectWithoutPemesanan_bahanInput
    upsert?: supplierUpsertWithoutPemesanan_bahanInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutPemesanan_bahanInput, supplierUpdateWithoutPemesanan_bahanInput>, supplierUncheckedUpdateWithoutPemesanan_bahanInput>
  }

  export type detail_pemesanan_bahanUpdateManyWithoutPemesanan_bahanNestedInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput> | detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput[]
    upsert?: detail_pemesanan_bahanUpsertWithWhereUniqueWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpsertWithWhereUniqueWithoutPemesanan_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyPemesanan_bahanInputEnvelope
    set?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    disconnect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    delete?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    update?: detail_pemesanan_bahanUpdateWithWhereUniqueWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpdateWithWhereUniqueWithoutPemesanan_bahanInput[]
    updateMany?: detail_pemesanan_bahanUpdateManyWithWhereWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpdateManyWithWhereWithoutPemesanan_bahanInput[]
    deleteMany?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
  }

  export type detail_pemesanan_bahanUncheckedUpdateManyWithoutPemesanan_bahanNestedInput = {
    create?: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput> | detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput[] | detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput[]
    connectOrCreate?: detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput | detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput[]
    upsert?: detail_pemesanan_bahanUpsertWithWhereUniqueWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpsertWithWhereUniqueWithoutPemesanan_bahanInput[]
    createMany?: detail_pemesanan_bahanCreateManyPemesanan_bahanInputEnvelope
    set?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    disconnect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    delete?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    connect?: detail_pemesanan_bahanWhereUniqueInput | detail_pemesanan_bahanWhereUniqueInput[]
    update?: detail_pemesanan_bahanUpdateWithWhereUniqueWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpdateWithWhereUniqueWithoutPemesanan_bahanInput[]
    updateMany?: detail_pemesanan_bahanUpdateManyWithWhereWithoutPemesanan_bahanInput | detail_pemesanan_bahanUpdateManyWithWhereWithoutPemesanan_bahanInput[]
    deleteMany?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
  }

  export type pemesanan_bahanCreateNestedManyWithoutSupplierInput = {
    create?: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput> | pemesanan_bahanCreateWithoutSupplierInput[] | pemesanan_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutSupplierInput | pemesanan_bahanCreateOrConnectWithoutSupplierInput[]
    createMany?: pemesanan_bahanCreateManySupplierInputEnvelope
    connect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
  }

  export type pemesanan_bahanUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput> | pemesanan_bahanCreateWithoutSupplierInput[] | pemesanan_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutSupplierInput | pemesanan_bahanCreateOrConnectWithoutSupplierInput[]
    createMany?: pemesanan_bahanCreateManySupplierInputEnvelope
    connect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
  }

  export type pemesanan_bahanUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput> | pemesanan_bahanCreateWithoutSupplierInput[] | pemesanan_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutSupplierInput | pemesanan_bahanCreateOrConnectWithoutSupplierInput[]
    upsert?: pemesanan_bahanUpsertWithWhereUniqueWithoutSupplierInput | pemesanan_bahanUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: pemesanan_bahanCreateManySupplierInputEnvelope
    set?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    disconnect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    delete?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    connect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    update?: pemesanan_bahanUpdateWithWhereUniqueWithoutSupplierInput | pemesanan_bahanUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: pemesanan_bahanUpdateManyWithWhereWithoutSupplierInput | pemesanan_bahanUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: pemesanan_bahanScalarWhereInput | pemesanan_bahanScalarWhereInput[]
  }

  export type pemesanan_bahanUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput> | pemesanan_bahanCreateWithoutSupplierInput[] | pemesanan_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: pemesanan_bahanCreateOrConnectWithoutSupplierInput | pemesanan_bahanCreateOrConnectWithoutSupplierInput[]
    upsert?: pemesanan_bahanUpsertWithWhereUniqueWithoutSupplierInput | pemesanan_bahanUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: pemesanan_bahanCreateManySupplierInputEnvelope
    set?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    disconnect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    delete?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    connect?: pemesanan_bahanWhereUniqueInput | pemesanan_bahanWhereUniqueInput[]
    update?: pemesanan_bahanUpdateWithWhereUniqueWithoutSupplierInput | pemesanan_bahanUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: pemesanan_bahanUpdateManyWithWhereWithoutSupplierInput | pemesanan_bahanUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: pemesanan_bahanScalarWhereInput | pemesanan_bahanScalarWhereInput[]
  }

  export type gawanganCreateNestedOneWithoutDetail_gawangansInput = {
    create?: XOR<gawanganCreateWithoutDetail_gawangansInput, gawanganUncheckedCreateWithoutDetail_gawangansInput>
    connectOrCreate?: gawanganCreateOrConnectWithoutDetail_gawangansInput
    connect?: gawanganWhereUniqueInput
  }

  export type produk_itemCreateNestedOneWithoutDetail_gawanganInput = {
    create?: XOR<produk_itemCreateWithoutDetail_gawanganInput, produk_itemUncheckedCreateWithoutDetail_gawanganInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_gawanganInput
    connect?: produk_itemWhereUniqueInput
  }

  export type gawanganUpdateOneRequiredWithoutDetail_gawangansNestedInput = {
    create?: XOR<gawanganCreateWithoutDetail_gawangansInput, gawanganUncheckedCreateWithoutDetail_gawangansInput>
    connectOrCreate?: gawanganCreateOrConnectWithoutDetail_gawangansInput
    upsert?: gawanganUpsertWithoutDetail_gawangansInput
    connect?: gawanganWhereUniqueInput
    update?: XOR<XOR<gawanganUpdateToOneWithWhereWithoutDetail_gawangansInput, gawanganUpdateWithoutDetail_gawangansInput>, gawanganUncheckedUpdateWithoutDetail_gawangansInput>
  }

  export type produk_itemUpdateOneRequiredWithoutDetail_gawanganNestedInput = {
    create?: XOR<produk_itemCreateWithoutDetail_gawanganInput, produk_itemUncheckedCreateWithoutDetail_gawanganInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_gawanganInput
    upsert?: produk_itemUpsertWithoutDetail_gawanganInput
    connect?: produk_itemWhereUniqueInput
    update?: XOR<XOR<produk_itemUpdateToOneWithWhereWithoutDetail_gawanganInput, produk_itemUpdateWithoutDetail_gawanganInput>, produk_itemUncheckedUpdateWithoutDetail_gawanganInput>
  }

  export type outletCreateNestedOneWithoutGawanganInput = {
    create?: XOR<outletCreateWithoutGawanganInput, outletUncheckedCreateWithoutGawanganInput>
    connectOrCreate?: outletCreateOrConnectWithoutGawanganInput
    connect?: outletWhereUniqueInput
  }

  export type detail_gawanganCreateNestedManyWithoutGawanganInput = {
    create?: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput> | detail_gawanganCreateWithoutGawanganInput[] | detail_gawanganUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutGawanganInput | detail_gawanganCreateOrConnectWithoutGawanganInput[]
    createMany?: detail_gawanganCreateManyGawanganInputEnvelope
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
  }

  export type detail_pembelian_produkCreateNestedManyWithoutGawanganInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput> | detail_pembelian_produkCreateWithoutGawanganInput[] | detail_pembelian_produkUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutGawanganInput | detail_pembelian_produkCreateOrConnectWithoutGawanganInput[]
    createMany?: detail_pembelian_produkCreateManyGawanganInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type detail_gawanganUncheckedCreateNestedManyWithoutGawanganInput = {
    create?: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput> | detail_gawanganCreateWithoutGawanganInput[] | detail_gawanganUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutGawanganInput | detail_gawanganCreateOrConnectWithoutGawanganInput[]
    createMany?: detail_gawanganCreateManyGawanganInputEnvelope
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
  }

  export type detail_pembelian_produkUncheckedCreateNestedManyWithoutGawanganInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput> | detail_pembelian_produkCreateWithoutGawanganInput[] | detail_pembelian_produkUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutGawanganInput | detail_pembelian_produkCreateOrConnectWithoutGawanganInput[]
    createMany?: detail_pembelian_produkCreateManyGawanganInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type outletUpdateOneRequiredWithoutGawanganNestedInput = {
    create?: XOR<outletCreateWithoutGawanganInput, outletUncheckedCreateWithoutGawanganInput>
    connectOrCreate?: outletCreateOrConnectWithoutGawanganInput
    upsert?: outletUpsertWithoutGawanganInput
    connect?: outletWhereUniqueInput
    update?: XOR<XOR<outletUpdateToOneWithWhereWithoutGawanganInput, outletUpdateWithoutGawanganInput>, outletUncheckedUpdateWithoutGawanganInput>
  }

  export type detail_gawanganUpdateManyWithoutGawanganNestedInput = {
    create?: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput> | detail_gawanganCreateWithoutGawanganInput[] | detail_gawanganUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutGawanganInput | detail_gawanganCreateOrConnectWithoutGawanganInput[]
    upsert?: detail_gawanganUpsertWithWhereUniqueWithoutGawanganInput | detail_gawanganUpsertWithWhereUniqueWithoutGawanganInput[]
    createMany?: detail_gawanganCreateManyGawanganInputEnvelope
    set?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    disconnect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    delete?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    update?: detail_gawanganUpdateWithWhereUniqueWithoutGawanganInput | detail_gawanganUpdateWithWhereUniqueWithoutGawanganInput[]
    updateMany?: detail_gawanganUpdateManyWithWhereWithoutGawanganInput | detail_gawanganUpdateManyWithWhereWithoutGawanganInput[]
    deleteMany?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
  }

  export type detail_pembelian_produkUpdateManyWithoutGawanganNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput> | detail_pembelian_produkCreateWithoutGawanganInput[] | detail_pembelian_produkUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutGawanganInput | detail_pembelian_produkCreateOrConnectWithoutGawanganInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutGawanganInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutGawanganInput[]
    createMany?: detail_pembelian_produkCreateManyGawanganInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutGawanganInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutGawanganInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutGawanganInput | detail_pembelian_produkUpdateManyWithWhereWithoutGawanganInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type detail_gawanganUncheckedUpdateManyWithoutGawanganNestedInput = {
    create?: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput> | detail_gawanganCreateWithoutGawanganInput[] | detail_gawanganUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_gawanganCreateOrConnectWithoutGawanganInput | detail_gawanganCreateOrConnectWithoutGawanganInput[]
    upsert?: detail_gawanganUpsertWithWhereUniqueWithoutGawanganInput | detail_gawanganUpsertWithWhereUniqueWithoutGawanganInput[]
    createMany?: detail_gawanganCreateManyGawanganInputEnvelope
    set?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    disconnect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    delete?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    connect?: detail_gawanganWhereUniqueInput | detail_gawanganWhereUniqueInput[]
    update?: detail_gawanganUpdateWithWhereUniqueWithoutGawanganInput | detail_gawanganUpdateWithWhereUniqueWithoutGawanganInput[]
    updateMany?: detail_gawanganUpdateManyWithWhereWithoutGawanganInput | detail_gawanganUpdateManyWithWhereWithoutGawanganInput[]
    deleteMany?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutGawanganNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput> | detail_pembelian_produkCreateWithoutGawanganInput[] | detail_pembelian_produkUncheckedCreateWithoutGawanganInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutGawanganInput | detail_pembelian_produkCreateOrConnectWithoutGawanganInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutGawanganInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutGawanganInput[]
    createMany?: detail_pembelian_produkCreateManyGawanganInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutGawanganInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutGawanganInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutGawanganInput | detail_pembelian_produkUpdateManyWithWhereWithoutGawanganInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type gawanganCreateNestedManyWithoutOutletInput = {
    create?: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput> | gawanganCreateWithoutOutletInput[] | gawanganUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: gawanganCreateOrConnectWithoutOutletInput | gawanganCreateOrConnectWithoutOutletInput[]
    createMany?: gawanganCreateManyOutletInputEnvelope
    connect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
  }

  export type gawanganUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput> | gawanganCreateWithoutOutletInput[] | gawanganUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: gawanganCreateOrConnectWithoutOutletInput | gawanganCreateOrConnectWithoutOutletInput[]
    createMany?: gawanganCreateManyOutletInputEnvelope
    connect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
  }

  export type gawanganUpdateManyWithoutOutletNestedInput = {
    create?: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput> | gawanganCreateWithoutOutletInput[] | gawanganUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: gawanganCreateOrConnectWithoutOutletInput | gawanganCreateOrConnectWithoutOutletInput[]
    upsert?: gawanganUpsertWithWhereUniqueWithoutOutletInput | gawanganUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: gawanganCreateManyOutletInputEnvelope
    set?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    disconnect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    delete?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    connect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    update?: gawanganUpdateWithWhereUniqueWithoutOutletInput | gawanganUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: gawanganUpdateManyWithWhereWithoutOutletInput | gawanganUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: gawanganScalarWhereInput | gawanganScalarWhereInput[]
  }

  export type gawanganUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput> | gawanganCreateWithoutOutletInput[] | gawanganUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: gawanganCreateOrConnectWithoutOutletInput | gawanganCreateOrConnectWithoutOutletInput[]
    upsert?: gawanganUpsertWithWhereUniqueWithoutOutletInput | gawanganUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: gawanganCreateManyOutletInputEnvelope
    set?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    disconnect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    delete?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    connect?: gawanganWhereUniqueInput | gawanganWhereUniqueInput[]
    update?: gawanganUpdateWithWhereUniqueWithoutOutletInput | gawanganUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: gawanganUpdateManyWithWhereWithoutOutletInput | gawanganUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: gawanganScalarWhereInput | gawanganScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutPembelian_produkInput = {
    create?: XOR<userCreateWithoutPembelian_produkInput, userUncheckedCreateWithoutPembelian_produkInput>
    connectOrCreate?: userCreateOrConnectWithoutPembelian_produkInput
    connect?: userWhereUniqueInput
  }

  export type detail_diskonCreateNestedManyWithoutPembelian_produkInput = {
    create?: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput> | detail_diskonCreateWithoutPembelian_produkInput[] | detail_diskonUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutPembelian_produkInput | detail_diskonCreateOrConnectWithoutPembelian_produkInput[]
    createMany?: detail_diskonCreateManyPembelian_produkInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type detail_pembelian_produkCreateNestedManyWithoutPembelian_produkInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput> | detail_pembelian_produkCreateWithoutPembelian_produkInput[] | detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput | detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput[]
    createMany?: detail_pembelian_produkCreateManyPembelian_produkInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type detail_diskonUncheckedCreateNestedManyWithoutPembelian_produkInput = {
    create?: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput> | detail_diskonCreateWithoutPembelian_produkInput[] | detail_diskonUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutPembelian_produkInput | detail_diskonCreateOrConnectWithoutPembelian_produkInput[]
    createMany?: detail_diskonCreateManyPembelian_produkInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type detail_pembelian_produkUncheckedCreateNestedManyWithoutPembelian_produkInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput> | detail_pembelian_produkCreateWithoutPembelian_produkInput[] | detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput | detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput[]
    createMany?: detail_pembelian_produkCreateManyPembelian_produkInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutPembelian_produkNestedInput = {
    create?: XOR<userCreateWithoutPembelian_produkInput, userUncheckedCreateWithoutPembelian_produkInput>
    connectOrCreate?: userCreateOrConnectWithoutPembelian_produkInput
    upsert?: userUpsertWithoutPembelian_produkInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPembelian_produkInput, userUpdateWithoutPembelian_produkInput>, userUncheckedUpdateWithoutPembelian_produkInput>
  }

  export type detail_diskonUpdateManyWithoutPembelian_produkNestedInput = {
    create?: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput> | detail_diskonCreateWithoutPembelian_produkInput[] | detail_diskonUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutPembelian_produkInput | detail_diskonCreateOrConnectWithoutPembelian_produkInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutPembelian_produkInput | detail_diskonUpsertWithWhereUniqueWithoutPembelian_produkInput[]
    createMany?: detail_diskonCreateManyPembelian_produkInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutPembelian_produkInput | detail_diskonUpdateWithWhereUniqueWithoutPembelian_produkInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutPembelian_produkInput | detail_diskonUpdateManyWithWhereWithoutPembelian_produkInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type detail_pembelian_produkUpdateManyWithoutPembelian_produkNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput> | detail_pembelian_produkCreateWithoutPembelian_produkInput[] | detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput | detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutPembelian_produkInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutPembelian_produkInput[]
    createMany?: detail_pembelian_produkCreateManyPembelian_produkInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutPembelian_produkInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutPembelian_produkInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutPembelian_produkInput | detail_pembelian_produkUpdateManyWithWhereWithoutPembelian_produkInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type detail_diskonUncheckedUpdateManyWithoutPembelian_produkNestedInput = {
    create?: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput> | detail_diskonCreateWithoutPembelian_produkInput[] | detail_diskonUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutPembelian_produkInput | detail_diskonCreateOrConnectWithoutPembelian_produkInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutPembelian_produkInput | detail_diskonUpsertWithWhereUniqueWithoutPembelian_produkInput[]
    createMany?: detail_diskonCreateManyPembelian_produkInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutPembelian_produkInput | detail_diskonUpdateWithWhereUniqueWithoutPembelian_produkInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutPembelian_produkInput | detail_diskonUpdateManyWithWhereWithoutPembelian_produkInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput> | detail_pembelian_produkCreateWithoutPembelian_produkInput[] | detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput | detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutPembelian_produkInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutPembelian_produkInput[]
    createMany?: detail_pembelian_produkCreateManyPembelian_produkInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutPembelian_produkInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutPembelian_produkInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutPembelian_produkInput | detail_pembelian_produkUpdateManyWithWhereWithoutPembelian_produkInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type pembelian_produkCreateNestedManyWithoutUserInput = {
    create?: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput> | pembelian_produkCreateWithoutUserInput[] | pembelian_produkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutUserInput | pembelian_produkCreateOrConnectWithoutUserInput[]
    createMany?: pembelian_produkCreateManyUserInputEnvelope
    connect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
  }

  export type pembelian_produkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput> | pembelian_produkCreateWithoutUserInput[] | pembelian_produkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutUserInput | pembelian_produkCreateOrConnectWithoutUserInput[]
    createMany?: pembelian_produkCreateManyUserInputEnvelope
    connect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
  }

  export type pembelian_produkUpdateManyWithoutUserNestedInput = {
    create?: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput> | pembelian_produkCreateWithoutUserInput[] | pembelian_produkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutUserInput | pembelian_produkCreateOrConnectWithoutUserInput[]
    upsert?: pembelian_produkUpsertWithWhereUniqueWithoutUserInput | pembelian_produkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pembelian_produkCreateManyUserInputEnvelope
    set?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    disconnect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    delete?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    connect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    update?: pembelian_produkUpdateWithWhereUniqueWithoutUserInput | pembelian_produkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pembelian_produkUpdateManyWithWhereWithoutUserInput | pembelian_produkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pembelian_produkScalarWhereInput | pembelian_produkScalarWhereInput[]
  }

  export type pembelian_produkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput> | pembelian_produkCreateWithoutUserInput[] | pembelian_produkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutUserInput | pembelian_produkCreateOrConnectWithoutUserInput[]
    upsert?: pembelian_produkUpsertWithWhereUniqueWithoutUserInput | pembelian_produkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pembelian_produkCreateManyUserInputEnvelope
    set?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    disconnect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    delete?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    connect?: pembelian_produkWhereUniqueInput | pembelian_produkWhereUniqueInput[]
    update?: pembelian_produkUpdateWithWhereUniqueWithoutUserInput | pembelian_produkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pembelian_produkUpdateManyWithWhereWithoutUserInput | pembelian_produkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pembelian_produkScalarWhereInput | pembelian_produkScalarWhereInput[]
  }

  export type diskonCreateNestedOneWithoutDetail_pembelian_produkInput = {
    create?: XOR<diskonCreateWithoutDetail_pembelian_produkInput, diskonUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: diskonCreateOrConnectWithoutDetail_pembelian_produkInput
    connect?: diskonWhereUniqueInput
  }

  export type produk_itemCreateNestedOneWithoutDetail_pembelian_produkInput = {
    create?: XOR<produk_itemCreateWithoutDetail_pembelian_produkInput, produk_itemUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_pembelian_produkInput
    connect?: produk_itemWhereUniqueInput
  }

  export type pembelian_produkCreateNestedOneWithoutDetail_pembelian_produkInput = {
    create?: XOR<pembelian_produkCreateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutDetail_pembelian_produkInput
    connect?: pembelian_produkWhereUniqueInput
  }

  export type gawanganCreateNestedOneWithoutDetail_pembelian_produkInput = {
    create?: XOR<gawanganCreateWithoutDetail_pembelian_produkInput, gawanganUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: gawanganCreateOrConnectWithoutDetail_pembelian_produkInput
    connect?: gawanganWhereUniqueInput
  }

  export type diskonUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput = {
    create?: XOR<diskonCreateWithoutDetail_pembelian_produkInput, diskonUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: diskonCreateOrConnectWithoutDetail_pembelian_produkInput
    upsert?: diskonUpsertWithoutDetail_pembelian_produkInput
    connect?: diskonWhereUniqueInput
    update?: XOR<XOR<diskonUpdateToOneWithWhereWithoutDetail_pembelian_produkInput, diskonUpdateWithoutDetail_pembelian_produkInput>, diskonUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type produk_itemUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput = {
    create?: XOR<produk_itemCreateWithoutDetail_pembelian_produkInput, produk_itemUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_pembelian_produkInput
    upsert?: produk_itemUpsertWithoutDetail_pembelian_produkInput
    connect?: produk_itemWhereUniqueInput
    update?: XOR<XOR<produk_itemUpdateToOneWithWhereWithoutDetail_pembelian_produkInput, produk_itemUpdateWithoutDetail_pembelian_produkInput>, produk_itemUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type pembelian_produkUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput = {
    create?: XOR<pembelian_produkCreateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutDetail_pembelian_produkInput
    upsert?: pembelian_produkUpsertWithoutDetail_pembelian_produkInput
    connect?: pembelian_produkWhereUniqueInput
    update?: XOR<XOR<pembelian_produkUpdateToOneWithWhereWithoutDetail_pembelian_produkInput, pembelian_produkUpdateWithoutDetail_pembelian_produkInput>, pembelian_produkUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type gawanganUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput = {
    create?: XOR<gawanganCreateWithoutDetail_pembelian_produkInput, gawanganUncheckedCreateWithoutDetail_pembelian_produkInput>
    connectOrCreate?: gawanganCreateOrConnectWithoutDetail_pembelian_produkInput
    upsert?: gawanganUpsertWithoutDetail_pembelian_produkInput
    connect?: gawanganWhereUniqueInput
    update?: XOR<XOR<gawanganUpdateToOneWithWhereWithoutDetail_pembelian_produkInput, gawanganUpdateWithoutDetail_pembelian_produkInput>, gawanganUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type detail_pembelian_produkCreateNestedManyWithoutDiskonInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput> | detail_pembelian_produkCreateWithoutDiskonInput[] | detail_pembelian_produkUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutDiskonInput | detail_pembelian_produkCreateOrConnectWithoutDiskonInput[]
    createMany?: detail_pembelian_produkCreateManyDiskonInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type detail_diskonCreateNestedManyWithoutDiskonInput = {
    create?: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput> | detail_diskonCreateWithoutDiskonInput[] | detail_diskonUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutDiskonInput | detail_diskonCreateOrConnectWithoutDiskonInput[]
    createMany?: detail_diskonCreateManyDiskonInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type detail_pembelian_produkUncheckedCreateNestedManyWithoutDiskonInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput> | detail_pembelian_produkCreateWithoutDiskonInput[] | detail_pembelian_produkUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutDiskonInput | detail_pembelian_produkCreateOrConnectWithoutDiskonInput[]
    createMany?: detail_pembelian_produkCreateManyDiskonInputEnvelope
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
  }

  export type detail_diskonUncheckedCreateNestedManyWithoutDiskonInput = {
    create?: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput> | detail_diskonCreateWithoutDiskonInput[] | detail_diskonUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutDiskonInput | detail_diskonCreateOrConnectWithoutDiskonInput[]
    createMany?: detail_diskonCreateManyDiskonInputEnvelope
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
  }

  export type EnumTipeDiskonFieldUpdateOperationsInput = {
    set?: $Enums.TipeDiskon
  }

  export type detail_pembelian_produkUpdateManyWithoutDiskonNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput> | detail_pembelian_produkCreateWithoutDiskonInput[] | detail_pembelian_produkUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutDiskonInput | detail_pembelian_produkCreateOrConnectWithoutDiskonInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutDiskonInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutDiskonInput[]
    createMany?: detail_pembelian_produkCreateManyDiskonInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutDiskonInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutDiskonInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutDiskonInput | detail_pembelian_produkUpdateManyWithWhereWithoutDiskonInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type detail_diskonUpdateManyWithoutDiskonNestedInput = {
    create?: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput> | detail_diskonCreateWithoutDiskonInput[] | detail_diskonUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutDiskonInput | detail_diskonCreateOrConnectWithoutDiskonInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutDiskonInput | detail_diskonUpsertWithWhereUniqueWithoutDiskonInput[]
    createMany?: detail_diskonCreateManyDiskonInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutDiskonInput | detail_diskonUpdateWithWhereUniqueWithoutDiskonInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutDiskonInput | detail_diskonUpdateManyWithWhereWithoutDiskonInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutDiskonNestedInput = {
    create?: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput> | detail_pembelian_produkCreateWithoutDiskonInput[] | detail_pembelian_produkUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_pembelian_produkCreateOrConnectWithoutDiskonInput | detail_pembelian_produkCreateOrConnectWithoutDiskonInput[]
    upsert?: detail_pembelian_produkUpsertWithWhereUniqueWithoutDiskonInput | detail_pembelian_produkUpsertWithWhereUniqueWithoutDiskonInput[]
    createMany?: detail_pembelian_produkCreateManyDiskonInputEnvelope
    set?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    disconnect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    delete?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    connect?: detail_pembelian_produkWhereUniqueInput | detail_pembelian_produkWhereUniqueInput[]
    update?: detail_pembelian_produkUpdateWithWhereUniqueWithoutDiskonInput | detail_pembelian_produkUpdateWithWhereUniqueWithoutDiskonInput[]
    updateMany?: detail_pembelian_produkUpdateManyWithWhereWithoutDiskonInput | detail_pembelian_produkUpdateManyWithWhereWithoutDiskonInput[]
    deleteMany?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
  }

  export type detail_diskonUncheckedUpdateManyWithoutDiskonNestedInput = {
    create?: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput> | detail_diskonCreateWithoutDiskonInput[] | detail_diskonUncheckedCreateWithoutDiskonInput[]
    connectOrCreate?: detail_diskonCreateOrConnectWithoutDiskonInput | detail_diskonCreateOrConnectWithoutDiskonInput[]
    upsert?: detail_diskonUpsertWithWhereUniqueWithoutDiskonInput | detail_diskonUpsertWithWhereUniqueWithoutDiskonInput[]
    createMany?: detail_diskonCreateManyDiskonInputEnvelope
    set?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    disconnect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    delete?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    connect?: detail_diskonWhereUniqueInput | detail_diskonWhereUniqueInput[]
    update?: detail_diskonUpdateWithWhereUniqueWithoutDiskonInput | detail_diskonUpdateWithWhereUniqueWithoutDiskonInput[]
    updateMany?: detail_diskonUpdateManyWithWhereWithoutDiskonInput | detail_diskonUpdateManyWithWhereWithoutDiskonInput[]
    deleteMany?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
  }

  export type diskonCreateNestedOneWithoutDetail_diskonInput = {
    create?: XOR<diskonCreateWithoutDetail_diskonInput, diskonUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: diskonCreateOrConnectWithoutDetail_diskonInput
    connect?: diskonWhereUniqueInput
  }

  export type produk_itemCreateNestedOneWithoutDetail_diskonInput = {
    create?: XOR<produk_itemCreateWithoutDetail_diskonInput, produk_itemUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_diskonInput
    connect?: produk_itemWhereUniqueInput
  }

  export type pembelian_produkCreateNestedOneWithoutDetail_diskonInput = {
    create?: XOR<pembelian_produkCreateWithoutDetail_diskonInput, pembelian_produkUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutDetail_diskonInput
    connect?: pembelian_produkWhereUniqueInput
  }

  export type diskonUpdateOneRequiredWithoutDetail_diskonNestedInput = {
    create?: XOR<diskonCreateWithoutDetail_diskonInput, diskonUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: diskonCreateOrConnectWithoutDetail_diskonInput
    upsert?: diskonUpsertWithoutDetail_diskonInput
    connect?: diskonWhereUniqueInput
    update?: XOR<XOR<diskonUpdateToOneWithWhereWithoutDetail_diskonInput, diskonUpdateWithoutDetail_diskonInput>, diskonUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type produk_itemUpdateOneWithoutDetail_diskonNestedInput = {
    create?: XOR<produk_itemCreateWithoutDetail_diskonInput, produk_itemUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: produk_itemCreateOrConnectWithoutDetail_diskonInput
    upsert?: produk_itemUpsertWithoutDetail_diskonInput
    disconnect?: produk_itemWhereInput | boolean
    delete?: produk_itemWhereInput | boolean
    connect?: produk_itemWhereUniqueInput
    update?: XOR<XOR<produk_itemUpdateToOneWithWhereWithoutDetail_diskonInput, produk_itemUpdateWithoutDetail_diskonInput>, produk_itemUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type pembelian_produkUpdateOneWithoutDetail_diskonNestedInput = {
    create?: XOR<pembelian_produkCreateWithoutDetail_diskonInput, pembelian_produkUncheckedCreateWithoutDetail_diskonInput>
    connectOrCreate?: pembelian_produkCreateOrConnectWithoutDetail_diskonInput
    upsert?: pembelian_produkUpsertWithoutDetail_diskonInput
    disconnect?: pembelian_produkWhereInput | boolean
    delete?: pembelian_produkWhereInput | boolean
    connect?: pembelian_produkWhereUniqueInput
    update?: XOR<XOR<pembelian_produkUpdateToOneWithWhereWithoutDetail_diskonInput, pembelian_produkUpdateWithoutDetail_diskonInput>, pembelian_produkUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipeDiskonFilter<$PrismaModel = never> = {
    equals?: $Enums.TipeDiskon | EnumTipeDiskonFieldRefInput<$PrismaModel>
    in?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    not?: NestedEnumTipeDiskonFilter<$PrismaModel> | $Enums.TipeDiskon
  }

  export type NestedEnumTipeDiskonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipeDiskon | EnumTipeDiskonFieldRefInput<$PrismaModel>
    in?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipeDiskon[] | ListEnumTipeDiskonFieldRefInput<$PrismaModel>
    not?: NestedEnumTipeDiskonWithAggregatesFilter<$PrismaModel> | $Enums.TipeDiskon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipeDiskonFilter<$PrismaModel>
    _max?: NestedEnumTipeDiskonFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type produksiCreateWithoutProduk_itemInput = {
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat: pembuatCreateNestedOneWithoutProduksiInput
    kategori_produk: kategori_produkCreateNestedOneWithoutProduksiInput
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutProduk_itemInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutProduk_itemInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutProduk_itemInput, produksiUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_diskonCreateWithoutProduk_itemInput = {
    jumlah: number
    jumlah_diskon: number
    diskon: diskonCreateNestedOneWithoutDetail_diskonInput
    pembelian_produk?: pembelian_produkCreateNestedOneWithoutDetail_diskonInput
  }

  export type detail_diskonUncheckedCreateWithoutProduk_itemInput = {
    id?: number
    diskon_id: number
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_diskonCreateOrConnectWithoutProduk_itemInput = {
    where: detail_diskonWhereUniqueInput
    create: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_diskonCreateManyProduk_itemInputEnvelope = {
    data: detail_diskonCreateManyProduk_itemInput | detail_diskonCreateManyProduk_itemInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_produkCreateWithoutProduk_itemInput = {
    jumlah: number
    pengecekan_produk: pengecekan_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
    kondisi_produk: kondisi_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
  }

  export type detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput = {
    id?: number
    pengecekan_produk_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkCreateOrConnectWithoutProduk_itemInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    create: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_pengecekan_produkCreateManyProduk_itemInputEnvelope = {
    data: detail_pengecekan_produkCreateManyProduk_itemInput | detail_pengecekan_produkCreateManyProduk_itemInput[]
    skipDuplicates?: boolean
  }

  export type detail_gawanganCreateWithoutProduk_itemInput = {
    jumlah: number
    gawangan: gawanganCreateNestedOneWithoutDetail_gawangansInput
  }

  export type detail_gawanganUncheckedCreateWithoutProduk_itemInput = {
    id?: number
    gawangan_id: number
    jumlah: number
  }

  export type detail_gawanganCreateOrConnectWithoutProduk_itemInput = {
    where: detail_gawanganWhereUniqueInput
    create: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_gawanganCreateManyProduk_itemInputEnvelope = {
    data: detail_gawanganCreateManyProduk_itemInput | detail_gawanganCreateManyProduk_itemInput[]
    skipDuplicates?: boolean
  }

  export type detail_pembelian_produkCreateWithoutProduk_itemInput = {
    jumlah: number
    diskon: diskonCreateNestedOneWithoutDetail_pembelian_produkInput
    pembelian_produk: pembelian_produkCreateNestedOneWithoutDetail_pembelian_produkInput
    gawangan: gawanganCreateNestedOneWithoutDetail_pembelian_produkInput
  }

  export type detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput = {
    id?: number
    jumlah: number
    diskon_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_pembelian_produkCreateOrConnectWithoutProduk_itemInput = {
    where: detail_pembelian_produkWhereUniqueInput
    create: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_pembelian_produkCreateManyProduk_itemInputEnvelope = {
    data: detail_pembelian_produkCreateManyProduk_itemInput | detail_pembelian_produkCreateManyProduk_itemInput[]
    skipDuplicates?: boolean
  }

  export type produksiUpsertWithoutProduk_itemInput = {
    update: XOR<produksiUpdateWithoutProduk_itemInput, produksiUncheckedUpdateWithoutProduk_itemInput>
    create: XOR<produksiCreateWithoutProduk_itemInput, produksiUncheckedCreateWithoutProduk_itemInput>
    where?: produksiWhereInput
  }

  export type produksiUpdateToOneWithWhereWithoutProduk_itemInput = {
    where?: produksiWhereInput
    data: XOR<produksiUpdateWithoutProduk_itemInput, produksiUncheckedUpdateWithoutProduk_itemInput>
  }

  export type produksiUpdateWithoutProduk_itemInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat?: pembuatUpdateOneRequiredWithoutProduksiNestedInput
    kategori_produk?: kategori_produkUpdateOneRequiredWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type detail_diskonUpsertWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_diskonWhereUniqueInput
    update: XOR<detail_diskonUpdateWithoutProduk_itemInput, detail_diskonUncheckedUpdateWithoutProduk_itemInput>
    create: XOR<detail_diskonCreateWithoutProduk_itemInput, detail_diskonUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_diskonUpdateWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_diskonWhereUniqueInput
    data: XOR<detail_diskonUpdateWithoutProduk_itemInput, detail_diskonUncheckedUpdateWithoutProduk_itemInput>
  }

  export type detail_diskonUpdateManyWithWhereWithoutProduk_itemInput = {
    where: detail_diskonScalarWhereInput
    data: XOR<detail_diskonUpdateManyMutationInput, detail_diskonUncheckedUpdateManyWithoutProduk_itemInput>
  }

  export type detail_diskonScalarWhereInput = {
    AND?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
    OR?: detail_diskonScalarWhereInput[]
    NOT?: detail_diskonScalarWhereInput | detail_diskonScalarWhereInput[]
    id?: IntFilter<"detail_diskon"> | number
    diskon_id?: IntFilter<"detail_diskon"> | number
    produk_item_id?: IntNullableFilter<"detail_diskon"> | number | null
    pembelian_produk_id?: IntNullableFilter<"detail_diskon"> | number | null
    jumlah?: FloatFilter<"detail_diskon"> | number
    jumlah_diskon?: FloatFilter<"detail_diskon"> | number
  }

  export type detail_pengecekan_produkUpsertWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    update: XOR<detail_pengecekan_produkUpdateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedUpdateWithoutProduk_itemInput>
    create: XOR<detail_pengecekan_produkCreateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_pengecekan_produkUpdateWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    data: XOR<detail_pengecekan_produkUpdateWithoutProduk_itemInput, detail_pengecekan_produkUncheckedUpdateWithoutProduk_itemInput>
  }

  export type detail_pengecekan_produkUpdateManyWithWhereWithoutProduk_itemInput = {
    where: detail_pengecekan_produkScalarWhereInput
    data: XOR<detail_pengecekan_produkUpdateManyMutationInput, detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemInput>
  }

  export type detail_pengecekan_produkScalarWhereInput = {
    AND?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
    OR?: detail_pengecekan_produkScalarWhereInput[]
    NOT?: detail_pengecekan_produkScalarWhereInput | detail_pengecekan_produkScalarWhereInput[]
    id?: IntFilter<"detail_pengecekan_produk"> | number
    pengecekan_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    produk_item_id?: IntFilter<"detail_pengecekan_produk"> | number
    kondisi_produk_id?: IntFilter<"detail_pengecekan_produk"> | number
    jumlah?: FloatFilter<"detail_pengecekan_produk"> | number
  }

  export type detail_gawanganUpsertWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_gawanganWhereUniqueInput
    update: XOR<detail_gawanganUpdateWithoutProduk_itemInput, detail_gawanganUncheckedUpdateWithoutProduk_itemInput>
    create: XOR<detail_gawanganCreateWithoutProduk_itemInput, detail_gawanganUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_gawanganUpdateWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_gawanganWhereUniqueInput
    data: XOR<detail_gawanganUpdateWithoutProduk_itemInput, detail_gawanganUncheckedUpdateWithoutProduk_itemInput>
  }

  export type detail_gawanganUpdateManyWithWhereWithoutProduk_itemInput = {
    where: detail_gawanganScalarWhereInput
    data: XOR<detail_gawanganUpdateManyMutationInput, detail_gawanganUncheckedUpdateManyWithoutProduk_itemInput>
  }

  export type detail_gawanganScalarWhereInput = {
    AND?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
    OR?: detail_gawanganScalarWhereInput[]
    NOT?: detail_gawanganScalarWhereInput | detail_gawanganScalarWhereInput[]
    id?: IntFilter<"detail_gawangan"> | number
    gawangan_id?: IntFilter<"detail_gawangan"> | number
    produk_item_id?: IntFilter<"detail_gawangan"> | number
    jumlah?: IntFilter<"detail_gawangan"> | number
  }

  export type detail_pembelian_produkUpsertWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_pembelian_produkWhereUniqueInput
    update: XOR<detail_pembelian_produkUpdateWithoutProduk_itemInput, detail_pembelian_produkUncheckedUpdateWithoutProduk_itemInput>
    create: XOR<detail_pembelian_produkCreateWithoutProduk_itemInput, detail_pembelian_produkUncheckedCreateWithoutProduk_itemInput>
  }

  export type detail_pembelian_produkUpdateWithWhereUniqueWithoutProduk_itemInput = {
    where: detail_pembelian_produkWhereUniqueInput
    data: XOR<detail_pembelian_produkUpdateWithoutProduk_itemInput, detail_pembelian_produkUncheckedUpdateWithoutProduk_itemInput>
  }

  export type detail_pembelian_produkUpdateManyWithWhereWithoutProduk_itemInput = {
    where: detail_pembelian_produkScalarWhereInput
    data: XOR<detail_pembelian_produkUpdateManyMutationInput, detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemInput>
  }

  export type detail_pembelian_produkScalarWhereInput = {
    AND?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
    OR?: detail_pembelian_produkScalarWhereInput[]
    NOT?: detail_pembelian_produkScalarWhereInput | detail_pembelian_produkScalarWhereInput[]
    id?: IntFilter<"detail_pembelian_produk"> | number
    jumlah?: IntFilter<"detail_pembelian_produk"> | number
    diskon_id?: IntFilter<"detail_pembelian_produk"> | number
    produk_item_id?: IntFilter<"detail_pembelian_produk"> | number
    pembelian_produk_id?: IntFilter<"detail_pembelian_produk"> | number
    gawangan_id?: IntFilter<"detail_pembelian_produk"> | number
  }

  export type pembuatCreateWithoutProduksiInput = {
    nama_pembuat: string
  }

  export type pembuatUncheckedCreateWithoutProduksiInput = {
    id?: number
    nama_pembuat: string
  }

  export type pembuatCreateOrConnectWithoutProduksiInput = {
    where: pembuatWhereUniqueInput
    create: XOR<pembuatCreateWithoutProduksiInput, pembuatUncheckedCreateWithoutProduksiInput>
  }

  export type kategori_produkCreateWithoutProduksiInput = {
    kategori: string
  }

  export type kategori_produkUncheckedCreateWithoutProduksiInput = {
    id?: number
    kategori: string
  }

  export type kategori_produkCreateOrConnectWithoutProduksiInput = {
    where: kategori_produkWhereUniqueInput
    create: XOR<kategori_produkCreateWithoutProduksiInput, kategori_produkUncheckedCreateWithoutProduksiInput>
  }

  export type produk_itemCreateWithoutProduksiInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    detail_diskon?: detail_diskonCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateWithoutProduksiInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemCreateOrConnectWithoutProduksiInput = {
    where: produk_itemWhereUniqueInput
    create: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput>
  }

  export type produk_itemCreateManyProduksiInputEnvelope = {
    data: produk_itemCreateManyProduksiInput | produk_itemCreateManyProduksiInput[]
    skipDuplicates?: boolean
  }

  export type bahan_produksiCreateWithoutProduksiInput = {
    stok_terpakai: number
    stok_bahan: stok_bahanCreateNestedOneWithoutBahan_produksiInput
  }

  export type bahan_produksiUncheckedCreateWithoutProduksiInput = {
    id?: number
    stok_terpakai: number
    stok_bahan_id: number
  }

  export type bahan_produksiCreateOrConnectWithoutProduksiInput = {
    where: bahan_produksiWhereUniqueInput
    create: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput>
  }

  export type bahan_produksiCreateManyProduksiInputEnvelope = {
    data: bahan_produksiCreateManyProduksiInput | bahan_produksiCreateManyProduksiInput[]
    skipDuplicates?: boolean
  }

  export type pembuatUpsertWithoutProduksiInput = {
    update: XOR<pembuatUpdateWithoutProduksiInput, pembuatUncheckedUpdateWithoutProduksiInput>
    create: XOR<pembuatCreateWithoutProduksiInput, pembuatUncheckedCreateWithoutProduksiInput>
    where?: pembuatWhereInput
  }

  export type pembuatUpdateToOneWithWhereWithoutProduksiInput = {
    where?: pembuatWhereInput
    data: XOR<pembuatUpdateWithoutProduksiInput, pembuatUncheckedUpdateWithoutProduksiInput>
  }

  export type pembuatUpdateWithoutProduksiInput = {
    nama_pembuat?: StringFieldUpdateOperationsInput | string
  }

  export type pembuatUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pembuat?: StringFieldUpdateOperationsInput | string
  }

  export type kategori_produkUpsertWithoutProduksiInput = {
    update: XOR<kategori_produkUpdateWithoutProduksiInput, kategori_produkUncheckedUpdateWithoutProduksiInput>
    create: XOR<kategori_produkCreateWithoutProduksiInput, kategori_produkUncheckedCreateWithoutProduksiInput>
    where?: kategori_produkWhereInput
  }

  export type kategori_produkUpdateToOneWithWhereWithoutProduksiInput = {
    where?: kategori_produkWhereInput
    data: XOR<kategori_produkUpdateWithoutProduksiInput, kategori_produkUncheckedUpdateWithoutProduksiInput>
  }

  export type kategori_produkUpdateWithoutProduksiInput = {
    kategori?: StringFieldUpdateOperationsInput | string
  }

  export type kategori_produkUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    kategori?: StringFieldUpdateOperationsInput | string
  }

  export type produk_itemUpsertWithWhereUniqueWithoutProduksiInput = {
    where: produk_itemWhereUniqueInput
    update: XOR<produk_itemUpdateWithoutProduksiInput, produk_itemUncheckedUpdateWithoutProduksiInput>
    create: XOR<produk_itemCreateWithoutProduksiInput, produk_itemUncheckedCreateWithoutProduksiInput>
  }

  export type produk_itemUpdateWithWhereUniqueWithoutProduksiInput = {
    where: produk_itemWhereUniqueInput
    data: XOR<produk_itemUpdateWithoutProduksiInput, produk_itemUncheckedUpdateWithoutProduksiInput>
  }

  export type produk_itemUpdateManyWithWhereWithoutProduksiInput = {
    where: produk_itemScalarWhereInput
    data: XOR<produk_itemUpdateManyMutationInput, produk_itemUncheckedUpdateManyWithoutProduksiInput>
  }

  export type produk_itemScalarWhereInput = {
    AND?: produk_itemScalarWhereInput | produk_itemScalarWhereInput[]
    OR?: produk_itemScalarWhereInput[]
    NOT?: produk_itemScalarWhereInput | produk_itemScalarWhereInput[]
    id?: IntFilter<"produk_item"> | number
    kode_produk?: StringFilter<"produk_item"> | string
    sku?: StringFilter<"produk_item"> | string
    nama_produk?: StringFilter<"produk_item"> | string
    stok?: IntFilter<"produk_item"> | number
    harga_jual?: FloatFilter<"produk_item"> | number
    produksi_id?: IntFilter<"produk_item"> | number
  }

  export type bahan_produksiUpsertWithWhereUniqueWithoutProduksiInput = {
    where: bahan_produksiWhereUniqueInput
    update: XOR<bahan_produksiUpdateWithoutProduksiInput, bahan_produksiUncheckedUpdateWithoutProduksiInput>
    create: XOR<bahan_produksiCreateWithoutProduksiInput, bahan_produksiUncheckedCreateWithoutProduksiInput>
  }

  export type bahan_produksiUpdateWithWhereUniqueWithoutProduksiInput = {
    where: bahan_produksiWhereUniqueInput
    data: XOR<bahan_produksiUpdateWithoutProduksiInput, bahan_produksiUncheckedUpdateWithoutProduksiInput>
  }

  export type bahan_produksiUpdateManyWithWhereWithoutProduksiInput = {
    where: bahan_produksiScalarWhereInput
    data: XOR<bahan_produksiUpdateManyMutationInput, bahan_produksiUncheckedUpdateManyWithoutProduksiInput>
  }

  export type bahan_produksiScalarWhereInput = {
    AND?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
    OR?: bahan_produksiScalarWhereInput[]
    NOT?: bahan_produksiScalarWhereInput | bahan_produksiScalarWhereInput[]
    id?: IntFilter<"bahan_produksi"> | number
    stok_terpakai?: FloatFilter<"bahan_produksi"> | number
    produksi_id?: IntFilter<"bahan_produksi"> | number
    stok_bahan_id?: IntFilter<"bahan_produksi"> | number
  }

  export type produksiCreateWithoutKategori_produkInput = {
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat: pembuatCreateNestedOneWithoutProduksiInput
    produk_item?: produk_itemCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutKategori_produkInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    produk_item?: produk_itemUncheckedCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutKategori_produkInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput>
  }

  export type produksiCreateManyKategori_produkInputEnvelope = {
    data: produksiCreateManyKategori_produkInput | produksiCreateManyKategori_produkInput[]
    skipDuplicates?: boolean
  }

  export type produksiUpsertWithWhereUniqueWithoutKategori_produkInput = {
    where: produksiWhereUniqueInput
    update: XOR<produksiUpdateWithoutKategori_produkInput, produksiUncheckedUpdateWithoutKategori_produkInput>
    create: XOR<produksiCreateWithoutKategori_produkInput, produksiUncheckedCreateWithoutKategori_produkInput>
  }

  export type produksiUpdateWithWhereUniqueWithoutKategori_produkInput = {
    where: produksiWhereUniqueInput
    data: XOR<produksiUpdateWithoutKategori_produkInput, produksiUncheckedUpdateWithoutKategori_produkInput>
  }

  export type produksiUpdateManyWithWhereWithoutKategori_produkInput = {
    where: produksiScalarWhereInput
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyWithoutKategori_produkInput>
  }

  export type produksiScalarWhereInput = {
    AND?: produksiScalarWhereInput | produksiScalarWhereInput[]
    OR?: produksiScalarWhereInput[]
    NOT?: produksiScalarWhereInput | produksiScalarWhereInput[]
    id?: IntFilter<"produksi"> | number
    mulai?: DateTimeFilter<"produksi"> | Date | string
    selesai?: DateTimeFilter<"produksi"> | Date | string
    kode_produk?: StringFilter<"produksi"> | string
    jumlah?: IntFilter<"produksi"> | number
    ukuran?: StringFilter<"produksi"> | string
    warna?: StringFilter<"produksi"> | string
    biaya?: FloatFilter<"produksi"> | number
    pembuat_id?: IntFilter<"produksi"> | number
    kategori_produk_id?: IntFilter<"produksi"> | number
  }

  export type produksiCreateWithoutPembuatInput = {
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    kategori_produk: kategori_produkCreateNestedOneWithoutProduksiInput
    produk_item?: produk_itemCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutPembuatInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    kategori_produk_id: number
    produk_item?: produk_itemUncheckedCreateNestedManyWithoutProduksiInput
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutPembuatInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput>
  }

  export type produksiCreateManyPembuatInputEnvelope = {
    data: produksiCreateManyPembuatInput | produksiCreateManyPembuatInput[]
    skipDuplicates?: boolean
  }

  export type produksiUpsertWithWhereUniqueWithoutPembuatInput = {
    where: produksiWhereUniqueInput
    update: XOR<produksiUpdateWithoutPembuatInput, produksiUncheckedUpdateWithoutPembuatInput>
    create: XOR<produksiCreateWithoutPembuatInput, produksiUncheckedCreateWithoutPembuatInput>
  }

  export type produksiUpdateWithWhereUniqueWithoutPembuatInput = {
    where: produksiWhereUniqueInput
    data: XOR<produksiUpdateWithoutPembuatInput, produksiUncheckedUpdateWithoutPembuatInput>
  }

  export type produksiUpdateManyWithWhereWithoutPembuatInput = {
    where: produksiScalarWhereInput
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyWithoutPembuatInput>
  }

  export type produksiCreateWithoutBahan_produksiInput = {
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat: pembuatCreateNestedOneWithoutProduksiInput
    kategori_produk: kategori_produkCreateNestedOneWithoutProduksiInput
    produk_item?: produk_itemCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutBahan_produksiInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
    kategori_produk_id: number
    produk_item?: produk_itemUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutBahan_produksiInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutBahan_produksiInput, produksiUncheckedCreateWithoutBahan_produksiInput>
  }

  export type stok_bahanCreateWithoutBahan_produksiInput = {
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    detail_pengecekan_bahan?: detail_pengecekan_bahanCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanUncheckedCreateWithoutBahan_produksiInput = {
    id?: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanCreateOrConnectWithoutBahan_produksiInput = {
    where: stok_bahanWhereUniqueInput
    create: XOR<stok_bahanCreateWithoutBahan_produksiInput, stok_bahanUncheckedCreateWithoutBahan_produksiInput>
  }

  export type produksiUpsertWithoutBahan_produksiInput = {
    update: XOR<produksiUpdateWithoutBahan_produksiInput, produksiUncheckedUpdateWithoutBahan_produksiInput>
    create: XOR<produksiCreateWithoutBahan_produksiInput, produksiUncheckedCreateWithoutBahan_produksiInput>
    where?: produksiWhereInput
  }

  export type produksiUpdateToOneWithWhereWithoutBahan_produksiInput = {
    where?: produksiWhereInput
    data: XOR<produksiUpdateWithoutBahan_produksiInput, produksiUncheckedUpdateWithoutBahan_produksiInput>
  }

  export type produksiUpdateWithoutBahan_produksiInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat?: pembuatUpdateOneRequiredWithoutProduksiNestedInput
    kategori_produk?: kategori_produkUpdateOneRequiredWithoutProduksiNestedInput
    produk_item?: produk_itemUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutBahan_produksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type stok_bahanUpsertWithoutBahan_produksiInput = {
    update: XOR<stok_bahanUpdateWithoutBahan_produksiInput, stok_bahanUncheckedUpdateWithoutBahan_produksiInput>
    create: XOR<stok_bahanCreateWithoutBahan_produksiInput, stok_bahanUncheckedCreateWithoutBahan_produksiInput>
    where?: stok_bahanWhereInput
  }

  export type stok_bahanUpdateToOneWithWhereWithoutBahan_produksiInput = {
    where?: stok_bahanWhereInput
    data: XOR<stok_bahanUpdateWithoutBahan_produksiInput, stok_bahanUncheckedUpdateWithoutBahan_produksiInput>
  }

  export type stok_bahanUpdateWithoutBahan_produksiInput = {
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUpdateManyWithoutStok_bahanNestedInput
  }

  export type stok_bahanUncheckedUpdateWithoutBahan_produksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
  }

  export type bahan_produksiCreateWithoutStok_bahanInput = {
    stok_terpakai: number
    produksi: produksiCreateNestedOneWithoutBahan_produksiInput
  }

  export type bahan_produksiUncheckedCreateWithoutStok_bahanInput = {
    id?: number
    stok_terpakai: number
    produksi_id: number
  }

  export type bahan_produksiCreateOrConnectWithoutStok_bahanInput = {
    where: bahan_produksiWhereUniqueInput
    create: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput>
  }

  export type bahan_produksiCreateManyStok_bahanInputEnvelope = {
    data: bahan_produksiCreateManyStok_bahanInput | bahan_produksiCreateManyStok_bahanInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_bahanCreateWithoutStok_bahanInput = {
    jumlah: number
    pengecekan_bahan: pengecekan_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
    kondisi_bahan: kondisi_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
  }

  export type detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput = {
    id?: number
    pengecekan_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanCreateOrConnectWithoutStok_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    create: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput>
  }

  export type detail_pengecekan_bahanCreateManyStok_bahanInputEnvelope = {
    data: detail_pengecekan_bahanCreateManyStok_bahanInput | detail_pengecekan_bahanCreateManyStok_bahanInput[]
    skipDuplicates?: boolean
  }

  export type detail_pemesanan_bahanCreateWithoutStok_bahanInput = {
    jumlah: number
    harga: number
    pemesanan_bahan: pemesanan_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput
  }

  export type detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput = {
    id?: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
  }

  export type detail_pemesanan_bahanCreateOrConnectWithoutStok_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    create: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput>
  }

  export type detail_pemesanan_bahanCreateManyStok_bahanInputEnvelope = {
    data: detail_pemesanan_bahanCreateManyStok_bahanInput | detail_pemesanan_bahanCreateManyStok_bahanInput[]
    skipDuplicates?: boolean
  }

  export type bahan_produksiUpsertWithWhereUniqueWithoutStok_bahanInput = {
    where: bahan_produksiWhereUniqueInput
    update: XOR<bahan_produksiUpdateWithoutStok_bahanInput, bahan_produksiUncheckedUpdateWithoutStok_bahanInput>
    create: XOR<bahan_produksiCreateWithoutStok_bahanInput, bahan_produksiUncheckedCreateWithoutStok_bahanInput>
  }

  export type bahan_produksiUpdateWithWhereUniqueWithoutStok_bahanInput = {
    where: bahan_produksiWhereUniqueInput
    data: XOR<bahan_produksiUpdateWithoutStok_bahanInput, bahan_produksiUncheckedUpdateWithoutStok_bahanInput>
  }

  export type bahan_produksiUpdateManyWithWhereWithoutStok_bahanInput = {
    where: bahan_produksiScalarWhereInput
    data: XOR<bahan_produksiUpdateManyMutationInput, bahan_produksiUncheckedUpdateManyWithoutStok_bahanInput>
  }

  export type detail_pengecekan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    update: XOR<detail_pengecekan_bahanUpdateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutStok_bahanInput>
    create: XOR<detail_pengecekan_bahanCreateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutStok_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    data: XOR<detail_pengecekan_bahanUpdateWithoutStok_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutStok_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateManyWithWhereWithoutStok_bahanInput = {
    where: detail_pengecekan_bahanScalarWhereInput
    data: XOR<detail_pengecekan_bahanUpdateManyMutationInput, detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanInput>
  }

  export type detail_pengecekan_bahanScalarWhereInput = {
    AND?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
    OR?: detail_pengecekan_bahanScalarWhereInput[]
    NOT?: detail_pengecekan_bahanScalarWhereInput | detail_pengecekan_bahanScalarWhereInput[]
    id?: IntFilter<"detail_pengecekan_bahan"> | number
    pengecekan_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    stok_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    kondisi_bahan_id?: IntFilter<"detail_pengecekan_bahan"> | number
    jumlah?: FloatFilter<"detail_pengecekan_bahan"> | number
  }

  export type detail_pemesanan_bahanUpsertWithWhereUniqueWithoutStok_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    update: XOR<detail_pemesanan_bahanUpdateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedUpdateWithoutStok_bahanInput>
    create: XOR<detail_pemesanan_bahanCreateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutStok_bahanInput>
  }

  export type detail_pemesanan_bahanUpdateWithWhereUniqueWithoutStok_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    data: XOR<detail_pemesanan_bahanUpdateWithoutStok_bahanInput, detail_pemesanan_bahanUncheckedUpdateWithoutStok_bahanInput>
  }

  export type detail_pemesanan_bahanUpdateManyWithWhereWithoutStok_bahanInput = {
    where: detail_pemesanan_bahanScalarWhereInput
    data: XOR<detail_pemesanan_bahanUpdateManyMutationInput, detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanInput>
  }

  export type detail_pemesanan_bahanScalarWhereInput = {
    AND?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
    OR?: detail_pemesanan_bahanScalarWhereInput[]
    NOT?: detail_pemesanan_bahanScalarWhereInput | detail_pemesanan_bahanScalarWhereInput[]
    id?: IntFilter<"detail_pemesanan_bahan"> | number
    stok_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    pemesanan_bahan_id?: IntFilter<"detail_pemesanan_bahan"> | number
    jumlah?: FloatFilter<"detail_pemesanan_bahan"> | number
    harga?: FloatFilter<"detail_pemesanan_bahan"> | number
  }

  export type pengecekan_produkCreateWithoutDetail_pengecekan_produkInput = {
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_produkUncheckedCreateWithoutDetail_pengecekan_produkInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_produkCreateOrConnectWithoutDetail_pengecekan_produkInput = {
    where: pengecekan_produkWhereUniqueInput
    create: XOR<pengecekan_produkCreateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
  }

  export type produk_itemCreateWithoutDetail_pengecekan_produkInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi: produksiCreateNestedOneWithoutProduk_itemInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateWithoutDetail_pengecekan_produkInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemCreateOrConnectWithoutDetail_pengecekan_produkInput = {
    where: produk_itemWhereUniqueInput
    create: XOR<produk_itemCreateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedCreateWithoutDetail_pengecekan_produkInput>
  }

  export type kondisi_produkCreateWithoutDetail_pengecekan_produkInput = {
    kondisi: string
  }

  export type kondisi_produkUncheckedCreateWithoutDetail_pengecekan_produkInput = {
    id?: number
    kondisi: string
  }

  export type kondisi_produkCreateOrConnectWithoutDetail_pengecekan_produkInput = {
    where: kondisi_produkWhereUniqueInput
    create: XOR<kondisi_produkCreateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
  }

  export type pengecekan_produkUpsertWithoutDetail_pengecekan_produkInput = {
    update: XOR<pengecekan_produkUpdateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
    create: XOR<pengecekan_produkCreateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    where?: pengecekan_produkWhereInput
  }

  export type pengecekan_produkUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput = {
    where?: pengecekan_produkWhereInput
    data: XOR<pengecekan_produkUpdateWithoutDetail_pengecekan_produkInput, pengecekan_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type pengecekan_produkUpdateWithoutDetail_pengecekan_produkInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pengecekan_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type produk_itemUpsertWithoutDetail_pengecekan_produkInput = {
    update: XOR<produk_itemUpdateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedUpdateWithoutDetail_pengecekan_produkInput>
    create: XOR<produk_itemCreateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedCreateWithoutDetail_pengecekan_produkInput>
    where?: produk_itemWhereInput
  }

  export type produk_itemUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput = {
    where?: produk_itemWhereInput
    data: XOR<produk_itemUpdateWithoutDetail_pengecekan_produkInput, produk_itemUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type produk_itemUpdateWithoutDetail_pengecekan_produkInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutProduk_itemNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateWithoutDetail_pengecekan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type kondisi_produkUpsertWithoutDetail_pengecekan_produkInput = {
    update: XOR<kondisi_produkUpdateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
    create: XOR<kondisi_produkCreateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedCreateWithoutDetail_pengecekan_produkInput>
    where?: kondisi_produkWhereInput
  }

  export type kondisi_produkUpdateToOneWithWhereWithoutDetail_pengecekan_produkInput = {
    where?: kondisi_produkWhereInput
    data: XOR<kondisi_produkUpdateWithoutDetail_pengecekan_produkInput, kondisi_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput>
  }

  export type kondisi_produkUpdateWithoutDetail_pengecekan_produkInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
  }

  export type kondisi_produkUncheckedUpdateWithoutDetail_pengecekan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
  }

  export type detail_pengecekan_produkCreateWithoutPengecekan_produkInput = {
    jumlah: number
    produk_item: produk_itemCreateNestedOneWithoutDetail_pengecekan_produkInput
    kondisi_produk: kondisi_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
  }

  export type detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput = {
    id?: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkCreateOrConnectWithoutPengecekan_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    create: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput>
  }

  export type detail_pengecekan_produkCreateManyPengecekan_produkInputEnvelope = {
    data: detail_pengecekan_produkCreateManyPengecekan_produkInput | detail_pengecekan_produkCreateManyPengecekan_produkInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_produkUpsertWithWhereUniqueWithoutPengecekan_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    update: XOR<detail_pengecekan_produkUpdateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedUpdateWithoutPengecekan_produkInput>
    create: XOR<detail_pengecekan_produkCreateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedCreateWithoutPengecekan_produkInput>
  }

  export type detail_pengecekan_produkUpdateWithWhereUniqueWithoutPengecekan_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    data: XOR<detail_pengecekan_produkUpdateWithoutPengecekan_produkInput, detail_pengecekan_produkUncheckedUpdateWithoutPengecekan_produkInput>
  }

  export type detail_pengecekan_produkUpdateManyWithWhereWithoutPengecekan_produkInput = {
    where: detail_pengecekan_produkScalarWhereInput
    data: XOR<detail_pengecekan_produkUpdateManyMutationInput, detail_pengecekan_produkUncheckedUpdateManyWithoutPengecekan_produkInput>
  }

  export type detail_pengecekan_produkCreateWithoutKondisi_produkInput = {
    jumlah: number
    pengecekan_produk: pengecekan_produkCreateNestedOneWithoutDetail_pengecekan_produkInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_pengecekan_produkInput
  }

  export type detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput = {
    id?: number
    pengecekan_produk_id: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkCreateOrConnectWithoutKondisi_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    create: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput>
  }

  export type detail_pengecekan_produkCreateManyKondisi_produkInputEnvelope = {
    data: detail_pengecekan_produkCreateManyKondisi_produkInput | detail_pengecekan_produkCreateManyKondisi_produkInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_produkUpsertWithWhereUniqueWithoutKondisi_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    update: XOR<detail_pengecekan_produkUpdateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedUpdateWithoutKondisi_produkInput>
    create: XOR<detail_pengecekan_produkCreateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedCreateWithoutKondisi_produkInput>
  }

  export type detail_pengecekan_produkUpdateWithWhereUniqueWithoutKondisi_produkInput = {
    where: detail_pengecekan_produkWhereUniqueInput
    data: XOR<detail_pengecekan_produkUpdateWithoutKondisi_produkInput, detail_pengecekan_produkUncheckedUpdateWithoutKondisi_produkInput>
  }

  export type detail_pengecekan_produkUpdateManyWithWhereWithoutKondisi_produkInput = {
    where: detail_pengecekan_produkScalarWhereInput
    data: XOR<detail_pengecekan_produkUpdateManyMutationInput, detail_pengecekan_produkUncheckedUpdateManyWithoutKondisi_produkInput>
  }

  export type pengecekan_bahanCreateWithoutDetail_pengecekan_bahanInput = {
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput = {
    id?: number
    nama_pic: string
    tanggal: Date | string
  }

  export type pengecekan_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput = {
    where: pengecekan_bahanWhereUniqueInput
    create: XOR<pengecekan_bahanCreateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
  }

  export type stok_bahanCreateWithoutDetail_pengecekan_bahanInput = {
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput = {
    id?: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutStok_bahanInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput = {
    where: stok_bahanWhereUniqueInput
    create: XOR<stok_bahanCreateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
  }

  export type kondisi_bahanCreateWithoutDetail_pengecekan_bahanInput = {
    kondisi: string
    pengecekan_bahan_id: number
  }

  export type kondisi_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput = {
    id?: number
    kondisi: string
    pengecekan_bahan_id: number
  }

  export type kondisi_bahanCreateOrConnectWithoutDetail_pengecekan_bahanInput = {
    where: kondisi_bahanWhereUniqueInput
    create: XOR<kondisi_bahanCreateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
  }

  export type pengecekan_bahanUpsertWithoutDetail_pengecekan_bahanInput = {
    update: XOR<pengecekan_bahanUpdateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
    create: XOR<pengecekan_bahanCreateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    where?: pengecekan_bahanWhereInput
  }

  export type pengecekan_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput = {
    where?: pengecekan_bahanWhereInput
    data: XOR<pengecekan_bahanUpdateWithoutDetail_pengecekan_bahanInput, pengecekan_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type pengecekan_bahanUpdateWithoutDetail_pengecekan_bahanInput = {
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pengecekan_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_pic?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stok_bahanUpsertWithoutDetail_pengecekan_bahanInput = {
    update: XOR<stok_bahanUpdateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
    create: XOR<stok_bahanCreateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    where?: stok_bahanWhereInput
  }

  export type stok_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput = {
    where?: stok_bahanWhereInput
    data: XOR<stok_bahanUpdateWithoutDetail_pengecekan_bahanInput, stok_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type stok_bahanUpdateWithoutDetail_pengecekan_bahanInput = {
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUpdateManyWithoutStok_bahanNestedInput
  }

  export type stok_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutStok_bahanNestedInput
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
  }

  export type kondisi_bahanUpsertWithoutDetail_pengecekan_bahanInput = {
    update: XOR<kondisi_bahanUpdateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
    create: XOR<kondisi_bahanCreateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedCreateWithoutDetail_pengecekan_bahanInput>
    where?: kondisi_bahanWhereInput
  }

  export type kondisi_bahanUpdateToOneWithWhereWithoutDetail_pengecekan_bahanInput = {
    where?: kondisi_bahanWhereInput
    data: XOR<kondisi_bahanUpdateWithoutDetail_pengecekan_bahanInput, kondisi_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput>
  }

  export type kondisi_bahanUpdateWithoutDetail_pengecekan_bahanInput = {
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type kondisi_bahanUncheckedUpdateWithoutDetail_pengecekan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    kondisi?: StringFieldUpdateOperationsInput | string
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput = {
    jumlah: number
    stok_bahan: stok_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
    kondisi_bahan: kondisi_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
  }

  export type detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput = {
    id?: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanCreateOrConnectWithoutPengecekan_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    create: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput>
  }

  export type detail_pengecekan_bahanCreateManyPengecekan_bahanInputEnvelope = {
    data: detail_pengecekan_bahanCreateManyPengecekan_bahanInput | detail_pengecekan_bahanCreateManyPengecekan_bahanInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_bahanUpsertWithWhereUniqueWithoutPengecekan_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    update: XOR<detail_pengecekan_bahanUpdateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutPengecekan_bahanInput>
    create: XOR<detail_pengecekan_bahanCreateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutPengecekan_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateWithWhereUniqueWithoutPengecekan_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    data: XOR<detail_pengecekan_bahanUpdateWithoutPengecekan_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutPengecekan_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateManyWithWhereWithoutPengecekan_bahanInput = {
    where: detail_pengecekan_bahanScalarWhereInput
    data: XOR<detail_pengecekan_bahanUpdateManyMutationInput, detail_pengecekan_bahanUncheckedUpdateManyWithoutPengecekan_bahanInput>
  }

  export type detail_pengecekan_bahanCreateWithoutKondisi_bahanInput = {
    jumlah: number
    pengecekan_bahan: pengecekan_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
    stok_bahan: stok_bahanCreateNestedOneWithoutDetail_pengecekan_bahanInput
  }

  export type detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput = {
    id?: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanCreateOrConnectWithoutKondisi_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    create: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput>
  }

  export type detail_pengecekan_bahanCreateManyKondisi_bahanInputEnvelope = {
    data: detail_pengecekan_bahanCreateManyKondisi_bahanInput | detail_pengecekan_bahanCreateManyKondisi_bahanInput[]
    skipDuplicates?: boolean
  }

  export type detail_pengecekan_bahanUpsertWithWhereUniqueWithoutKondisi_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    update: XOR<detail_pengecekan_bahanUpdateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutKondisi_bahanInput>
    create: XOR<detail_pengecekan_bahanCreateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedCreateWithoutKondisi_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateWithWhereUniqueWithoutKondisi_bahanInput = {
    where: detail_pengecekan_bahanWhereUniqueInput
    data: XOR<detail_pengecekan_bahanUpdateWithoutKondisi_bahanInput, detail_pengecekan_bahanUncheckedUpdateWithoutKondisi_bahanInput>
  }

  export type detail_pengecekan_bahanUpdateManyWithWhereWithoutKondisi_bahanInput = {
    where: detail_pengecekan_bahanScalarWhereInput
    data: XOR<detail_pengecekan_bahanUpdateManyMutationInput, detail_pengecekan_bahanUncheckedUpdateManyWithoutKondisi_bahanInput>
  }

  export type pemesanan_bahanCreateWithoutDetail_pemesanan_bahanInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier: supplierCreateNestedOneWithoutPemesanan_bahanInput
  }

  export type pemesanan_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    supplier_id: number
  }

  export type pemesanan_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput = {
    where: pemesanan_bahanWhereUniqueInput
    create: XOR<pemesanan_bahanCreateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
  }

  export type stok_bahanCreateWithoutDetail_pemesanan_bahanInput = {
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiCreateNestedManyWithoutStok_bahanInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput = {
    id?: number
    kode_bahan: string
    nama_bahan: string
    ukuran: number
    satuan: string
    stok: number
    bahan_produksi?: bahan_produksiUncheckedCreateNestedManyWithoutStok_bahanInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedCreateNestedManyWithoutStok_bahanInput
  }

  export type stok_bahanCreateOrConnectWithoutDetail_pemesanan_bahanInput = {
    where: stok_bahanWhereUniqueInput
    create: XOR<stok_bahanCreateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
  }

  export type pemesanan_bahanUpsertWithoutDetail_pemesanan_bahanInput = {
    update: XOR<pemesanan_bahanUpdateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
    create: XOR<pemesanan_bahanCreateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    where?: pemesanan_bahanWhereInput
  }

  export type pemesanan_bahanUpdateToOneWithWhereWithoutDetail_pemesanan_bahanInput = {
    where?: pemesanan_bahanWhereInput
    data: XOR<pemesanan_bahanUpdateWithoutDetail_pemesanan_bahanInput, pemesanan_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
  }

  export type pemesanan_bahanUpdateWithoutDetail_pemesanan_bahanInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    supplier?: supplierUpdateOneRequiredWithoutPemesanan_bahanNestedInput
  }

  export type pemesanan_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    supplier_id?: IntFieldUpdateOperationsInput | number
  }

  export type stok_bahanUpsertWithoutDetail_pemesanan_bahanInput = {
    update: XOR<stok_bahanUpdateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
    create: XOR<stok_bahanCreateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedCreateWithoutDetail_pemesanan_bahanInput>
    where?: stok_bahanWhereInput
  }

  export type stok_bahanUpdateToOneWithWhereWithoutDetail_pemesanan_bahanInput = {
    where?: stok_bahanWhereInput
    data: XOR<stok_bahanUpdateWithoutDetail_pemesanan_bahanInput, stok_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput>
  }

  export type stok_bahanUpdateWithoutDetail_pemesanan_bahanInput = {
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUpdateManyWithoutStok_bahanNestedInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUpdateManyWithoutStok_bahanNestedInput
  }

  export type stok_bahanUncheckedUpdateWithoutDetail_pemesanan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_bahan?: StringFieldUpdateOperationsInput | string
    nama_bahan?: StringFieldUpdateOperationsInput | string
    ukuran?: FloatFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutStok_bahanNestedInput
    detail_pengecekan_bahan?: detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanNestedInput
  }

  export type supplierCreateWithoutPemesanan_bahanInput = {
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
  }

  export type supplierUncheckedCreateWithoutPemesanan_bahanInput = {
    id?: number
    nama_supplier: string
    alamat: string
    kontak: string
    nama_pic: string
    kontak_pic: string
  }

  export type supplierCreateOrConnectWithoutPemesanan_bahanInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutPemesanan_bahanInput, supplierUncheckedCreateWithoutPemesanan_bahanInput>
  }

  export type detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput = {
    jumlah: number
    harga: number
    stok_bahan: stok_bahanCreateNestedOneWithoutDetail_pemesanan_bahanInput
  }

  export type detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput = {
    id?: number
    stok_bahan_id: number
    jumlah: number
    harga: number
  }

  export type detail_pemesanan_bahanCreateOrConnectWithoutPemesanan_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    create: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput>
  }

  export type detail_pemesanan_bahanCreateManyPemesanan_bahanInputEnvelope = {
    data: detail_pemesanan_bahanCreateManyPemesanan_bahanInput | detail_pemesanan_bahanCreateManyPemesanan_bahanInput[]
    skipDuplicates?: boolean
  }

  export type supplierUpsertWithoutPemesanan_bahanInput = {
    update: XOR<supplierUpdateWithoutPemesanan_bahanInput, supplierUncheckedUpdateWithoutPemesanan_bahanInput>
    create: XOR<supplierCreateWithoutPemesanan_bahanInput, supplierUncheckedCreateWithoutPemesanan_bahanInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutPemesanan_bahanInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutPemesanan_bahanInput, supplierUncheckedUpdateWithoutPemesanan_bahanInput>
  }

  export type supplierUpdateWithoutPemesanan_bahanInput = {
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type supplierUncheckedUpdateWithoutPemesanan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_supplier?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type detail_pemesanan_bahanUpsertWithWhereUniqueWithoutPemesanan_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    update: XOR<detail_pemesanan_bahanUpdateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedUpdateWithoutPemesanan_bahanInput>
    create: XOR<detail_pemesanan_bahanCreateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedCreateWithoutPemesanan_bahanInput>
  }

  export type detail_pemesanan_bahanUpdateWithWhereUniqueWithoutPemesanan_bahanInput = {
    where: detail_pemesanan_bahanWhereUniqueInput
    data: XOR<detail_pemesanan_bahanUpdateWithoutPemesanan_bahanInput, detail_pemesanan_bahanUncheckedUpdateWithoutPemesanan_bahanInput>
  }

  export type detail_pemesanan_bahanUpdateManyWithWhereWithoutPemesanan_bahanInput = {
    where: detail_pemesanan_bahanScalarWhereInput
    data: XOR<detail_pemesanan_bahanUpdateManyMutationInput, detail_pemesanan_bahanUncheckedUpdateManyWithoutPemesanan_bahanInput>
  }

  export type pemesanan_bahanCreateWithoutSupplierInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    detail_pemesanan_bahan?: detail_pemesanan_bahanCreateNestedManyWithoutPemesanan_bahanInput
  }

  export type pemesanan_bahanUncheckedCreateWithoutSupplierInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedCreateNestedManyWithoutPemesanan_bahanInput
  }

  export type pemesanan_bahanCreateOrConnectWithoutSupplierInput = {
    where: pemesanan_bahanWhereUniqueInput
    create: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput>
  }

  export type pemesanan_bahanCreateManySupplierInputEnvelope = {
    data: pemesanan_bahanCreateManySupplierInput | pemesanan_bahanCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type pemesanan_bahanUpsertWithWhereUniqueWithoutSupplierInput = {
    where: pemesanan_bahanWhereUniqueInput
    update: XOR<pemesanan_bahanUpdateWithoutSupplierInput, pemesanan_bahanUncheckedUpdateWithoutSupplierInput>
    create: XOR<pemesanan_bahanCreateWithoutSupplierInput, pemesanan_bahanUncheckedCreateWithoutSupplierInput>
  }

  export type pemesanan_bahanUpdateWithWhereUniqueWithoutSupplierInput = {
    where: pemesanan_bahanWhereUniqueInput
    data: XOR<pemesanan_bahanUpdateWithoutSupplierInput, pemesanan_bahanUncheckedUpdateWithoutSupplierInput>
  }

  export type pemesanan_bahanUpdateManyWithWhereWithoutSupplierInput = {
    where: pemesanan_bahanScalarWhereInput
    data: XOR<pemesanan_bahanUpdateManyMutationInput, pemesanan_bahanUncheckedUpdateManyWithoutSupplierInput>
  }

  export type pemesanan_bahanScalarWhereInput = {
    AND?: pemesanan_bahanScalarWhereInput | pemesanan_bahanScalarWhereInput[]
    OR?: pemesanan_bahanScalarWhereInput[]
    NOT?: pemesanan_bahanScalarWhereInput | pemesanan_bahanScalarWhereInput[]
    id?: IntFilter<"pemesanan_bahan"> | number
    tanggal_pesan?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"pemesanan_bahan"> | Date | string
    pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    kontak_pic_pemesan?: StringFilter<"pemesanan_bahan"> | string
    supplier_id?: IntFilter<"pemesanan_bahan"> | number
  }

  export type gawanganCreateWithoutDetail_gawangansInput = {
    nama_gawangan: string
    outlet: outletCreateNestedOneWithoutGawanganInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutGawanganInput
  }

  export type gawanganUncheckedCreateWithoutDetail_gawangansInput = {
    id?: number
    nama_gawangan: string
    outlet_id: number
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutGawanganInput
  }

  export type gawanganCreateOrConnectWithoutDetail_gawangansInput = {
    where: gawanganWhereUniqueInput
    create: XOR<gawanganCreateWithoutDetail_gawangansInput, gawanganUncheckedCreateWithoutDetail_gawangansInput>
  }

  export type produk_itemCreateWithoutDetail_gawanganInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi: produksiCreateNestedOneWithoutProduk_itemInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateWithoutDetail_gawanganInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemCreateOrConnectWithoutDetail_gawanganInput = {
    where: produk_itemWhereUniqueInput
    create: XOR<produk_itemCreateWithoutDetail_gawanganInput, produk_itemUncheckedCreateWithoutDetail_gawanganInput>
  }

  export type gawanganUpsertWithoutDetail_gawangansInput = {
    update: XOR<gawanganUpdateWithoutDetail_gawangansInput, gawanganUncheckedUpdateWithoutDetail_gawangansInput>
    create: XOR<gawanganCreateWithoutDetail_gawangansInput, gawanganUncheckedCreateWithoutDetail_gawangansInput>
    where?: gawanganWhereInput
  }

  export type gawanganUpdateToOneWithWhereWithoutDetail_gawangansInput = {
    where?: gawanganWhereInput
    data: XOR<gawanganUpdateWithoutDetail_gawangansInput, gawanganUncheckedUpdateWithoutDetail_gawangansInput>
  }

  export type gawanganUpdateWithoutDetail_gawangansInput = {
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneRequiredWithoutGawanganNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganUncheckedUpdateWithoutDetail_gawangansInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet_id?: IntFieldUpdateOperationsInput | number
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutGawanganNestedInput
  }

  export type produk_itemUpsertWithoutDetail_gawanganInput = {
    update: XOR<produk_itemUpdateWithoutDetail_gawanganInput, produk_itemUncheckedUpdateWithoutDetail_gawanganInput>
    create: XOR<produk_itemCreateWithoutDetail_gawanganInput, produk_itemUncheckedCreateWithoutDetail_gawanganInput>
    where?: produk_itemWhereInput
  }

  export type produk_itemUpdateToOneWithWhereWithoutDetail_gawanganInput = {
    where?: produk_itemWhereInput
    data: XOR<produk_itemUpdateWithoutDetail_gawanganInput, produk_itemUncheckedUpdateWithoutDetail_gawanganInput>
  }

  export type produk_itemUpdateWithoutDetail_gawanganInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutProduk_itemNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateWithoutDetail_gawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type outletCreateWithoutGawanganInput = {
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
  }

  export type outletUncheckedCreateWithoutGawanganInput = {
    id?: number
    nama_outlet: string
    alamat: string
    nama_pic: string
    kontak_pic: string
  }

  export type outletCreateOrConnectWithoutGawanganInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutGawanganInput, outletUncheckedCreateWithoutGawanganInput>
  }

  export type detail_gawanganCreateWithoutGawanganInput = {
    jumlah: number
    produk_item: produk_itemCreateNestedOneWithoutDetail_gawanganInput
  }

  export type detail_gawanganUncheckedCreateWithoutGawanganInput = {
    id?: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_gawanganCreateOrConnectWithoutGawanganInput = {
    where: detail_gawanganWhereUniqueInput
    create: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput>
  }

  export type detail_gawanganCreateManyGawanganInputEnvelope = {
    data: detail_gawanganCreateManyGawanganInput | detail_gawanganCreateManyGawanganInput[]
    skipDuplicates?: boolean
  }

  export type detail_pembelian_produkCreateWithoutGawanganInput = {
    jumlah: number
    diskon: diskonCreateNestedOneWithoutDetail_pembelian_produkInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_pembelian_produkInput
    pembelian_produk: pembelian_produkCreateNestedOneWithoutDetail_pembelian_produkInput
  }

  export type detail_pembelian_produkUncheckedCreateWithoutGawanganInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
  }

  export type detail_pembelian_produkCreateOrConnectWithoutGawanganInput = {
    where: detail_pembelian_produkWhereUniqueInput
    create: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput>
  }

  export type detail_pembelian_produkCreateManyGawanganInputEnvelope = {
    data: detail_pembelian_produkCreateManyGawanganInput | detail_pembelian_produkCreateManyGawanganInput[]
    skipDuplicates?: boolean
  }

  export type outletUpsertWithoutGawanganInput = {
    update: XOR<outletUpdateWithoutGawanganInput, outletUncheckedUpdateWithoutGawanganInput>
    create: XOR<outletCreateWithoutGawanganInput, outletUncheckedCreateWithoutGawanganInput>
    where?: outletWhereInput
  }

  export type outletUpdateToOneWithWhereWithoutGawanganInput = {
    where?: outletWhereInput
    data: XOR<outletUpdateWithoutGawanganInput, outletUncheckedUpdateWithoutGawanganInput>
  }

  export type outletUpdateWithoutGawanganInput = {
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type outletUncheckedUpdateWithoutGawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_outlet?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    nama_pic?: StringFieldUpdateOperationsInput | string
    kontak_pic?: StringFieldUpdateOperationsInput | string
  }

  export type detail_gawanganUpsertWithWhereUniqueWithoutGawanganInput = {
    where: detail_gawanganWhereUniqueInput
    update: XOR<detail_gawanganUpdateWithoutGawanganInput, detail_gawanganUncheckedUpdateWithoutGawanganInput>
    create: XOR<detail_gawanganCreateWithoutGawanganInput, detail_gawanganUncheckedCreateWithoutGawanganInput>
  }

  export type detail_gawanganUpdateWithWhereUniqueWithoutGawanganInput = {
    where: detail_gawanganWhereUniqueInput
    data: XOR<detail_gawanganUpdateWithoutGawanganInput, detail_gawanganUncheckedUpdateWithoutGawanganInput>
  }

  export type detail_gawanganUpdateManyWithWhereWithoutGawanganInput = {
    where: detail_gawanganScalarWhereInput
    data: XOR<detail_gawanganUpdateManyMutationInput, detail_gawanganUncheckedUpdateManyWithoutGawanganInput>
  }

  export type detail_pembelian_produkUpsertWithWhereUniqueWithoutGawanganInput = {
    where: detail_pembelian_produkWhereUniqueInput
    update: XOR<detail_pembelian_produkUpdateWithoutGawanganInput, detail_pembelian_produkUncheckedUpdateWithoutGawanganInput>
    create: XOR<detail_pembelian_produkCreateWithoutGawanganInput, detail_pembelian_produkUncheckedCreateWithoutGawanganInput>
  }

  export type detail_pembelian_produkUpdateWithWhereUniqueWithoutGawanganInput = {
    where: detail_pembelian_produkWhereUniqueInput
    data: XOR<detail_pembelian_produkUpdateWithoutGawanganInput, detail_pembelian_produkUncheckedUpdateWithoutGawanganInput>
  }

  export type detail_pembelian_produkUpdateManyWithWhereWithoutGawanganInput = {
    where: detail_pembelian_produkScalarWhereInput
    data: XOR<detail_pembelian_produkUpdateManyMutationInput, detail_pembelian_produkUncheckedUpdateManyWithoutGawanganInput>
  }

  export type gawanganCreateWithoutOutletInput = {
    nama_gawangan: string
    detail_gawangans?: detail_gawanganCreateNestedManyWithoutGawanganInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutGawanganInput
  }

  export type gawanganUncheckedCreateWithoutOutletInput = {
    id?: number
    nama_gawangan: string
    detail_gawangans?: detail_gawanganUncheckedCreateNestedManyWithoutGawanganInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutGawanganInput
  }

  export type gawanganCreateOrConnectWithoutOutletInput = {
    where: gawanganWhereUniqueInput
    create: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput>
  }

  export type gawanganCreateManyOutletInputEnvelope = {
    data: gawanganCreateManyOutletInput | gawanganCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type gawanganUpsertWithWhereUniqueWithoutOutletInput = {
    where: gawanganWhereUniqueInput
    update: XOR<gawanganUpdateWithoutOutletInput, gawanganUncheckedUpdateWithoutOutletInput>
    create: XOR<gawanganCreateWithoutOutletInput, gawanganUncheckedCreateWithoutOutletInput>
  }

  export type gawanganUpdateWithWhereUniqueWithoutOutletInput = {
    where: gawanganWhereUniqueInput
    data: XOR<gawanganUpdateWithoutOutletInput, gawanganUncheckedUpdateWithoutOutletInput>
  }

  export type gawanganUpdateManyWithWhereWithoutOutletInput = {
    where: gawanganScalarWhereInput
    data: XOR<gawanganUpdateManyMutationInput, gawanganUncheckedUpdateManyWithoutOutletInput>
  }

  export type gawanganScalarWhereInput = {
    AND?: gawanganScalarWhereInput | gawanganScalarWhereInput[]
    OR?: gawanganScalarWhereInput[]
    NOT?: gawanganScalarWhereInput | gawanganScalarWhereInput[]
    id?: IntFilter<"gawangan"> | number
    nama_gawangan?: StringFilter<"gawangan"> | string
    outlet_id?: IntFilter<"gawangan"> | number
  }

  export type userCreateWithoutPembelian_produkInput = {
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
  }

  export type userUncheckedCreateWithoutPembelian_produkInput = {
    id?: number
    nama_lengkap: string
    kontak: string
    email: string
    username: string
    password: string
  }

  export type userCreateOrConnectWithoutPembelian_produkInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPembelian_produkInput, userUncheckedCreateWithoutPembelian_produkInput>
  }

  export type detail_diskonCreateWithoutPembelian_produkInput = {
    jumlah: number
    jumlah_diskon: number
    diskon: diskonCreateNestedOneWithoutDetail_diskonInput
    produk_item?: produk_itemCreateNestedOneWithoutDetail_diskonInput
  }

  export type detail_diskonUncheckedCreateWithoutPembelian_produkInput = {
    id?: number
    diskon_id: number
    produk_item_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_diskonCreateOrConnectWithoutPembelian_produkInput = {
    where: detail_diskonWhereUniqueInput
    create: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput>
  }

  export type detail_diskonCreateManyPembelian_produkInputEnvelope = {
    data: detail_diskonCreateManyPembelian_produkInput | detail_diskonCreateManyPembelian_produkInput[]
    skipDuplicates?: boolean
  }

  export type detail_pembelian_produkCreateWithoutPembelian_produkInput = {
    jumlah: number
    diskon: diskonCreateNestedOneWithoutDetail_pembelian_produkInput
    produk_item: produk_itemCreateNestedOneWithoutDetail_pembelian_produkInput
    gawangan: gawanganCreateNestedOneWithoutDetail_pembelian_produkInput
  }

  export type detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    gawangan_id: number
  }

  export type detail_pembelian_produkCreateOrConnectWithoutPembelian_produkInput = {
    where: detail_pembelian_produkWhereUniqueInput
    create: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput>
  }

  export type detail_pembelian_produkCreateManyPembelian_produkInputEnvelope = {
    data: detail_pembelian_produkCreateManyPembelian_produkInput | detail_pembelian_produkCreateManyPembelian_produkInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutPembelian_produkInput = {
    update: XOR<userUpdateWithoutPembelian_produkInput, userUncheckedUpdateWithoutPembelian_produkInput>
    create: XOR<userCreateWithoutPembelian_produkInput, userUncheckedCreateWithoutPembelian_produkInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPembelian_produkInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPembelian_produkInput, userUncheckedUpdateWithoutPembelian_produkInput>
  }

  export type userUpdateWithoutPembelian_produkInput = {
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateWithoutPembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lengkap?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type detail_diskonUpsertWithWhereUniqueWithoutPembelian_produkInput = {
    where: detail_diskonWhereUniqueInput
    update: XOR<detail_diskonUpdateWithoutPembelian_produkInput, detail_diskonUncheckedUpdateWithoutPembelian_produkInput>
    create: XOR<detail_diskonCreateWithoutPembelian_produkInput, detail_diskonUncheckedCreateWithoutPembelian_produkInput>
  }

  export type detail_diskonUpdateWithWhereUniqueWithoutPembelian_produkInput = {
    where: detail_diskonWhereUniqueInput
    data: XOR<detail_diskonUpdateWithoutPembelian_produkInput, detail_diskonUncheckedUpdateWithoutPembelian_produkInput>
  }

  export type detail_diskonUpdateManyWithWhereWithoutPembelian_produkInput = {
    where: detail_diskonScalarWhereInput
    data: XOR<detail_diskonUpdateManyMutationInput, detail_diskonUncheckedUpdateManyWithoutPembelian_produkInput>
  }

  export type detail_pembelian_produkUpsertWithWhereUniqueWithoutPembelian_produkInput = {
    where: detail_pembelian_produkWhereUniqueInput
    update: XOR<detail_pembelian_produkUpdateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedUpdateWithoutPembelian_produkInput>
    create: XOR<detail_pembelian_produkCreateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedCreateWithoutPembelian_produkInput>
  }

  export type detail_pembelian_produkUpdateWithWhereUniqueWithoutPembelian_produkInput = {
    where: detail_pembelian_produkWhereUniqueInput
    data: XOR<detail_pembelian_produkUpdateWithoutPembelian_produkInput, detail_pembelian_produkUncheckedUpdateWithoutPembelian_produkInput>
  }

  export type detail_pembelian_produkUpdateManyWithWhereWithoutPembelian_produkInput = {
    where: detail_pembelian_produkScalarWhereInput
    data: XOR<detail_pembelian_produkUpdateManyMutationInput, detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkInput>
  }

  export type pembelian_produkCreateWithoutUserInput = {
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    detail_diskon?: detail_diskonCreateNestedManyWithoutPembelian_produkInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkUncheckedCreateWithoutUserInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutPembelian_produkInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkCreateOrConnectWithoutUserInput = {
    where: pembelian_produkWhereUniqueInput
    create: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput>
  }

  export type pembelian_produkCreateManyUserInputEnvelope = {
    data: pembelian_produkCreateManyUserInput | pembelian_produkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type pembelian_produkUpsertWithWhereUniqueWithoutUserInput = {
    where: pembelian_produkWhereUniqueInput
    update: XOR<pembelian_produkUpdateWithoutUserInput, pembelian_produkUncheckedUpdateWithoutUserInput>
    create: XOR<pembelian_produkCreateWithoutUserInput, pembelian_produkUncheckedCreateWithoutUserInput>
  }

  export type pembelian_produkUpdateWithWhereUniqueWithoutUserInput = {
    where: pembelian_produkWhereUniqueInput
    data: XOR<pembelian_produkUpdateWithoutUserInput, pembelian_produkUncheckedUpdateWithoutUserInput>
  }

  export type pembelian_produkUpdateManyWithWhereWithoutUserInput = {
    where: pembelian_produkScalarWhereInput
    data: XOR<pembelian_produkUpdateManyMutationInput, pembelian_produkUncheckedUpdateManyWithoutUserInput>
  }

  export type pembelian_produkScalarWhereInput = {
    AND?: pembelian_produkScalarWhereInput | pembelian_produkScalarWhereInput[]
    OR?: pembelian_produkScalarWhereInput[]
    NOT?: pembelian_produkScalarWhereInput | pembelian_produkScalarWhereInput[]
    id?: IntFilter<"pembelian_produk"> | number
    tanggal_pembelian?: DateTimeFilter<"pembelian_produk"> | Date | string
    nama_pembeli?: StringFilter<"pembelian_produk"> | string
    kontak_pembeli?: StringFilter<"pembelian_produk"> | string
    user_id?: IntFilter<"pembelian_produk"> | number
  }

  export type diskonCreateWithoutDetail_pembelian_produkInput = {
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_diskon?: detail_diskonCreateNestedManyWithoutDiskonInput
  }

  export type diskonUncheckedCreateWithoutDetail_pembelian_produkInput = {
    id?: number
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutDiskonInput
  }

  export type diskonCreateOrConnectWithoutDetail_pembelian_produkInput = {
    where: diskonWhereUniqueInput
    create: XOR<diskonCreateWithoutDetail_pembelian_produkInput, diskonUncheckedCreateWithoutDetail_pembelian_produkInput>
  }

  export type produk_itemCreateWithoutDetail_pembelian_produkInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi: produksiCreateNestedOneWithoutProduk_itemInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateWithoutDetail_pembelian_produkInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemCreateOrConnectWithoutDetail_pembelian_produkInput = {
    where: produk_itemWhereUniqueInput
    create: XOR<produk_itemCreateWithoutDetail_pembelian_produkInput, produk_itemUncheckedCreateWithoutDetail_pembelian_produkInput>
  }

  export type pembelian_produkCreateWithoutDetail_pembelian_produkInput = {
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user: userCreateNestedOneWithoutPembelian_produkInput
    detail_diskon?: detail_diskonCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkUncheckedCreateWithoutDetail_pembelian_produkInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user_id: number
    detail_diskon?: detail_diskonUncheckedCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkCreateOrConnectWithoutDetail_pembelian_produkInput = {
    where: pembelian_produkWhereUniqueInput
    create: XOR<pembelian_produkCreateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedCreateWithoutDetail_pembelian_produkInput>
  }

  export type gawanganCreateWithoutDetail_pembelian_produkInput = {
    nama_gawangan: string
    outlet: outletCreateNestedOneWithoutGawanganInput
    detail_gawangans?: detail_gawanganCreateNestedManyWithoutGawanganInput
  }

  export type gawanganUncheckedCreateWithoutDetail_pembelian_produkInput = {
    id?: number
    nama_gawangan: string
    outlet_id: number
    detail_gawangans?: detail_gawanganUncheckedCreateNestedManyWithoutGawanganInput
  }

  export type gawanganCreateOrConnectWithoutDetail_pembelian_produkInput = {
    where: gawanganWhereUniqueInput
    create: XOR<gawanganCreateWithoutDetail_pembelian_produkInput, gawanganUncheckedCreateWithoutDetail_pembelian_produkInput>
  }

  export type diskonUpsertWithoutDetail_pembelian_produkInput = {
    update: XOR<diskonUpdateWithoutDetail_pembelian_produkInput, diskonUncheckedUpdateWithoutDetail_pembelian_produkInput>
    create: XOR<diskonCreateWithoutDetail_pembelian_produkInput, diskonUncheckedCreateWithoutDetail_pembelian_produkInput>
    where?: diskonWhereInput
  }

  export type diskonUpdateToOneWithWhereWithoutDetail_pembelian_produkInput = {
    where?: diskonWhereInput
    data: XOR<diskonUpdateWithoutDetail_pembelian_produkInput, diskonUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type diskonUpdateWithoutDetail_pembelian_produkInput = {
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_diskon?: detail_diskonUpdateManyWithoutDiskonNestedInput
  }

  export type diskonUncheckedUpdateWithoutDetail_pembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutDiskonNestedInput
  }

  export type produk_itemUpsertWithoutDetail_pembelian_produkInput = {
    update: XOR<produk_itemUpdateWithoutDetail_pembelian_produkInput, produk_itemUncheckedUpdateWithoutDetail_pembelian_produkInput>
    create: XOR<produk_itemCreateWithoutDetail_pembelian_produkInput, produk_itemUncheckedCreateWithoutDetail_pembelian_produkInput>
    where?: produk_itemWhereInput
  }

  export type produk_itemUpdateToOneWithWhereWithoutDetail_pembelian_produkInput = {
    where?: produk_itemWhereInput
    data: XOR<produk_itemUpdateWithoutDetail_pembelian_produkInput, produk_itemUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type produk_itemUpdateWithoutDetail_pembelian_produkInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutProduk_itemNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateWithoutDetail_pembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type pembelian_produkUpsertWithoutDetail_pembelian_produkInput = {
    update: XOR<pembelian_produkUpdateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedUpdateWithoutDetail_pembelian_produkInput>
    create: XOR<pembelian_produkCreateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedCreateWithoutDetail_pembelian_produkInput>
    where?: pembelian_produkWhereInput
  }

  export type pembelian_produkUpdateToOneWithWhereWithoutDetail_pembelian_produkInput = {
    where?: pembelian_produkWhereInput
    data: XOR<pembelian_produkUpdateWithoutDetail_pembelian_produkInput, pembelian_produkUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type pembelian_produkUpdateWithoutDetail_pembelian_produkInput = {
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutPembelian_produkNestedInput
    detail_diskon?: detail_diskonUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkUncheckedUpdateWithoutDetail_pembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutPembelian_produkNestedInput
  }

  export type gawanganUpsertWithoutDetail_pembelian_produkInput = {
    update: XOR<gawanganUpdateWithoutDetail_pembelian_produkInput, gawanganUncheckedUpdateWithoutDetail_pembelian_produkInput>
    create: XOR<gawanganCreateWithoutDetail_pembelian_produkInput, gawanganUncheckedCreateWithoutDetail_pembelian_produkInput>
    where?: gawanganWhereInput
  }

  export type gawanganUpdateToOneWithWhereWithoutDetail_pembelian_produkInput = {
    where?: gawanganWhereInput
    data: XOR<gawanganUpdateWithoutDetail_pembelian_produkInput, gawanganUncheckedUpdateWithoutDetail_pembelian_produkInput>
  }

  export type gawanganUpdateWithoutDetail_pembelian_produkInput = {
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneRequiredWithoutGawanganNestedInput
    detail_gawangans?: detail_gawanganUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganUncheckedUpdateWithoutDetail_pembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    outlet_id?: IntFieldUpdateOperationsInput | number
    detail_gawangans?: detail_gawanganUncheckedUpdateManyWithoutGawanganNestedInput
  }

  export type detail_pembelian_produkCreateWithoutDiskonInput = {
    jumlah: number
    produk_item: produk_itemCreateNestedOneWithoutDetail_pembelian_produkInput
    pembelian_produk: pembelian_produkCreateNestedOneWithoutDetail_pembelian_produkInput
    gawangan: gawanganCreateNestedOneWithoutDetail_pembelian_produkInput
  }

  export type detail_pembelian_produkUncheckedCreateWithoutDiskonInput = {
    id?: number
    jumlah: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_pembelian_produkCreateOrConnectWithoutDiskonInput = {
    where: detail_pembelian_produkWhereUniqueInput
    create: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput>
  }

  export type detail_pembelian_produkCreateManyDiskonInputEnvelope = {
    data: detail_pembelian_produkCreateManyDiskonInput | detail_pembelian_produkCreateManyDiskonInput[]
    skipDuplicates?: boolean
  }

  export type detail_diskonCreateWithoutDiskonInput = {
    jumlah: number
    jumlah_diskon: number
    produk_item?: produk_itemCreateNestedOneWithoutDetail_diskonInput
    pembelian_produk?: pembelian_produkCreateNestedOneWithoutDetail_diskonInput
  }

  export type detail_diskonUncheckedCreateWithoutDiskonInput = {
    id?: number
    produk_item_id?: number | null
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_diskonCreateOrConnectWithoutDiskonInput = {
    where: detail_diskonWhereUniqueInput
    create: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput>
  }

  export type detail_diskonCreateManyDiskonInputEnvelope = {
    data: detail_diskonCreateManyDiskonInput | detail_diskonCreateManyDiskonInput[]
    skipDuplicates?: boolean
  }

  export type detail_pembelian_produkUpsertWithWhereUniqueWithoutDiskonInput = {
    where: detail_pembelian_produkWhereUniqueInput
    update: XOR<detail_pembelian_produkUpdateWithoutDiskonInput, detail_pembelian_produkUncheckedUpdateWithoutDiskonInput>
    create: XOR<detail_pembelian_produkCreateWithoutDiskonInput, detail_pembelian_produkUncheckedCreateWithoutDiskonInput>
  }

  export type detail_pembelian_produkUpdateWithWhereUniqueWithoutDiskonInput = {
    where: detail_pembelian_produkWhereUniqueInput
    data: XOR<detail_pembelian_produkUpdateWithoutDiskonInput, detail_pembelian_produkUncheckedUpdateWithoutDiskonInput>
  }

  export type detail_pembelian_produkUpdateManyWithWhereWithoutDiskonInput = {
    where: detail_pembelian_produkScalarWhereInput
    data: XOR<detail_pembelian_produkUpdateManyMutationInput, detail_pembelian_produkUncheckedUpdateManyWithoutDiskonInput>
  }

  export type detail_diskonUpsertWithWhereUniqueWithoutDiskonInput = {
    where: detail_diskonWhereUniqueInput
    update: XOR<detail_diskonUpdateWithoutDiskonInput, detail_diskonUncheckedUpdateWithoutDiskonInput>
    create: XOR<detail_diskonCreateWithoutDiskonInput, detail_diskonUncheckedCreateWithoutDiskonInput>
  }

  export type detail_diskonUpdateWithWhereUniqueWithoutDiskonInput = {
    where: detail_diskonWhereUniqueInput
    data: XOR<detail_diskonUpdateWithoutDiskonInput, detail_diskonUncheckedUpdateWithoutDiskonInput>
  }

  export type detail_diskonUpdateManyWithWhereWithoutDiskonInput = {
    where: detail_diskonScalarWhereInput
    data: XOR<detail_diskonUpdateManyMutationInput, detail_diskonUncheckedUpdateManyWithoutDiskonInput>
  }

  export type diskonCreateWithoutDetail_diskonInput = {
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutDiskonInput
  }

  export type diskonUncheckedCreateWithoutDetail_diskonInput = {
    id?: number
    nama_diskon: string
    tipe_diskon: $Enums.TipeDiskon
    jumlah_diskon: number
    tanggal_mulai: Date | string
    tanggal_selesai: Date | string
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutDiskonInput
  }

  export type diskonCreateOrConnectWithoutDetail_diskonInput = {
    where: diskonWhereUniqueInput
    create: XOR<diskonCreateWithoutDetail_diskonInput, diskonUncheckedCreateWithoutDetail_diskonInput>
  }

  export type produk_itemCreateWithoutDetail_diskonInput = {
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi: produksiCreateNestedOneWithoutProduk_itemInput
    detail_pengecekan_produk?: detail_pengecekan_produkCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemUncheckedCreateWithoutDetail_diskonInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
    produksi_id: number
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_gawangan?: detail_gawanganUncheckedCreateNestedManyWithoutProduk_itemInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutProduk_itemInput
  }

  export type produk_itemCreateOrConnectWithoutDetail_diskonInput = {
    where: produk_itemWhereUniqueInput
    create: XOR<produk_itemCreateWithoutDetail_diskonInput, produk_itemUncheckedCreateWithoutDetail_diskonInput>
  }

  export type pembelian_produkCreateWithoutDetail_diskonInput = {
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user: userCreateNestedOneWithoutPembelian_produkInput
    detail_pembelian_produk?: detail_pembelian_produkCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkUncheckedCreateWithoutDetail_diskonInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
    user_id: number
    detail_pembelian_produk?: detail_pembelian_produkUncheckedCreateNestedManyWithoutPembelian_produkInput
  }

  export type pembelian_produkCreateOrConnectWithoutDetail_diskonInput = {
    where: pembelian_produkWhereUniqueInput
    create: XOR<pembelian_produkCreateWithoutDetail_diskonInput, pembelian_produkUncheckedCreateWithoutDetail_diskonInput>
  }

  export type diskonUpsertWithoutDetail_diskonInput = {
    update: XOR<diskonUpdateWithoutDetail_diskonInput, diskonUncheckedUpdateWithoutDetail_diskonInput>
    create: XOR<diskonCreateWithoutDetail_diskonInput, diskonUncheckedCreateWithoutDetail_diskonInput>
    where?: diskonWhereInput
  }

  export type diskonUpdateToOneWithWhereWithoutDetail_diskonInput = {
    where?: diskonWhereInput
    data: XOR<diskonUpdateWithoutDetail_diskonInput, diskonUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type diskonUpdateWithoutDetail_diskonInput = {
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutDiskonNestedInput
  }

  export type diskonUncheckedUpdateWithoutDetail_diskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_diskon?: StringFieldUpdateOperationsInput | string
    tipe_diskon?: EnumTipeDiskonFieldUpdateOperationsInput | $Enums.TipeDiskon
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutDiskonNestedInput
  }

  export type produk_itemUpsertWithoutDetail_diskonInput = {
    update: XOR<produk_itemUpdateWithoutDetail_diskonInput, produk_itemUncheckedUpdateWithoutDetail_diskonInput>
    create: XOR<produk_itemCreateWithoutDetail_diskonInput, produk_itemUncheckedCreateWithoutDetail_diskonInput>
    where?: produk_itemWhereInput
  }

  export type produk_itemUpdateToOneWithWhereWithoutDetail_diskonInput = {
    where?: produk_itemWhereInput
    data: XOR<produk_itemUpdateWithoutDetail_diskonInput, produk_itemUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type produk_itemUpdateWithoutDetail_diskonInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateWithoutDetail_diskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type pembelian_produkUpsertWithoutDetail_diskonInput = {
    update: XOR<pembelian_produkUpdateWithoutDetail_diskonInput, pembelian_produkUncheckedUpdateWithoutDetail_diskonInput>
    create: XOR<pembelian_produkCreateWithoutDetail_diskonInput, pembelian_produkUncheckedCreateWithoutDetail_diskonInput>
    where?: pembelian_produkWhereInput
  }

  export type pembelian_produkUpdateToOneWithWhereWithoutDetail_diskonInput = {
    where?: pembelian_produkWhereInput
    data: XOR<pembelian_produkUpdateWithoutDetail_diskonInput, pembelian_produkUncheckedUpdateWithoutDetail_diskonInput>
  }

  export type pembelian_produkUpdateWithoutDetail_diskonInput = {
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutPembelian_produkNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkUncheckedUpdateWithoutDetail_diskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkNestedInput
  }

  export type detail_diskonCreateManyProduk_itemInput = {
    id?: number
    diskon_id: number
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_pengecekan_produkCreateManyProduk_itemInput = {
    id?: number
    pengecekan_produk_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_gawanganCreateManyProduk_itemInput = {
    id?: number
    gawangan_id: number
    jumlah: number
  }

  export type detail_pembelian_produkCreateManyProduk_itemInput = {
    id?: number
    jumlah: number
    diskon_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_diskonUpdateWithoutProduk_itemInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_diskonNestedInput
    pembelian_produk?: pembelian_produkUpdateOneWithoutDetail_diskonNestedInput
  }

  export type detail_diskonUncheckedUpdateWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_diskonUncheckedUpdateManyWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkUpdateWithoutProduk_itemInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_produk?: pengecekan_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
    kondisi_produk?: kondisi_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
  }

  export type detail_pengecekan_produkUncheckedUpdateWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_gawanganUpdateWithoutProduk_itemInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_gawangansNestedInput
  }

  export type detail_gawanganUncheckedUpdateWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_gawanganUncheckedUpdateManyWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUpdateWithoutProduk_itemInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    pembelian_produk?: pembelian_produkUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
  }

  export type detail_pembelian_produkUncheckedUpdateWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type produk_itemCreateManyProduksiInput = {
    id?: number
    kode_produk: string
    sku: string
    nama_produk: string
    stok: number
    harga_jual: number
  }

  export type bahan_produksiCreateManyProduksiInput = {
    id?: number
    stok_terpakai: number
    stok_bahan_id: number
  }

  export type produk_itemUpdateWithoutProduksiInput = {
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pengecekan_produk?: detail_pengecekan_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_gawangan?: detail_gawanganUncheckedUpdateManyWithoutProduk_itemNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutProduk_itemNestedInput
  }

  export type produk_itemUncheckedUpdateManyWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_produk?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    stok?: IntFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type bahan_produksiUpdateWithoutProduksiInput = {
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutBahan_produksiNestedInput
  }

  export type bahan_produksiUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type bahan_produksiUncheckedUpdateManyWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
  }

  export type produksiCreateManyKategori_produkInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    pembuat_id: number
  }

  export type produksiUpdateWithoutKategori_produkInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat?: pembuatUpdateOneRequiredWithoutProduksiNestedInput
    produk_item?: produk_itemUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutKategori_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUncheckedUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateManyWithoutKategori_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    pembuat_id?: IntFieldUpdateOperationsInput | number
  }

  export type produksiCreateManyPembuatInput = {
    id?: number
    mulai: Date | string
    selesai: Date | string
    kode_produk: string
    jumlah: number
    ukuran: string
    warna: string
    biaya: number
    kategori_produk_id: number
  }

  export type produksiUpdateWithoutPembuatInput = {
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    kategori_produk?: kategori_produkUpdateOneRequiredWithoutProduksiNestedInput
    produk_item?: produk_itemUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutPembuatInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUncheckedUpdateManyWithoutProduksiNestedInput
    bahan_produksi?: bahan_produksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateManyWithoutPembuatInput = {
    id?: IntFieldUpdateOperationsInput | number
    mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    selesai?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_produk?: StringFieldUpdateOperationsInput | string
    jumlah?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    warna?: StringFieldUpdateOperationsInput | string
    biaya?: FloatFieldUpdateOperationsInput | number
    kategori_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type bahan_produksiCreateManyStok_bahanInput = {
    id?: number
    stok_terpakai: number
    produksi_id: number
  }

  export type detail_pengecekan_bahanCreateManyStok_bahanInput = {
    id?: number
    pengecekan_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pemesanan_bahanCreateManyStok_bahanInput = {
    id?: number
    pemesanan_bahan_id: number
    jumlah: number
    harga: number
  }

  export type bahan_produksiUpdateWithoutStok_bahanInput = {
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi?: produksiUpdateOneRequiredWithoutBahan_produksiNestedInput
  }

  export type bahan_produksiUncheckedUpdateWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
  }

  export type bahan_produksiUncheckedUpdateManyWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_terpakai?: FloatFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanUpdateWithoutStok_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_bahan?: pengecekan_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
    kondisi_bahan?: kondisi_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
  }

  export type detail_pengecekan_bahanUncheckedUpdateWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanUpdateWithoutStok_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
    pemesanan_bahan?: pemesanan_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput
  }

  export type detail_pemesanan_bahanUncheckedUpdateWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pemesanan_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanUncheckedUpdateManyWithoutStok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pemesanan_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkCreateManyPengecekan_produkInput = {
    id?: number
    produk_item_id: number
    kondisi_produk_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkUpdateWithoutPengecekan_produkInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
    kondisi_produk?: kondisi_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
  }

  export type detail_pengecekan_produkUncheckedUpdateWithoutPengecekan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutPengecekan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    kondisi_produk_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkCreateManyKondisi_produkInput = {
    id?: number
    pengecekan_produk_id: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_pengecekan_produkUpdateWithoutKondisi_produkInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_produk?: pengecekan_produkUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pengecekan_produkNestedInput
  }

  export type detail_pengecekan_produkUncheckedUpdateWithoutKondisi_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_produkUncheckedUpdateManyWithoutKondisi_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_produk_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanCreateManyPengecekan_bahanInput = {
    id?: number
    stok_bahan_id: number
    kondisi_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanUpdateWithoutPengecekan_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
    kondisi_bahan?: kondisi_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
  }

  export type detail_pengecekan_bahanUncheckedUpdateWithoutPengecekan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutPengecekan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    kondisi_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanCreateManyKondisi_bahanInput = {
    id?: number
    pengecekan_bahan_id: number
    stok_bahan_id: number
    jumlah: number
  }

  export type detail_pengecekan_bahanUpdateWithoutKondisi_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    pengecekan_bahan?: pengecekan_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutDetail_pengecekan_bahanNestedInput
  }

  export type detail_pengecekan_bahanUncheckedUpdateWithoutKondisi_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pengecekan_bahanUncheckedUpdateManyWithoutKondisi_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengecekan_bahan_id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanCreateManyPemesanan_bahanInput = {
    id?: number
    stok_bahan_id: number
    jumlah: number
    harga: number
  }

  export type detail_pemesanan_bahanUpdateWithoutPemesanan_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
    stok_bahan?: stok_bahanUpdateOneRequiredWithoutDetail_pemesanan_bahanNestedInput
  }

  export type detail_pemesanan_bahanUncheckedUpdateWithoutPemesanan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pemesanan_bahanUncheckedUpdateManyWithoutPemesanan_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    stok_bahan_id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    harga?: FloatFieldUpdateOperationsInput | number
  }

  export type pemesanan_bahanCreateManySupplierInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    pic_pemesan: string
    kontak_pic_pemesan: string
  }

  export type pemesanan_bahanUpdateWithoutSupplierInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    detail_pemesanan_bahan?: detail_pemesanan_bahanUpdateManyWithoutPemesanan_bahanNestedInput
  }

  export type pemesanan_bahanUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
    detail_pemesanan_bahan?: detail_pemesanan_bahanUncheckedUpdateManyWithoutPemesanan_bahanNestedInput
  }

  export type pemesanan_bahanUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    pic_pemesan?: StringFieldUpdateOperationsInput | string
    kontak_pic_pemesan?: StringFieldUpdateOperationsInput | string
  }

  export type detail_gawanganCreateManyGawanganInput = {
    id?: number
    produk_item_id: number
    jumlah: number
  }

  export type detail_pembelian_produkCreateManyGawanganInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    pembelian_produk_id: number
  }

  export type detail_gawanganUpdateWithoutGawanganInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_gawanganNestedInput
  }

  export type detail_gawanganUncheckedUpdateWithoutGawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_gawanganUncheckedUpdateManyWithoutGawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUpdateWithoutGawanganInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    pembelian_produk?: pembelian_produkUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
  }

  export type detail_pembelian_produkUncheckedUpdateWithoutGawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutGawanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type gawanganCreateManyOutletInput = {
    id?: number
    nama_gawangan: string
  }

  export type gawanganUpdateWithoutOutletInput = {
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    detail_gawangans?: detail_gawanganUpdateManyWithoutGawanganNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganUncheckedUpdateWithoutOutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
    detail_gawangans?: detail_gawanganUncheckedUpdateManyWithoutGawanganNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutGawanganNestedInput
  }

  export type gawanganUncheckedUpdateManyWithoutOutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_gawangan?: StringFieldUpdateOperationsInput | string
  }

  export type detail_diskonCreateManyPembelian_produkInput = {
    id?: number
    diskon_id: number
    produk_item_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_pembelian_produkCreateManyPembelian_produkInput = {
    id?: number
    jumlah: number
    diskon_id: number
    produk_item_id: number
    gawangan_id: number
  }

  export type detail_diskonUpdateWithoutPembelian_produkInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_diskonNestedInput
    produk_item?: produk_itemUpdateOneWithoutDetail_diskonNestedInput
  }

  export type detail_diskonUncheckedUpdateWithoutPembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_diskonUncheckedUpdateManyWithoutPembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUpdateWithoutPembelian_produkInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon?: diskonUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
  }

  export type detail_pembelian_produkUncheckedUpdateWithoutPembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    diskon_id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type pembelian_produkCreateManyUserInput = {
    id?: number
    tanggal_pembelian: Date | string
    nama_pembeli: string
    kontak_pembeli: string
  }

  export type pembelian_produkUpdateWithoutUserInput = {
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    detail_diskon?: detail_diskonUpdateManyWithoutPembelian_produkNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
    detail_diskon?: detail_diskonUncheckedUpdateManyWithoutPembelian_produkNestedInput
    detail_pembelian_produk?: detail_pembelian_produkUncheckedUpdateManyWithoutPembelian_produkNestedInput
  }

  export type pembelian_produkUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pembelian?: DateTimeFieldUpdateOperationsInput | Date | string
    nama_pembeli?: StringFieldUpdateOperationsInput | string
    kontak_pembeli?: StringFieldUpdateOperationsInput | string
  }

  export type detail_pembelian_produkCreateManyDiskonInput = {
    id?: number
    jumlah: number
    produk_item_id: number
    pembelian_produk_id: number
    gawangan_id: number
  }

  export type detail_diskonCreateManyDiskonInput = {
    id?: number
    produk_item_id?: number | null
    pembelian_produk_id?: number | null
    jumlah: number
    jumlah_diskon: number
  }

  export type detail_pembelian_produkUpdateWithoutDiskonInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    produk_item?: produk_itemUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    pembelian_produk?: pembelian_produkUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
    gawangan?: gawanganUpdateOneRequiredWithoutDetail_pembelian_produkNestedInput
  }

  export type detail_pembelian_produkUncheckedUpdateWithoutDiskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_pembelian_produkUncheckedUpdateManyWithoutDiskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    produk_item_id?: IntFieldUpdateOperationsInput | number
    pembelian_produk_id?: IntFieldUpdateOperationsInput | number
    gawangan_id?: IntFieldUpdateOperationsInput | number
  }

  export type detail_diskonUpdateWithoutDiskonInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
    produk_item?: produk_itemUpdateOneWithoutDetail_diskonNestedInput
    pembelian_produk?: pembelian_produkUpdateOneWithoutDetail_diskonNestedInput
  }

  export type detail_diskonUncheckedUpdateWithoutDiskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }

  export type detail_diskonUncheckedUpdateManyWithoutDiskonInput = {
    id?: IntFieldUpdateOperationsInput | number
    produk_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    pembelian_produk_id?: NullableIntFieldUpdateOperationsInput | number | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    jumlah_diskon?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Produk_itemCountOutputTypeDefaultArgs instead
     */
    export type Produk_itemCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Produk_itemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProduksiCountOutputTypeDefaultArgs instead
     */
    export type ProduksiCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ProduksiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Kategori_produkCountOutputTypeDefaultArgs instead
     */
    export type Kategori_produkCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PembuatCountOutputTypeDefaultArgs instead
     */
    export type PembuatCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PembuatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Stok_bahanCountOutputTypeDefaultArgs instead
     */
    export type Stok_bahanCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Stok_bahanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Pengecekan_produkCountOutputTypeDefaultArgs instead
     */
    export type Pengecekan_produkCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Pengecekan_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Kondisi_produkCountOutputTypeDefaultArgs instead
     */
    export type Kondisi_produkCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Kondisi_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Pengecekan_bahanCountOutputTypeDefaultArgs instead
     */
    export type Pengecekan_bahanCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Pengecekan_bahanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Kondisi_bahanCountOutputTypeDefaultArgs instead
     */
    export type Kondisi_bahanCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Kondisi_bahanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Pemesanan_bahanCountOutputTypeDefaultArgs instead
     */
    export type Pemesanan_bahanCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Pemesanan_bahanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GawanganCountOutputTypeDefaultArgs instead
     */
    export type GawanganCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = GawanganCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutletCountOutputTypeDefaultArgs instead
     */
    export type OutletCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OutletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Pembelian_produkCountOutputTypeDefaultArgs instead
     */
    export type Pembelian_produkCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = Pembelian_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiskonCountOutputTypeDefaultArgs instead
     */
    export type DiskonCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DiskonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use produk_itemDefaultArgs instead
     */
    export type produk_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = produk_itemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use produksiDefaultArgs instead
     */
    export type produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = produksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kategori_produkDefaultArgs instead
     */
    export type kategori_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = kategori_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pembuatDefaultArgs instead
     */
    export type pembuatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = pembuatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bahan_produksiDefaultArgs instead
     */
    export type bahan_produksiArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = bahan_produksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use stok_bahanDefaultArgs instead
     */
    export type stok_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = stok_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_pengecekan_produkDefaultArgs instead
     */
    export type detail_pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_pengecekan_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pengecekan_produkDefaultArgs instead
     */
    export type pengecekan_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = pengecekan_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kondisi_produkDefaultArgs instead
     */
    export type kondisi_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = kondisi_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_pengecekan_bahanDefaultArgs instead
     */
    export type detail_pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_pengecekan_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pengecekan_bahanDefaultArgs instead
     */
    export type pengecekan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = pengecekan_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kondisi_bahanDefaultArgs instead
     */
    export type kondisi_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = kondisi_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_pemesanan_bahanDefaultArgs instead
     */
    export type detail_pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_pemesanan_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pemesanan_bahanDefaultArgs instead
     */
    export type pemesanan_bahanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = pemesanan_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplierDefaultArgs instead
     */
    export type supplierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = supplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_gawanganDefaultArgs instead
     */
    export type detail_gawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_gawanganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gawanganDefaultArgs instead
     */
    export type gawanganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = gawanganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use outletDefaultArgs instead
     */
    export type outletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = outletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pembelian_produkDefaultArgs instead
     */
    export type pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = pembelian_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_pembelian_produkDefaultArgs instead
     */
    export type detail_pembelian_produkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_pembelian_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use diskonDefaultArgs instead
     */
    export type diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = diskonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_diskonDefaultArgs instead
     */
    export type detail_diskonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = detail_diskonDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}