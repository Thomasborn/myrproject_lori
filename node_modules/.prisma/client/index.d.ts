
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model karyawan
 * 
 */
export type karyawan = $Result.DefaultSelection<Prisma.$karyawanPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model akses
 * 
 */
export type akses = $Result.DefaultSelection<Prisma.$aksesPayload>
/**
 * Model fungsi
 * 
 */
export type fungsi = $Result.DefaultSelection<Prisma.$fungsiPayload>
/**
 * Model hak_akses
 * 
 */
export type hak_akses = $Result.DefaultSelection<Prisma.$hak_aksesPayload>
/**
 * Model model_produk
 * 
 */
export type model_produk = $Result.DefaultSelection<Prisma.$model_produkPayload>
/**
 * Model foto_produk
 * 
 */
export type foto_produk = $Result.DefaultSelection<Prisma.$foto_produkPayload>
/**
 * Model kategori_produk
 * 
 */
export type kategori_produk = $Result.DefaultSelection<Prisma.$kategori_produkPayload>
/**
 * Model detail_model_produk
 * 
 */
export type detail_model_produk = $Result.DefaultSelection<Prisma.$detail_model_produkPayload>
/**
 * Model bahan_produk
 * 
 */
export type bahan_produk = $Result.DefaultSelection<Prisma.$bahan_produkPayload>
/**
 * Model daftar_bahan
 * 
 */
export type daftar_bahan = $Result.DefaultSelection<Prisma.$daftar_bahanPayload>
/**
 * Model restok_bahan
 * 
 */
export type restok_bahan = $Result.DefaultSelection<Prisma.$restok_bahanPayload>
/**
 * Model supplier
 * 
 */
export type supplier = $Result.DefaultSelection<Prisma.$supplierPayload>
/**
 * Model produksi
 * 
 */
export type produksi = $Result.DefaultSelection<Prisma.$produksiPayload>
/**
 * Model qcproduksi
 * 
 */
export type qcproduksi = $Result.DefaultSelection<Prisma.$qcproduksiPayload>
/**
 * Model daftar_produk
 * 
 */
export type daftar_produk = $Result.DefaultSelection<Prisma.$daftar_produkPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.karyawan`: Exposes CRUD operations for the **karyawan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Karyawans
    * const karyawans = await prisma.karyawan.findMany()
    * ```
    */
  get karyawan(): Prisma.karyawanDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs>;

  /**
   * `prisma.akses`: Exposes CRUD operations for the **akses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Akses
    * const akses = await prisma.akses.findMany()
    * ```
    */
  get akses(): Prisma.aksesDelegate<ExtArgs>;

  /**
   * `prisma.fungsi`: Exposes CRUD operations for the **fungsi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fungsis
    * const fungsis = await prisma.fungsi.findMany()
    * ```
    */
  get fungsi(): Prisma.fungsiDelegate<ExtArgs>;

  /**
   * `prisma.hak_akses`: Exposes CRUD operations for the **hak_akses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hak_akses
    * const hak_akses = await prisma.hak_akses.findMany()
    * ```
    */
  get hak_akses(): Prisma.hak_aksesDelegate<ExtArgs>;

  /**
   * `prisma.model_produk`: Exposes CRUD operations for the **model_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Model_produks
    * const model_produks = await prisma.model_produk.findMany()
    * ```
    */
  get model_produk(): Prisma.model_produkDelegate<ExtArgs>;

  /**
   * `prisma.foto_produk`: Exposes CRUD operations for the **foto_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foto_produks
    * const foto_produks = await prisma.foto_produk.findMany()
    * ```
    */
  get foto_produk(): Prisma.foto_produkDelegate<ExtArgs>;

  /**
   * `prisma.kategori_produk`: Exposes CRUD operations for the **kategori_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kategori_produks
    * const kategori_produks = await prisma.kategori_produk.findMany()
    * ```
    */
  get kategori_produk(): Prisma.kategori_produkDelegate<ExtArgs>;

  /**
   * `prisma.detail_model_produk`: Exposes CRUD operations for the **detail_model_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detail_model_produks
    * const detail_model_produks = await prisma.detail_model_produk.findMany()
    * ```
    */
  get detail_model_produk(): Prisma.detail_model_produkDelegate<ExtArgs>;

  /**
   * `prisma.bahan_produk`: Exposes CRUD operations for the **bahan_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bahan_produks
    * const bahan_produks = await prisma.bahan_produk.findMany()
    * ```
    */
  get bahan_produk(): Prisma.bahan_produkDelegate<ExtArgs>;

  /**
   * `prisma.daftar_bahan`: Exposes CRUD operations for the **daftar_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Daftar_bahans
    * const daftar_bahans = await prisma.daftar_bahan.findMany()
    * ```
    */
  get daftar_bahan(): Prisma.daftar_bahanDelegate<ExtArgs>;

  /**
   * `prisma.restok_bahan`: Exposes CRUD operations for the **restok_bahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restok_bahans
    * const restok_bahans = await prisma.restok_bahan.findMany()
    * ```
    */
  get restok_bahan(): Prisma.restok_bahanDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<ExtArgs>;

  /**
   * `prisma.produksi`: Exposes CRUD operations for the **produksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produksis
    * const produksis = await prisma.produksi.findMany()
    * ```
    */
  get produksi(): Prisma.produksiDelegate<ExtArgs>;

  /**
   * `prisma.qcproduksi`: Exposes CRUD operations for the **qcproduksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qcproduksis
    * const qcproduksis = await prisma.qcproduksi.findMany()
    * ```
    */
  get qcproduksi(): Prisma.qcproduksiDelegate<ExtArgs>;

  /**
   * `prisma.daftar_produk`: Exposes CRUD operations for the **daftar_produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Daftar_produks
    * const daftar_produks = await prisma.daftar_produk.findMany()
    * ```
    */
  get daftar_produk(): Prisma.daftar_produkDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    karyawan: 'karyawan',
    role: 'role',
    akses: 'akses',
    fungsi: 'fungsi',
    hak_akses: 'hak_akses',
    model_produk: 'model_produk',
    foto_produk: 'foto_produk',
    kategori_produk: 'kategori_produk',
    detail_model_produk: 'detail_model_produk',
    bahan_produk: 'bahan_produk',
    daftar_bahan: 'daftar_bahan',
    restok_bahan: 'restok_bahan',
    supplier: 'supplier',
    produksi: 'produksi',
    qcproduksi: 'qcproduksi',
    daftar_produk: 'daftar_produk'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'karyawan' | 'role' | 'akses' | 'fungsi' | 'hak_akses' | 'model_produk' | 'foto_produk' | 'kategori_produk' | 'detail_model_produk' | 'bahan_produk' | 'daftar_bahan' | 'restok_bahan' | 'supplier' | 'produksi' | 'qcproduksi' | 'daftar_produk'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      karyawan: {
        payload: Prisma.$karyawanPayload<ExtArgs>
        fields: Prisma.karyawanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.karyawanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.karyawanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          findFirst: {
            args: Prisma.karyawanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.karyawanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          findMany: {
            args: Prisma.karyawanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>[]
          }
          create: {
            args: Prisma.karyawanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          createMany: {
            args: Prisma.karyawanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.karyawanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          update: {
            args: Prisma.karyawanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          deleteMany: {
            args: Prisma.karyawanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.karyawanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.karyawanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$karyawanPayload>
          }
          aggregate: {
            args: Prisma.KaryawanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKaryawan>
          }
          groupBy: {
            args: Prisma.karyawanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KaryawanGroupByOutputType>[]
          }
          count: {
            args: Prisma.karyawanCountArgs<ExtArgs>,
            result: $Utils.Optional<KaryawanCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      akses: {
        payload: Prisma.$aksesPayload<ExtArgs>
        fields: Prisma.aksesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aksesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aksesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          findFirst: {
            args: Prisma.aksesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aksesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          findMany: {
            args: Prisma.aksesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>[]
          }
          create: {
            args: Prisma.aksesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          createMany: {
            args: Prisma.aksesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.aksesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          update: {
            args: Prisma.aksesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          deleteMany: {
            args: Prisma.aksesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.aksesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.aksesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$aksesPayload>
          }
          aggregate: {
            args: Prisma.AksesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAkses>
          }
          groupBy: {
            args: Prisma.aksesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AksesGroupByOutputType>[]
          }
          count: {
            args: Prisma.aksesCountArgs<ExtArgs>,
            result: $Utils.Optional<AksesCountAggregateOutputType> | number
          }
        }
      }
      fungsi: {
        payload: Prisma.$fungsiPayload<ExtArgs>
        fields: Prisma.fungsiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fungsiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fungsiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          findFirst: {
            args: Prisma.fungsiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fungsiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          findMany: {
            args: Prisma.fungsiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>[]
          }
          create: {
            args: Prisma.fungsiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          createMany: {
            args: Prisma.fungsiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fungsiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          update: {
            args: Prisma.fungsiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          deleteMany: {
            args: Prisma.fungsiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fungsiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fungsiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fungsiPayload>
          }
          aggregate: {
            args: Prisma.FungsiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFungsi>
          }
          groupBy: {
            args: Prisma.fungsiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FungsiGroupByOutputType>[]
          }
          count: {
            args: Prisma.fungsiCountArgs<ExtArgs>,
            result: $Utils.Optional<FungsiCountAggregateOutputType> | number
          }
        }
      }
      hak_akses: {
        payload: Prisma.$hak_aksesPayload<ExtArgs>
        fields: Prisma.hak_aksesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hak_aksesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hak_aksesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          findFirst: {
            args: Prisma.hak_aksesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hak_aksesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          findMany: {
            args: Prisma.hak_aksesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>[]
          }
          create: {
            args: Prisma.hak_aksesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          createMany: {
            args: Prisma.hak_aksesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.hak_aksesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          update: {
            args: Prisma.hak_aksesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          deleteMany: {
            args: Prisma.hak_aksesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.hak_aksesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.hak_aksesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hak_aksesPayload>
          }
          aggregate: {
            args: Prisma.Hak_aksesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHak_akses>
          }
          groupBy: {
            args: Prisma.hak_aksesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Hak_aksesGroupByOutputType>[]
          }
          count: {
            args: Prisma.hak_aksesCountArgs<ExtArgs>,
            result: $Utils.Optional<Hak_aksesCountAggregateOutputType> | number
          }
        }
      }
      model_produk: {
        payload: Prisma.$model_produkPayload<ExtArgs>
        fields: Prisma.model_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.model_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.model_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          findFirst: {
            args: Prisma.model_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.model_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          findMany: {
            args: Prisma.model_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>[]
          }
          create: {
            args: Prisma.model_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          createMany: {
            args: Prisma.model_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.model_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          update: {
            args: Prisma.model_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          deleteMany: {
            args: Prisma.model_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.model_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.model_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$model_produkPayload>
          }
          aggregate: {
            args: Prisma.Model_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModel_produk>
          }
          groupBy: {
            args: Prisma.model_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Model_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.model_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Model_produkCountAggregateOutputType> | number
          }
        }
      }
      foto_produk: {
        payload: Prisma.$foto_produkPayload<ExtArgs>
        fields: Prisma.foto_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.foto_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.foto_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          findFirst: {
            args: Prisma.foto_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.foto_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          findMany: {
            args: Prisma.foto_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>[]
          }
          create: {
            args: Prisma.foto_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          createMany: {
            args: Prisma.foto_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.foto_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          update: {
            args: Prisma.foto_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          deleteMany: {
            args: Prisma.foto_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.foto_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.foto_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$foto_produkPayload>
          }
          aggregate: {
            args: Prisma.Foto_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFoto_produk>
          }
          groupBy: {
            args: Prisma.foto_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Foto_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.foto_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Foto_produkCountAggregateOutputType> | number
          }
        }
      }
      kategori_produk: {
        payload: Prisma.$kategori_produkPayload<ExtArgs>
        fields: Prisma.kategori_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategori_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategori_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          findFirst: {
            args: Prisma.kategori_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategori_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          findMany: {
            args: Prisma.kategori_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>[]
          }
          create: {
            args: Prisma.kategori_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          createMany: {
            args: Prisma.kategori_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.kategori_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          update: {
            args: Prisma.kategori_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          deleteMany: {
            args: Prisma.kategori_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.kategori_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.kategori_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kategori_produkPayload>
          }
          aggregate: {
            args: Prisma.Kategori_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKategori_produk>
          }
          groupBy: {
            args: Prisma.kategori_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Kategori_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategori_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Kategori_produkCountAggregateOutputType> | number
          }
        }
      }
      detail_model_produk: {
        payload: Prisma.$detail_model_produkPayload<ExtArgs>
        fields: Prisma.detail_model_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detail_model_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detail_model_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          findFirst: {
            args: Prisma.detail_model_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detail_model_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          findMany: {
            args: Prisma.detail_model_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>[]
          }
          create: {
            args: Prisma.detail_model_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          createMany: {
            args: Prisma.detail_model_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detail_model_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          update: {
            args: Prisma.detail_model_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          deleteMany: {
            args: Prisma.detail_model_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detail_model_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detail_model_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detail_model_produkPayload>
          }
          aggregate: {
            args: Prisma.Detail_model_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetail_model_produk>
          }
          groupBy: {
            args: Prisma.detail_model_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detail_model_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.detail_model_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Detail_model_produkCountAggregateOutputType> | number
          }
        }
      }
      bahan_produk: {
        payload: Prisma.$bahan_produkPayload<ExtArgs>
        fields: Prisma.bahan_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bahan_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bahan_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          findFirst: {
            args: Prisma.bahan_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bahan_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          findMany: {
            args: Prisma.bahan_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>[]
          }
          create: {
            args: Prisma.bahan_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          createMany: {
            args: Prisma.bahan_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bahan_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          update: {
            args: Prisma.bahan_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          deleteMany: {
            args: Prisma.bahan_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bahan_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bahan_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bahan_produkPayload>
          }
          aggregate: {
            args: Prisma.Bahan_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBahan_produk>
          }
          groupBy: {
            args: Prisma.bahan_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bahan_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.bahan_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Bahan_produkCountAggregateOutputType> | number
          }
        }
      }
      daftar_bahan: {
        payload: Prisma.$daftar_bahanPayload<ExtArgs>
        fields: Prisma.daftar_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.daftar_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.daftar_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          findFirst: {
            args: Prisma.daftar_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.daftar_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          findMany: {
            args: Prisma.daftar_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>[]
          }
          create: {
            args: Prisma.daftar_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          createMany: {
            args: Prisma.daftar_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.daftar_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          update: {
            args: Prisma.daftar_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          deleteMany: {
            args: Prisma.daftar_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.daftar_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.daftar_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_bahanPayload>
          }
          aggregate: {
            args: Prisma.Daftar_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDaftar_bahan>
          }
          groupBy: {
            args: Prisma.daftar_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Daftar_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.daftar_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Daftar_bahanCountAggregateOutputType> | number
          }
        }
      }
      restok_bahan: {
        payload: Prisma.$restok_bahanPayload<ExtArgs>
        fields: Prisma.restok_bahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.restok_bahanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.restok_bahanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          findFirst: {
            args: Prisma.restok_bahanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.restok_bahanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          findMany: {
            args: Prisma.restok_bahanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>[]
          }
          create: {
            args: Prisma.restok_bahanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          createMany: {
            args: Prisma.restok_bahanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.restok_bahanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          update: {
            args: Prisma.restok_bahanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          deleteMany: {
            args: Prisma.restok_bahanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.restok_bahanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.restok_bahanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$restok_bahanPayload>
          }
          aggregate: {
            args: Prisma.Restok_bahanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRestok_bahan>
          }
          groupBy: {
            args: Prisma.restok_bahanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Restok_bahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.restok_bahanCountArgs<ExtArgs>,
            result: $Utils.Optional<Restok_bahanCountAggregateOutputType> | number
          }
        }
      }
      supplier: {
        payload: Prisma.$supplierPayload<ExtArgs>
        fields: Prisma.supplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findFirst: {
            args: Prisma.supplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findMany: {
            args: Prisma.supplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          create: {
            args: Prisma.supplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          createMany: {
            args: Prisma.supplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.supplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          update: {
            args: Prisma.supplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          deleteMany: {
            args: Prisma.supplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.supplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.supplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.supplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      produksi: {
        payload: Prisma.$produksiPayload<ExtArgs>
        fields: Prisma.produksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produksiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produksiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          findFirst: {
            args: Prisma.produksiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produksiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          findMany: {
            args: Prisma.produksiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>[]
          }
          create: {
            args: Prisma.produksiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          createMany: {
            args: Prisma.produksiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.produksiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          update: {
            args: Prisma.produksiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          deleteMany: {
            args: Prisma.produksiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.produksiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.produksiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$produksiPayload>
          }
          aggregate: {
            args: Prisma.ProduksiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduksi>
          }
          groupBy: {
            args: Prisma.produksiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProduksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.produksiCountArgs<ExtArgs>,
            result: $Utils.Optional<ProduksiCountAggregateOutputType> | number
          }
        }
      }
      qcproduksi: {
        payload: Prisma.$qcproduksiPayload<ExtArgs>
        fields: Prisma.qcproduksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qcproduksiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qcproduksiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          findFirst: {
            args: Prisma.qcproduksiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qcproduksiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          findMany: {
            args: Prisma.qcproduksiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>[]
          }
          create: {
            args: Prisma.qcproduksiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          createMany: {
            args: Prisma.qcproduksiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.qcproduksiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          update: {
            args: Prisma.qcproduksiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          deleteMany: {
            args: Prisma.qcproduksiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.qcproduksiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.qcproduksiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$qcproduksiPayload>
          }
          aggregate: {
            args: Prisma.QcproduksiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQcproduksi>
          }
          groupBy: {
            args: Prisma.qcproduksiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QcproduksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.qcproduksiCountArgs<ExtArgs>,
            result: $Utils.Optional<QcproduksiCountAggregateOutputType> | number
          }
        }
      }
      daftar_produk: {
        payload: Prisma.$daftar_produkPayload<ExtArgs>
        fields: Prisma.daftar_produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.daftar_produkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.daftar_produkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          findFirst: {
            args: Prisma.daftar_produkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.daftar_produkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          findMany: {
            args: Prisma.daftar_produkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>[]
          }
          create: {
            args: Prisma.daftar_produkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          createMany: {
            args: Prisma.daftar_produkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.daftar_produkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          update: {
            args: Prisma.daftar_produkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          deleteMany: {
            args: Prisma.daftar_produkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.daftar_produkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.daftar_produkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$daftar_produkPayload>
          }
          aggregate: {
            args: Prisma.Daftar_produkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDaftar_produk>
          }
          groupBy: {
            args: Prisma.daftar_produkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Daftar_produkGroupByOutputType>[]
          }
          count: {
            args: Prisma.daftar_produkCountArgs<ExtArgs>,
            result: $Utils.Optional<Daftar_produkCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    produksi: number
    qcproduksi: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produksi?: boolean | UserCountOutputTypeCountProduksiArgs
    qcproduksi?: boolean | UserCountOutputTypeCountQcproduksiArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQcproduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qcproduksiWhereInput
  }



  /**
   * Count Type KaryawanCountOutputType
   */

  export type KaryawanCountOutputType = {
    users: number
  }

  export type KaryawanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | KaryawanCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * KaryawanCountOutputType without action
   */
  export type KaryawanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KaryawanCountOutputType
     */
    select?: KaryawanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * KaryawanCountOutputType without action
   */
  export type KaryawanCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    hak_akses: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    hak_akses?: boolean | RoleCountOutputTypeCountHak_aksesArgs
  }

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountHak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hak_aksesWhereInput
  }



  /**
   * Count Type AksesCountOutputType
   */

  export type AksesCountOutputType = {
    hak_akses: number
  }

  export type AksesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hak_akses?: boolean | AksesCountOutputTypeCountHak_aksesArgs
  }

  // Custom InputTypes

  /**
   * AksesCountOutputType without action
   */
  export type AksesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AksesCountOutputType
     */
    select?: AksesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AksesCountOutputType without action
   */
  export type AksesCountOutputTypeCountHak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hak_aksesWhereInput
  }



  /**
   * Count Type FungsiCountOutputType
   */

  export type FungsiCountOutputType = {
    hak_akses: number
  }

  export type FungsiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hak_akses?: boolean | FungsiCountOutputTypeCountHak_aksesArgs
  }

  // Custom InputTypes

  /**
   * FungsiCountOutputType without action
   */
  export type FungsiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FungsiCountOutputType
     */
    select?: FungsiCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FungsiCountOutputType without action
   */
  export type FungsiCountOutputTypeCountHak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hak_aksesWhereInput
  }



  /**
   * Count Type Model_produkCountOutputType
   */

  export type Model_produkCountOutputType = {
    foto_produk: number
    detail_model_produk: number
  }

  export type Model_produkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foto_produk?: boolean | Model_produkCountOutputTypeCountFoto_produkArgs
    detail_model_produk?: boolean | Model_produkCountOutputTypeCountDetail_model_produkArgs
  }

  // Custom InputTypes

  /**
   * Model_produkCountOutputType without action
   */
  export type Model_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model_produkCountOutputType
     */
    select?: Model_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Model_produkCountOutputType without action
   */
  export type Model_produkCountOutputTypeCountFoto_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: foto_produkWhereInput
  }


  /**
   * Model_produkCountOutputType without action
   */
  export type Model_produkCountOutputTypeCountDetail_model_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detail_model_produkWhereInput
  }



  /**
   * Count Type Kategori_produkCountOutputType
   */

  export type Kategori_produkCountOutputType = {
    model_produk: number
  }

  export type Kategori_produkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_produk?: boolean | Kategori_produkCountOutputTypeCountModel_produkArgs
  }

  // Custom InputTypes

  /**
   * Kategori_produkCountOutputType without action
   */
  export type Kategori_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kategori_produkCountOutputType
     */
    select?: Kategori_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Kategori_produkCountOutputType without action
   */
  export type Kategori_produkCountOutputTypeCountModel_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_produkWhereInput
  }



  /**
   * Count Type Detail_model_produkCountOutputType
   */

  export type Detail_model_produkCountOutputType = {
    bahan_produk: number
    daftar_produk: number
    produksi: number
  }

  export type Detail_model_produkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bahan_produk?: boolean | Detail_model_produkCountOutputTypeCountBahan_produkArgs
    daftar_produk?: boolean | Detail_model_produkCountOutputTypeCountDaftar_produkArgs
    produksi?: boolean | Detail_model_produkCountOutputTypeCountProduksiArgs
  }

  // Custom InputTypes

  /**
   * Detail_model_produkCountOutputType without action
   */
  export type Detail_model_produkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detail_model_produkCountOutputType
     */
    select?: Detail_model_produkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Detail_model_produkCountOutputType without action
   */
  export type Detail_model_produkCountOutputTypeCountBahan_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bahan_produkWhereInput
  }


  /**
   * Detail_model_produkCountOutputType without action
   */
  export type Detail_model_produkCountOutputTypeCountDaftar_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daftar_produkWhereInput
  }


  /**
   * Detail_model_produkCountOutputType without action
   */
  export type Detail_model_produkCountOutputTypeCountProduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
  }



  /**
   * Count Type Daftar_bahanCountOutputType
   */

  export type Daftar_bahanCountOutputType = {
    bahan_produk: number
    restok_bahan: number
  }

  export type Daftar_bahanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bahan_produk?: boolean | Daftar_bahanCountOutputTypeCountBahan_produkArgs
    restok_bahan?: boolean | Daftar_bahanCountOutputTypeCountRestok_bahanArgs
  }

  // Custom InputTypes

  /**
   * Daftar_bahanCountOutputType without action
   */
  export type Daftar_bahanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Daftar_bahanCountOutputType
     */
    select?: Daftar_bahanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Daftar_bahanCountOutputType without action
   */
  export type Daftar_bahanCountOutputTypeCountBahan_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bahan_produkWhereInput
  }


  /**
   * Daftar_bahanCountOutputType without action
   */
  export type Daftar_bahanCountOutputTypeCountRestok_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: restok_bahanWhereInput
  }



  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    restok_bahan: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restok_bahan?: boolean | SupplierCountOutputTypeCountRestok_bahanArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountRestok_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: restok_bahanWhereInput
  }



  /**
   * Count Type ProduksiCountOutputType
   */

  export type ProduksiCountOutputType = {
    qcproduksi: number
  }

  export type ProduksiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qcproduksi?: boolean | ProduksiCountOutputTypeCountQcproduksiArgs
  }

  // Custom InputTypes

  /**
   * ProduksiCountOutputType without action
   */
  export type ProduksiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProduksiCountOutputType
     */
    select?: ProduksiCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProduksiCountOutputType without action
   */
  export type ProduksiCountOutputTypeCountQcproduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qcproduksiWhereInput
  }



  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    karyawan_id: number | null
    role_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    karyawan_id: number | null
    role_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    karyawan_id: number | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    karyawan_id: number | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    karyawan_id: number
    role_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    karyawan_id?: true
    role_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    karyawan_id?: true
    role_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    karyawan_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    karyawan_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    karyawan_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    karyawan_id: number
    role_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    karyawan_id?: boolean
    role_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    karyawan?: boolean | karyawanDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    produksi?: boolean | user$produksiArgs<ExtArgs>
    qcproduksi?: boolean | user$qcproduksiArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    karyawan_id?: boolean
    role_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    karyawan?: boolean | karyawanDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    produksi?: boolean | user$produksiArgs<ExtArgs>
    qcproduksi?: boolean | user$qcproduksiArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      karyawan: Prisma.$karyawanPayload<ExtArgs>
      role: Prisma.$rolePayload<ExtArgs>
      produksi: Prisma.$produksiPayload<ExtArgs>[]
      qcproduksi: Prisma.$qcproduksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      karyawan_id: number
      role_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    karyawan<T extends karyawanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, karyawanDefaultArgs<ExtArgs>>): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produksi<T extends user$produksiArgs<ExtArgs> = {}>(args?: Subset<T, user$produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    qcproduksi<T extends user$qcproduksiArgs<ExtArgs> = {}>(args?: Subset<T, user$qcproduksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly karyawan_id: FieldRef<"user", 'Int'>
    readonly role_id: FieldRef<"user", 'Int'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly deleted_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.produksi
   */
  export type user$produksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    cursor?: produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * user.qcproduksi
   */
  export type user$qcproduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    where?: qcproduksiWhereInput
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    cursor?: qcproduksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcproduksiScalarFieldEnum | QcproduksiScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model karyawan
   */

  export type AggregateKaryawan = {
    _count: KaryawanCountAggregateOutputType | null
    _avg: KaryawanAvgAggregateOutputType | null
    _sum: KaryawanSumAggregateOutputType | null
    _min: KaryawanMinAggregateOutputType | null
    _max: KaryawanMaxAggregateOutputType | null
  }

  export type KaryawanAvgAggregateOutputType = {
    id: number | null
  }

  export type KaryawanSumAggregateOutputType = {
    id: number | null
  }

  export type KaryawanMinAggregateOutputType = {
    id: number | null
    nama: string | null
    nik: string | null
    alamat: string | null
    kontak: string | null
    tanggal_lahir: Date | null
    jenis_kelamin: string | null
    no_rekening: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type KaryawanMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    nik: string | null
    alamat: string | null
    kontak: string | null
    tanggal_lahir: Date | null
    jenis_kelamin: string | null
    no_rekening: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type KaryawanCountAggregateOutputType = {
    id: number
    nama: number
    nik: number
    alamat: number
    kontak: number
    tanggal_lahir: number
    jenis_kelamin: number
    no_rekening: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type KaryawanAvgAggregateInputType = {
    id?: true
  }

  export type KaryawanSumAggregateInputType = {
    id?: true
  }

  export type KaryawanMinAggregateInputType = {
    id?: true
    nama?: true
    nik?: true
    alamat?: true
    kontak?: true
    tanggal_lahir?: true
    jenis_kelamin?: true
    no_rekening?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type KaryawanMaxAggregateInputType = {
    id?: true
    nama?: true
    nik?: true
    alamat?: true
    kontak?: true
    tanggal_lahir?: true
    jenis_kelamin?: true
    no_rekening?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type KaryawanCountAggregateInputType = {
    id?: true
    nama?: true
    nik?: true
    alamat?: true
    kontak?: true
    tanggal_lahir?: true
    jenis_kelamin?: true
    no_rekening?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type KaryawanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which karyawan to aggregate.
     */
    where?: karyawanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karyawans to fetch.
     */
    orderBy?: karyawanOrderByWithRelationInput | karyawanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: karyawanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karyawans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karyawans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned karyawans
    **/
    _count?: true | KaryawanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KaryawanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KaryawanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KaryawanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KaryawanMaxAggregateInputType
  }

  export type GetKaryawanAggregateType<T extends KaryawanAggregateArgs> = {
        [P in keyof T & keyof AggregateKaryawan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKaryawan[P]>
      : GetScalarType<T[P], AggregateKaryawan[P]>
  }




  export type karyawanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: karyawanWhereInput
    orderBy?: karyawanOrderByWithAggregationInput | karyawanOrderByWithAggregationInput[]
    by: KaryawanScalarFieldEnum[] | KaryawanScalarFieldEnum
    having?: karyawanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KaryawanCountAggregateInputType | true
    _avg?: KaryawanAvgAggregateInputType
    _sum?: KaryawanSumAggregateInputType
    _min?: KaryawanMinAggregateInputType
    _max?: KaryawanMaxAggregateInputType
  }

  export type KaryawanGroupByOutputType = {
    id: number
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date
    jenis_kelamin: string
    no_rekening: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: KaryawanCountAggregateOutputType | null
    _avg: KaryawanAvgAggregateOutputType | null
    _sum: KaryawanSumAggregateOutputType | null
    _min: KaryawanMinAggregateOutputType | null
    _max: KaryawanMaxAggregateOutputType | null
  }

  type GetKaryawanGroupByPayload<T extends karyawanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KaryawanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KaryawanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KaryawanGroupByOutputType[P]>
            : GetScalarType<T[P], KaryawanGroupByOutputType[P]>
        }
      >
    >


  export type karyawanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    nik?: boolean
    alamat?: boolean
    kontak?: boolean
    tanggal_lahir?: boolean
    jenis_kelamin?: boolean
    no_rekening?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | karyawan$usersArgs<ExtArgs>
    _count?: boolean | KaryawanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["karyawan"]>

  export type karyawanSelectScalar = {
    id?: boolean
    nama?: boolean
    nik?: boolean
    alamat?: boolean
    kontak?: boolean
    tanggal_lahir?: boolean
    jenis_kelamin?: boolean
    no_rekening?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type karyawanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | karyawan$usersArgs<ExtArgs>
    _count?: boolean | KaryawanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $karyawanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "karyawan"
    objects: {
      users: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      nik: string
      alamat: string
      kontak: string
      tanggal_lahir: Date
      jenis_kelamin: string
      no_rekening: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["karyawan"]>
    composites: {}
  }


  type karyawanGetPayload<S extends boolean | null | undefined | karyawanDefaultArgs> = $Result.GetResult<Prisma.$karyawanPayload, S>

  type karyawanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<karyawanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: KaryawanCountAggregateInputType | true
    }

  export interface karyawanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['karyawan'], meta: { name: 'karyawan' } }
    /**
     * Find zero or one Karyawan that matches the filter.
     * @param {karyawanFindUniqueArgs} args - Arguments to find a Karyawan
     * @example
     * // Get one Karyawan
     * const karyawan = await prisma.karyawan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends karyawanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanFindUniqueArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Karyawan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {karyawanFindUniqueOrThrowArgs} args - Arguments to find a Karyawan
     * @example
     * // Get one Karyawan
     * const karyawan = await prisma.karyawan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends karyawanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Karyawan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanFindFirstArgs} args - Arguments to find a Karyawan
     * @example
     * // Get one Karyawan
     * const karyawan = await prisma.karyawan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends karyawanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanFindFirstArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Karyawan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanFindFirstOrThrowArgs} args - Arguments to find a Karyawan
     * @example
     * // Get one Karyawan
     * const karyawan = await prisma.karyawan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends karyawanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Karyawans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Karyawans
     * const karyawans = await prisma.karyawan.findMany()
     * 
     * // Get first 10 Karyawans
     * const karyawans = await prisma.karyawan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const karyawanWithIdOnly = await prisma.karyawan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends karyawanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Karyawan.
     * @param {karyawanCreateArgs} args - Arguments to create a Karyawan.
     * @example
     * // Create one Karyawan
     * const Karyawan = await prisma.karyawan.create({
     *   data: {
     *     // ... data to create a Karyawan
     *   }
     * })
     * 
    **/
    create<T extends karyawanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanCreateArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Karyawans.
     *     @param {karyawanCreateManyArgs} args - Arguments to create many Karyawans.
     *     @example
     *     // Create many Karyawans
     *     const karyawan = await prisma.karyawan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends karyawanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Karyawan.
     * @param {karyawanDeleteArgs} args - Arguments to delete one Karyawan.
     * @example
     * // Delete one Karyawan
     * const Karyawan = await prisma.karyawan.delete({
     *   where: {
     *     // ... filter to delete one Karyawan
     *   }
     * })
     * 
    **/
    delete<T extends karyawanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanDeleteArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Karyawan.
     * @param {karyawanUpdateArgs} args - Arguments to update one Karyawan.
     * @example
     * // Update one Karyawan
     * const karyawan = await prisma.karyawan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends karyawanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanUpdateArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Karyawans.
     * @param {karyawanDeleteManyArgs} args - Arguments to filter Karyawans to delete.
     * @example
     * // Delete a few Karyawans
     * const { count } = await prisma.karyawan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends karyawanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, karyawanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Karyawans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Karyawans
     * const karyawan = await prisma.karyawan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends karyawanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Karyawan.
     * @param {karyawanUpsertArgs} args - Arguments to update or create a Karyawan.
     * @example
     * // Update or create a Karyawan
     * const karyawan = await prisma.karyawan.upsert({
     *   create: {
     *     // ... data to create a Karyawan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Karyawan we want to update
     *   }
     * })
    **/
    upsert<T extends karyawanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, karyawanUpsertArgs<ExtArgs>>
    ): Prisma__karyawanClient<$Result.GetResult<Prisma.$karyawanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Karyawans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanCountArgs} args - Arguments to filter Karyawans to count.
     * @example
     * // Count the number of Karyawans
     * const count = await prisma.karyawan.count({
     *   where: {
     *     // ... the filter for the Karyawans we want to count
     *   }
     * })
    **/
    count<T extends karyawanCountArgs>(
      args?: Subset<T, karyawanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KaryawanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Karyawan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KaryawanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KaryawanAggregateArgs>(args: Subset<T, KaryawanAggregateArgs>): Prisma.PrismaPromise<GetKaryawanAggregateType<T>>

    /**
     * Group by Karyawan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {karyawanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends karyawanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: karyawanGroupByArgs['orderBy'] }
        : { orderBy?: karyawanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, karyawanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKaryawanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the karyawan model
   */
  readonly fields: karyawanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for karyawan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__karyawanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends karyawan$usersArgs<ExtArgs> = {}>(args?: Subset<T, karyawan$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the karyawan model
   */ 
  interface karyawanFieldRefs {
    readonly id: FieldRef<"karyawan", 'Int'>
    readonly nama: FieldRef<"karyawan", 'String'>
    readonly nik: FieldRef<"karyawan", 'String'>
    readonly alamat: FieldRef<"karyawan", 'String'>
    readonly kontak: FieldRef<"karyawan", 'String'>
    readonly tanggal_lahir: FieldRef<"karyawan", 'DateTime'>
    readonly jenis_kelamin: FieldRef<"karyawan", 'String'>
    readonly no_rekening: FieldRef<"karyawan", 'String'>
    readonly created_at: FieldRef<"karyawan", 'DateTime'>
    readonly updated_at: FieldRef<"karyawan", 'DateTime'>
    readonly deleted_at: FieldRef<"karyawan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * karyawan findUnique
   */
  export type karyawanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter, which karyawan to fetch.
     */
    where: karyawanWhereUniqueInput
  }


  /**
   * karyawan findUniqueOrThrow
   */
  export type karyawanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter, which karyawan to fetch.
     */
    where: karyawanWhereUniqueInput
  }


  /**
   * karyawan findFirst
   */
  export type karyawanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter, which karyawan to fetch.
     */
    where?: karyawanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karyawans to fetch.
     */
    orderBy?: karyawanOrderByWithRelationInput | karyawanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for karyawans.
     */
    cursor?: karyawanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karyawans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karyawans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of karyawans.
     */
    distinct?: KaryawanScalarFieldEnum | KaryawanScalarFieldEnum[]
  }


  /**
   * karyawan findFirstOrThrow
   */
  export type karyawanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter, which karyawan to fetch.
     */
    where?: karyawanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karyawans to fetch.
     */
    orderBy?: karyawanOrderByWithRelationInput | karyawanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for karyawans.
     */
    cursor?: karyawanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karyawans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karyawans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of karyawans.
     */
    distinct?: KaryawanScalarFieldEnum | KaryawanScalarFieldEnum[]
  }


  /**
   * karyawan findMany
   */
  export type karyawanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter, which karyawans to fetch.
     */
    where?: karyawanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karyawans to fetch.
     */
    orderBy?: karyawanOrderByWithRelationInput | karyawanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing karyawans.
     */
    cursor?: karyawanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karyawans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karyawans.
     */
    skip?: number
    distinct?: KaryawanScalarFieldEnum | KaryawanScalarFieldEnum[]
  }


  /**
   * karyawan create
   */
  export type karyawanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * The data needed to create a karyawan.
     */
    data: XOR<karyawanCreateInput, karyawanUncheckedCreateInput>
  }


  /**
   * karyawan createMany
   */
  export type karyawanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many karyawans.
     */
    data: karyawanCreateManyInput | karyawanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * karyawan update
   */
  export type karyawanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * The data needed to update a karyawan.
     */
    data: XOR<karyawanUpdateInput, karyawanUncheckedUpdateInput>
    /**
     * Choose, which karyawan to update.
     */
    where: karyawanWhereUniqueInput
  }


  /**
   * karyawan updateMany
   */
  export type karyawanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update karyawans.
     */
    data: XOR<karyawanUpdateManyMutationInput, karyawanUncheckedUpdateManyInput>
    /**
     * Filter which karyawans to update
     */
    where?: karyawanWhereInput
  }


  /**
   * karyawan upsert
   */
  export type karyawanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * The filter to search for the karyawan to update in case it exists.
     */
    where: karyawanWhereUniqueInput
    /**
     * In case the karyawan found by the `where` argument doesn't exist, create a new karyawan with this data.
     */
    create: XOR<karyawanCreateInput, karyawanUncheckedCreateInput>
    /**
     * In case the karyawan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<karyawanUpdateInput, karyawanUncheckedUpdateInput>
  }


  /**
   * karyawan delete
   */
  export type karyawanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
    /**
     * Filter which karyawan to delete.
     */
    where: karyawanWhereUniqueInput
  }


  /**
   * karyawan deleteMany
   */
  export type karyawanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which karyawans to delete
     */
    where?: karyawanWhereInput
  }


  /**
   * karyawan.users
   */
  export type karyawan$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * karyawan without action
   */
  export type karyawanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the karyawan
     */
    select?: karyawanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: karyawanInclude<ExtArgs> | null
  }



  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    nama: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    nama: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | role$usersArgs<ExtArgs>
    hak_akses?: boolean | role$hak_aksesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | role$usersArgs<ExtArgs>
    hak_akses?: boolean | role$hak_aksesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      users: Prisma.$userPayload<ExtArgs>[]
      hak_akses: Prisma.$hak_aksesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }


  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends roleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends roleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, roleCreateArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {roleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends roleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends roleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, roleDeleteArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpdateArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends roleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpsertArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends role$usersArgs<ExtArgs> = {}>(args?: Subset<T, role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    hak_akses<T extends role$hak_aksesArgs<ExtArgs> = {}>(args?: Subset<T, role$hak_aksesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the role model
   */ 
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'Int'>
    readonly nama: FieldRef<"role", 'String'>
    readonly created_at: FieldRef<"role", 'DateTime'>
    readonly updated_at: FieldRef<"role", 'DateTime'>
    readonly deleted_at: FieldRef<"role", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }


  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
  }


  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }


  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
  }


  /**
   * role.users
   */
  export type role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * role.hak_akses
   */
  export type role$hak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    where?: hak_aksesWhereInput
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    cursor?: hak_aksesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
  }



  /**
   * Model akses
   */

  export type AggregateAkses = {
    _count: AksesCountAggregateOutputType | null
    _avg: AksesAvgAggregateOutputType | null
    _sum: AksesSumAggregateOutputType | null
    _min: AksesMinAggregateOutputType | null
    _max: AksesMaxAggregateOutputType | null
  }

  export type AksesAvgAggregateOutputType = {
    id: number | null
  }

  export type AksesSumAggregateOutputType = {
    id: number | null
  }

  export type AksesMinAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AksesMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AksesCountAggregateOutputType = {
    id: number
    nama: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type AksesAvgAggregateInputType = {
    id?: true
  }

  export type AksesSumAggregateInputType = {
    id?: true
  }

  export type AksesMinAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AksesMaxAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AksesCountAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AksesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which akses to aggregate.
     */
    where?: aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of akses to fetch.
     */
    orderBy?: aksesOrderByWithRelationInput | aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned akses
    **/
    _count?: true | AksesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AksesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AksesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AksesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AksesMaxAggregateInputType
  }

  export type GetAksesAggregateType<T extends AksesAggregateArgs> = {
        [P in keyof T & keyof AggregateAkses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAkses[P]>
      : GetScalarType<T[P], AggregateAkses[P]>
  }




  export type aksesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aksesWhereInput
    orderBy?: aksesOrderByWithAggregationInput | aksesOrderByWithAggregationInput[]
    by: AksesScalarFieldEnum[] | AksesScalarFieldEnum
    having?: aksesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AksesCountAggregateInputType | true
    _avg?: AksesAvgAggregateInputType
    _sum?: AksesSumAggregateInputType
    _min?: AksesMinAggregateInputType
    _max?: AksesMaxAggregateInputType
  }

  export type AksesGroupByOutputType = {
    id: number
    nama: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: AksesCountAggregateOutputType | null
    _avg: AksesAvgAggregateOutputType | null
    _sum: AksesSumAggregateOutputType | null
    _min: AksesMinAggregateOutputType | null
    _max: AksesMaxAggregateOutputType | null
  }

  type GetAksesGroupByPayload<T extends aksesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AksesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AksesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AksesGroupByOutputType[P]>
            : GetScalarType<T[P], AksesGroupByOutputType[P]>
        }
      >
    >


  export type aksesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    hak_akses?: boolean | akses$hak_aksesArgs<ExtArgs>
    _count?: boolean | AksesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["akses"]>

  export type aksesSelectScalar = {
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type aksesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hak_akses?: boolean | akses$hak_aksesArgs<ExtArgs>
    _count?: boolean | AksesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $aksesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "akses"
    objects: {
      hak_akses: Prisma.$hak_aksesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["akses"]>
    composites: {}
  }


  type aksesGetPayload<S extends boolean | null | undefined | aksesDefaultArgs> = $Result.GetResult<Prisma.$aksesPayload, S>

  type aksesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<aksesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AksesCountAggregateInputType | true
    }

  export interface aksesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['akses'], meta: { name: 'akses' } }
    /**
     * Find zero or one Akses that matches the filter.
     * @param {aksesFindUniqueArgs} args - Arguments to find a Akses
     * @example
     * // Get one Akses
     * const akses = await prisma.akses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends aksesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, aksesFindUniqueArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Akses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {aksesFindUniqueOrThrowArgs} args - Arguments to find a Akses
     * @example
     * // Get one Akses
     * const akses = await prisma.akses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends aksesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Akses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesFindFirstArgs} args - Arguments to find a Akses
     * @example
     * // Get one Akses
     * const akses = await prisma.akses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends aksesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesFindFirstArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Akses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesFindFirstOrThrowArgs} args - Arguments to find a Akses
     * @example
     * // Get one Akses
     * const akses = await prisma.akses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends aksesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Akses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Akses
     * const akses = await prisma.akses.findMany()
     * 
     * // Get first 10 Akses
     * const akses = await prisma.akses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aksesWithIdOnly = await prisma.akses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends aksesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Akses.
     * @param {aksesCreateArgs} args - Arguments to create a Akses.
     * @example
     * // Create one Akses
     * const Akses = await prisma.akses.create({
     *   data: {
     *     // ... data to create a Akses
     *   }
     * })
     * 
    **/
    create<T extends aksesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, aksesCreateArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Akses.
     *     @param {aksesCreateManyArgs} args - Arguments to create many Akses.
     *     @example
     *     // Create many Akses
     *     const akses = await prisma.akses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends aksesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Akses.
     * @param {aksesDeleteArgs} args - Arguments to delete one Akses.
     * @example
     * // Delete one Akses
     * const Akses = await prisma.akses.delete({
     *   where: {
     *     // ... filter to delete one Akses
     *   }
     * })
     * 
    **/
    delete<T extends aksesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, aksesDeleteArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Akses.
     * @param {aksesUpdateArgs} args - Arguments to update one Akses.
     * @example
     * // Update one Akses
     * const akses = await prisma.akses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends aksesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, aksesUpdateArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Akses.
     * @param {aksesDeleteManyArgs} args - Arguments to filter Akses to delete.
     * @example
     * // Delete a few Akses
     * const { count } = await prisma.akses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends aksesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aksesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Akses
     * const akses = await prisma.akses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends aksesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, aksesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Akses.
     * @param {aksesUpsertArgs} args - Arguments to update or create a Akses.
     * @example
     * // Update or create a Akses
     * const akses = await prisma.akses.upsert({
     *   create: {
     *     // ... data to create a Akses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Akses we want to update
     *   }
     * })
    **/
    upsert<T extends aksesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, aksesUpsertArgs<ExtArgs>>
    ): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesCountArgs} args - Arguments to filter Akses to count.
     * @example
     * // Count the number of Akses
     * const count = await prisma.akses.count({
     *   where: {
     *     // ... the filter for the Akses we want to count
     *   }
     * })
    **/
    count<T extends aksesCountArgs>(
      args?: Subset<T, aksesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AksesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AksesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AksesAggregateArgs>(args: Subset<T, AksesAggregateArgs>): Prisma.PrismaPromise<GetAksesAggregateType<T>>

    /**
     * Group by Akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aksesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aksesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aksesGroupByArgs['orderBy'] }
        : { orderBy?: aksesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aksesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAksesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the akses model
   */
  readonly fields: aksesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for akses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aksesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    hak_akses<T extends akses$hak_aksesArgs<ExtArgs> = {}>(args?: Subset<T, akses$hak_aksesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the akses model
   */ 
  interface aksesFieldRefs {
    readonly id: FieldRef<"akses", 'Int'>
    readonly nama: FieldRef<"akses", 'String'>
    readonly created_at: FieldRef<"akses", 'DateTime'>
    readonly updated_at: FieldRef<"akses", 'DateTime'>
    readonly deleted_at: FieldRef<"akses", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * akses findUnique
   */
  export type aksesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter, which akses to fetch.
     */
    where: aksesWhereUniqueInput
  }


  /**
   * akses findUniqueOrThrow
   */
  export type aksesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter, which akses to fetch.
     */
    where: aksesWhereUniqueInput
  }


  /**
   * akses findFirst
   */
  export type aksesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter, which akses to fetch.
     */
    where?: aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of akses to fetch.
     */
    orderBy?: aksesOrderByWithRelationInput | aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for akses.
     */
    cursor?: aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of akses.
     */
    distinct?: AksesScalarFieldEnum | AksesScalarFieldEnum[]
  }


  /**
   * akses findFirstOrThrow
   */
  export type aksesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter, which akses to fetch.
     */
    where?: aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of akses to fetch.
     */
    orderBy?: aksesOrderByWithRelationInput | aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for akses.
     */
    cursor?: aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of akses.
     */
    distinct?: AksesScalarFieldEnum | AksesScalarFieldEnum[]
  }


  /**
   * akses findMany
   */
  export type aksesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter, which akses to fetch.
     */
    where?: aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of akses to fetch.
     */
    orderBy?: aksesOrderByWithRelationInput | aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing akses.
     */
    cursor?: aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` akses.
     */
    skip?: number
    distinct?: AksesScalarFieldEnum | AksesScalarFieldEnum[]
  }


  /**
   * akses create
   */
  export type aksesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * The data needed to create a akses.
     */
    data: XOR<aksesCreateInput, aksesUncheckedCreateInput>
  }


  /**
   * akses createMany
   */
  export type aksesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many akses.
     */
    data: aksesCreateManyInput | aksesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * akses update
   */
  export type aksesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * The data needed to update a akses.
     */
    data: XOR<aksesUpdateInput, aksesUncheckedUpdateInput>
    /**
     * Choose, which akses to update.
     */
    where: aksesWhereUniqueInput
  }


  /**
   * akses updateMany
   */
  export type aksesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update akses.
     */
    data: XOR<aksesUpdateManyMutationInput, aksesUncheckedUpdateManyInput>
    /**
     * Filter which akses to update
     */
    where?: aksesWhereInput
  }


  /**
   * akses upsert
   */
  export type aksesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * The filter to search for the akses to update in case it exists.
     */
    where: aksesWhereUniqueInput
    /**
     * In case the akses found by the `where` argument doesn't exist, create a new akses with this data.
     */
    create: XOR<aksesCreateInput, aksesUncheckedCreateInput>
    /**
     * In case the akses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aksesUpdateInput, aksesUncheckedUpdateInput>
  }


  /**
   * akses delete
   */
  export type aksesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
    /**
     * Filter which akses to delete.
     */
    where: aksesWhereUniqueInput
  }


  /**
   * akses deleteMany
   */
  export type aksesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which akses to delete
     */
    where?: aksesWhereInput
  }


  /**
   * akses.hak_akses
   */
  export type akses$hak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    where?: hak_aksesWhereInput
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    cursor?: hak_aksesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * akses without action
   */
  export type aksesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the akses
     */
    select?: aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: aksesInclude<ExtArgs> | null
  }



  /**
   * Model fungsi
   */

  export type AggregateFungsi = {
    _count: FungsiCountAggregateOutputType | null
    _avg: FungsiAvgAggregateOutputType | null
    _sum: FungsiSumAggregateOutputType | null
    _min: FungsiMinAggregateOutputType | null
    _max: FungsiMaxAggregateOutputType | null
  }

  export type FungsiAvgAggregateOutputType = {
    id: number | null
  }

  export type FungsiSumAggregateOutputType = {
    id: number | null
  }

  export type FungsiMinAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type FungsiMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type FungsiCountAggregateOutputType = {
    id: number
    nama: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type FungsiAvgAggregateInputType = {
    id?: true
  }

  export type FungsiSumAggregateInputType = {
    id?: true
  }

  export type FungsiMinAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type FungsiMaxAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type FungsiCountAggregateInputType = {
    id?: true
    nama?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type FungsiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fungsi to aggregate.
     */
    where?: fungsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fungsis to fetch.
     */
    orderBy?: fungsiOrderByWithRelationInput | fungsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fungsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fungsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fungsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fungsis
    **/
    _count?: true | FungsiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FungsiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FungsiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FungsiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FungsiMaxAggregateInputType
  }

  export type GetFungsiAggregateType<T extends FungsiAggregateArgs> = {
        [P in keyof T & keyof AggregateFungsi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFungsi[P]>
      : GetScalarType<T[P], AggregateFungsi[P]>
  }




  export type fungsiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fungsiWhereInput
    orderBy?: fungsiOrderByWithAggregationInput | fungsiOrderByWithAggregationInput[]
    by: FungsiScalarFieldEnum[] | FungsiScalarFieldEnum
    having?: fungsiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FungsiCountAggregateInputType | true
    _avg?: FungsiAvgAggregateInputType
    _sum?: FungsiSumAggregateInputType
    _min?: FungsiMinAggregateInputType
    _max?: FungsiMaxAggregateInputType
  }

  export type FungsiGroupByOutputType = {
    id: number
    nama: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: FungsiCountAggregateOutputType | null
    _avg: FungsiAvgAggregateOutputType | null
    _sum: FungsiSumAggregateOutputType | null
    _min: FungsiMinAggregateOutputType | null
    _max: FungsiMaxAggregateOutputType | null
  }

  type GetFungsiGroupByPayload<T extends fungsiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FungsiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FungsiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FungsiGroupByOutputType[P]>
            : GetScalarType<T[P], FungsiGroupByOutputType[P]>
        }
      >
    >


  export type fungsiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    hak_akses?: boolean | fungsi$hak_aksesArgs<ExtArgs>
    _count?: boolean | FungsiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fungsi"]>

  export type fungsiSelectScalar = {
    id?: boolean
    nama?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type fungsiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hak_akses?: boolean | fungsi$hak_aksesArgs<ExtArgs>
    _count?: boolean | FungsiCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $fungsiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fungsi"
    objects: {
      hak_akses: Prisma.$hak_aksesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["fungsi"]>
    composites: {}
  }


  type fungsiGetPayload<S extends boolean | null | undefined | fungsiDefaultArgs> = $Result.GetResult<Prisma.$fungsiPayload, S>

  type fungsiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fungsiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FungsiCountAggregateInputType | true
    }

  export interface fungsiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fungsi'], meta: { name: 'fungsi' } }
    /**
     * Find zero or one Fungsi that matches the filter.
     * @param {fungsiFindUniqueArgs} args - Arguments to find a Fungsi
     * @example
     * // Get one Fungsi
     * const fungsi = await prisma.fungsi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fungsiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiFindUniqueArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fungsi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fungsiFindUniqueOrThrowArgs} args - Arguments to find a Fungsi
     * @example
     * // Get one Fungsi
     * const fungsi = await prisma.fungsi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fungsiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fungsi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiFindFirstArgs} args - Arguments to find a Fungsi
     * @example
     * // Get one Fungsi
     * const fungsi = await prisma.fungsi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fungsiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiFindFirstArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fungsi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiFindFirstOrThrowArgs} args - Arguments to find a Fungsi
     * @example
     * // Get one Fungsi
     * const fungsi = await prisma.fungsi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fungsiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fungsis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fungsis
     * const fungsis = await prisma.fungsi.findMany()
     * 
     * // Get first 10 Fungsis
     * const fungsis = await prisma.fungsi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fungsiWithIdOnly = await prisma.fungsi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fungsiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fungsi.
     * @param {fungsiCreateArgs} args - Arguments to create a Fungsi.
     * @example
     * // Create one Fungsi
     * const Fungsi = await prisma.fungsi.create({
     *   data: {
     *     // ... data to create a Fungsi
     *   }
     * })
     * 
    **/
    create<T extends fungsiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiCreateArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fungsis.
     *     @param {fungsiCreateManyArgs} args - Arguments to create many Fungsis.
     *     @example
     *     // Create many Fungsis
     *     const fungsi = await prisma.fungsi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fungsiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fungsi.
     * @param {fungsiDeleteArgs} args - Arguments to delete one Fungsi.
     * @example
     * // Delete one Fungsi
     * const Fungsi = await prisma.fungsi.delete({
     *   where: {
     *     // ... filter to delete one Fungsi
     *   }
     * })
     * 
    **/
    delete<T extends fungsiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiDeleteArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fungsi.
     * @param {fungsiUpdateArgs} args - Arguments to update one Fungsi.
     * @example
     * // Update one Fungsi
     * const fungsi = await prisma.fungsi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fungsiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiUpdateArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fungsis.
     * @param {fungsiDeleteManyArgs} args - Arguments to filter Fungsis to delete.
     * @example
     * // Delete a few Fungsis
     * const { count } = await prisma.fungsi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fungsiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fungsiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fungsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fungsis
     * const fungsi = await prisma.fungsi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fungsiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fungsi.
     * @param {fungsiUpsertArgs} args - Arguments to update or create a Fungsi.
     * @example
     * // Update or create a Fungsi
     * const fungsi = await prisma.fungsi.upsert({
     *   create: {
     *     // ... data to create a Fungsi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fungsi we want to update
     *   }
     * })
    **/
    upsert<T extends fungsiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fungsiUpsertArgs<ExtArgs>>
    ): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fungsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiCountArgs} args - Arguments to filter Fungsis to count.
     * @example
     * // Count the number of Fungsis
     * const count = await prisma.fungsi.count({
     *   where: {
     *     // ... the filter for the Fungsis we want to count
     *   }
     * })
    **/
    count<T extends fungsiCountArgs>(
      args?: Subset<T, fungsiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FungsiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fungsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FungsiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FungsiAggregateArgs>(args: Subset<T, FungsiAggregateArgs>): Prisma.PrismaPromise<GetFungsiAggregateType<T>>

    /**
     * Group by Fungsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fungsiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fungsiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fungsiGroupByArgs['orderBy'] }
        : { orderBy?: fungsiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fungsiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFungsiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fungsi model
   */
  readonly fields: fungsiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fungsi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fungsiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    hak_akses<T extends fungsi$hak_aksesArgs<ExtArgs> = {}>(args?: Subset<T, fungsi$hak_aksesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the fungsi model
   */ 
  interface fungsiFieldRefs {
    readonly id: FieldRef<"fungsi", 'Int'>
    readonly nama: FieldRef<"fungsi", 'String'>
    readonly created_at: FieldRef<"fungsi", 'DateTime'>
    readonly updated_at: FieldRef<"fungsi", 'DateTime'>
    readonly deleted_at: FieldRef<"fungsi", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * fungsi findUnique
   */
  export type fungsiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter, which fungsi to fetch.
     */
    where: fungsiWhereUniqueInput
  }


  /**
   * fungsi findUniqueOrThrow
   */
  export type fungsiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter, which fungsi to fetch.
     */
    where: fungsiWhereUniqueInput
  }


  /**
   * fungsi findFirst
   */
  export type fungsiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter, which fungsi to fetch.
     */
    where?: fungsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fungsis to fetch.
     */
    orderBy?: fungsiOrderByWithRelationInput | fungsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fungsis.
     */
    cursor?: fungsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fungsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fungsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fungsis.
     */
    distinct?: FungsiScalarFieldEnum | FungsiScalarFieldEnum[]
  }


  /**
   * fungsi findFirstOrThrow
   */
  export type fungsiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter, which fungsi to fetch.
     */
    where?: fungsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fungsis to fetch.
     */
    orderBy?: fungsiOrderByWithRelationInput | fungsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fungsis.
     */
    cursor?: fungsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fungsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fungsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fungsis.
     */
    distinct?: FungsiScalarFieldEnum | FungsiScalarFieldEnum[]
  }


  /**
   * fungsi findMany
   */
  export type fungsiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter, which fungsis to fetch.
     */
    where?: fungsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fungsis to fetch.
     */
    orderBy?: fungsiOrderByWithRelationInput | fungsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fungsis.
     */
    cursor?: fungsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fungsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fungsis.
     */
    skip?: number
    distinct?: FungsiScalarFieldEnum | FungsiScalarFieldEnum[]
  }


  /**
   * fungsi create
   */
  export type fungsiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * The data needed to create a fungsi.
     */
    data: XOR<fungsiCreateInput, fungsiUncheckedCreateInput>
  }


  /**
   * fungsi createMany
   */
  export type fungsiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fungsis.
     */
    data: fungsiCreateManyInput | fungsiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fungsi update
   */
  export type fungsiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * The data needed to update a fungsi.
     */
    data: XOR<fungsiUpdateInput, fungsiUncheckedUpdateInput>
    /**
     * Choose, which fungsi to update.
     */
    where: fungsiWhereUniqueInput
  }


  /**
   * fungsi updateMany
   */
  export type fungsiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fungsis.
     */
    data: XOR<fungsiUpdateManyMutationInput, fungsiUncheckedUpdateManyInput>
    /**
     * Filter which fungsis to update
     */
    where?: fungsiWhereInput
  }


  /**
   * fungsi upsert
   */
  export type fungsiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * The filter to search for the fungsi to update in case it exists.
     */
    where: fungsiWhereUniqueInput
    /**
     * In case the fungsi found by the `where` argument doesn't exist, create a new fungsi with this data.
     */
    create: XOR<fungsiCreateInput, fungsiUncheckedCreateInput>
    /**
     * In case the fungsi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fungsiUpdateInput, fungsiUncheckedUpdateInput>
  }


  /**
   * fungsi delete
   */
  export type fungsiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
    /**
     * Filter which fungsi to delete.
     */
    where: fungsiWhereUniqueInput
  }


  /**
   * fungsi deleteMany
   */
  export type fungsiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fungsis to delete
     */
    where?: fungsiWhereInput
  }


  /**
   * fungsi.hak_akses
   */
  export type fungsi$hak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    where?: hak_aksesWhereInput
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    cursor?: hak_aksesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * fungsi without action
   */
  export type fungsiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fungsi
     */
    select?: fungsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fungsiInclude<ExtArgs> | null
  }



  /**
   * Model hak_akses
   */

  export type AggregateHak_akses = {
    _count: Hak_aksesCountAggregateOutputType | null
    _avg: Hak_aksesAvgAggregateOutputType | null
    _sum: Hak_aksesSumAggregateOutputType | null
    _min: Hak_aksesMinAggregateOutputType | null
    _max: Hak_aksesMaxAggregateOutputType | null
  }

  export type Hak_aksesAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
    fungsi_id: number | null
    akses_id: number | null
  }

  export type Hak_aksesSumAggregateOutputType = {
    id: number | null
    role_id: number | null
    fungsi_id: number | null
    akses_id: number | null
  }

  export type Hak_aksesMinAggregateOutputType = {
    id: number | null
    role_id: number | null
    fungsi_id: number | null
    akses_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Hak_aksesMaxAggregateOutputType = {
    id: number | null
    role_id: number | null
    fungsi_id: number | null
    akses_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Hak_aksesCountAggregateOutputType = {
    id: number
    role_id: number
    fungsi_id: number
    akses_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Hak_aksesAvgAggregateInputType = {
    id?: true
    role_id?: true
    fungsi_id?: true
    akses_id?: true
  }

  export type Hak_aksesSumAggregateInputType = {
    id?: true
    role_id?: true
    fungsi_id?: true
    akses_id?: true
  }

  export type Hak_aksesMinAggregateInputType = {
    id?: true
    role_id?: true
    fungsi_id?: true
    akses_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Hak_aksesMaxAggregateInputType = {
    id?: true
    role_id?: true
    fungsi_id?: true
    akses_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Hak_aksesCountAggregateInputType = {
    id?: true
    role_id?: true
    fungsi_id?: true
    akses_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Hak_aksesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hak_akses to aggregate.
     */
    where?: hak_aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hak_akses to fetch.
     */
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hak_aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hak_akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hak_akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hak_akses
    **/
    _count?: true | Hak_aksesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hak_aksesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hak_aksesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hak_aksesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hak_aksesMaxAggregateInputType
  }

  export type GetHak_aksesAggregateType<T extends Hak_aksesAggregateArgs> = {
        [P in keyof T & keyof AggregateHak_akses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHak_akses[P]>
      : GetScalarType<T[P], AggregateHak_akses[P]>
  }




  export type hak_aksesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hak_aksesWhereInput
    orderBy?: hak_aksesOrderByWithAggregationInput | hak_aksesOrderByWithAggregationInput[]
    by: Hak_aksesScalarFieldEnum[] | Hak_aksesScalarFieldEnum
    having?: hak_aksesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hak_aksesCountAggregateInputType | true
    _avg?: Hak_aksesAvgAggregateInputType
    _sum?: Hak_aksesSumAggregateInputType
    _min?: Hak_aksesMinAggregateInputType
    _max?: Hak_aksesMaxAggregateInputType
  }

  export type Hak_aksesGroupByOutputType = {
    id: number
    role_id: number
    fungsi_id: number
    akses_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Hak_aksesCountAggregateOutputType | null
    _avg: Hak_aksesAvgAggregateOutputType | null
    _sum: Hak_aksesSumAggregateOutputType | null
    _min: Hak_aksesMinAggregateOutputType | null
    _max: Hak_aksesMaxAggregateOutputType | null
  }

  type GetHak_aksesGroupByPayload<T extends hak_aksesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hak_aksesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hak_aksesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hak_aksesGroupByOutputType[P]>
            : GetScalarType<T[P], Hak_aksesGroupByOutputType[P]>
        }
      >
    >


  export type hak_aksesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    fungsi_id?: boolean
    akses_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    fungsi?: boolean | fungsiDefaultArgs<ExtArgs>
    akses?: boolean | aksesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hak_akses"]>

  export type hak_aksesSelectScalar = {
    id?: boolean
    role_id?: boolean
    fungsi_id?: boolean
    akses_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type hak_aksesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    fungsi?: boolean | fungsiDefaultArgs<ExtArgs>
    akses?: boolean | aksesDefaultArgs<ExtArgs>
  }


  export type $hak_aksesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hak_akses"
    objects: {
      role: Prisma.$rolePayload<ExtArgs>
      fungsi: Prisma.$fungsiPayload<ExtArgs>
      akses: Prisma.$aksesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_id: number
      fungsi_id: number
      akses_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["hak_akses"]>
    composites: {}
  }


  type hak_aksesGetPayload<S extends boolean | null | undefined | hak_aksesDefaultArgs> = $Result.GetResult<Prisma.$hak_aksesPayload, S>

  type hak_aksesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hak_aksesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Hak_aksesCountAggregateInputType | true
    }

  export interface hak_aksesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hak_akses'], meta: { name: 'hak_akses' } }
    /**
     * Find zero or one Hak_akses that matches the filter.
     * @param {hak_aksesFindUniqueArgs} args - Arguments to find a Hak_akses
     * @example
     * // Get one Hak_akses
     * const hak_akses = await prisma.hak_akses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends hak_aksesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesFindUniqueArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Hak_akses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {hak_aksesFindUniqueOrThrowArgs} args - Arguments to find a Hak_akses
     * @example
     * // Get one Hak_akses
     * const hak_akses = await prisma.hak_akses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends hak_aksesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Hak_akses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesFindFirstArgs} args - Arguments to find a Hak_akses
     * @example
     * // Get one Hak_akses
     * const hak_akses = await prisma.hak_akses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends hak_aksesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesFindFirstArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Hak_akses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesFindFirstOrThrowArgs} args - Arguments to find a Hak_akses
     * @example
     * // Get one Hak_akses
     * const hak_akses = await prisma.hak_akses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends hak_aksesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Hak_akses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hak_akses
     * const hak_akses = await prisma.hak_akses.findMany()
     * 
     * // Get first 10 Hak_akses
     * const hak_akses = await prisma.hak_akses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hak_aksesWithIdOnly = await prisma.hak_akses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends hak_aksesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Hak_akses.
     * @param {hak_aksesCreateArgs} args - Arguments to create a Hak_akses.
     * @example
     * // Create one Hak_akses
     * const Hak_akses = await prisma.hak_akses.create({
     *   data: {
     *     // ... data to create a Hak_akses
     *   }
     * })
     * 
    **/
    create<T extends hak_aksesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesCreateArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Hak_akses.
     *     @param {hak_aksesCreateManyArgs} args - Arguments to create many Hak_akses.
     *     @example
     *     // Create many Hak_akses
     *     const hak_akses = await prisma.hak_akses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends hak_aksesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hak_akses.
     * @param {hak_aksesDeleteArgs} args - Arguments to delete one Hak_akses.
     * @example
     * // Delete one Hak_akses
     * const Hak_akses = await prisma.hak_akses.delete({
     *   where: {
     *     // ... filter to delete one Hak_akses
     *   }
     * })
     * 
    **/
    delete<T extends hak_aksesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesDeleteArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Hak_akses.
     * @param {hak_aksesUpdateArgs} args - Arguments to update one Hak_akses.
     * @example
     * // Update one Hak_akses
     * const hak_akses = await prisma.hak_akses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends hak_aksesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesUpdateArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Hak_akses.
     * @param {hak_aksesDeleteManyArgs} args - Arguments to filter Hak_akses to delete.
     * @example
     * // Delete a few Hak_akses
     * const { count } = await prisma.hak_akses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends hak_aksesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hak_aksesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hak_akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hak_akses
     * const hak_akses = await prisma.hak_akses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends hak_aksesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hak_akses.
     * @param {hak_aksesUpsertArgs} args - Arguments to update or create a Hak_akses.
     * @example
     * // Update or create a Hak_akses
     * const hak_akses = await prisma.hak_akses.upsert({
     *   create: {
     *     // ... data to create a Hak_akses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hak_akses we want to update
     *   }
     * })
    **/
    upsert<T extends hak_aksesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, hak_aksesUpsertArgs<ExtArgs>>
    ): Prisma__hak_aksesClient<$Result.GetResult<Prisma.$hak_aksesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Hak_akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesCountArgs} args - Arguments to filter Hak_akses to count.
     * @example
     * // Count the number of Hak_akses
     * const count = await prisma.hak_akses.count({
     *   where: {
     *     // ... the filter for the Hak_akses we want to count
     *   }
     * })
    **/
    count<T extends hak_aksesCountArgs>(
      args?: Subset<T, hak_aksesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hak_aksesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hak_akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hak_aksesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hak_aksesAggregateArgs>(args: Subset<T, Hak_aksesAggregateArgs>): Prisma.PrismaPromise<GetHak_aksesAggregateType<T>>

    /**
     * Group by Hak_akses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hak_aksesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hak_aksesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hak_aksesGroupByArgs['orderBy'] }
        : { orderBy?: hak_aksesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hak_aksesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHak_aksesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hak_akses model
   */
  readonly fields: hak_aksesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hak_akses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hak_aksesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    fungsi<T extends fungsiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, fungsiDefaultArgs<ExtArgs>>): Prisma__fungsiClient<$Result.GetResult<Prisma.$fungsiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    akses<T extends aksesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aksesDefaultArgs<ExtArgs>>): Prisma__aksesClient<$Result.GetResult<Prisma.$aksesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the hak_akses model
   */ 
  interface hak_aksesFieldRefs {
    readonly id: FieldRef<"hak_akses", 'Int'>
    readonly role_id: FieldRef<"hak_akses", 'Int'>
    readonly fungsi_id: FieldRef<"hak_akses", 'Int'>
    readonly akses_id: FieldRef<"hak_akses", 'Int'>
    readonly created_at: FieldRef<"hak_akses", 'DateTime'>
    readonly updated_at: FieldRef<"hak_akses", 'DateTime'>
    readonly deleted_at: FieldRef<"hak_akses", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * hak_akses findUnique
   */
  export type hak_aksesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter, which hak_akses to fetch.
     */
    where: hak_aksesWhereUniqueInput
  }


  /**
   * hak_akses findUniqueOrThrow
   */
  export type hak_aksesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter, which hak_akses to fetch.
     */
    where: hak_aksesWhereUniqueInput
  }


  /**
   * hak_akses findFirst
   */
  export type hak_aksesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter, which hak_akses to fetch.
     */
    where?: hak_aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hak_akses to fetch.
     */
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hak_akses.
     */
    cursor?: hak_aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hak_akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hak_akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hak_akses.
     */
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * hak_akses findFirstOrThrow
   */
  export type hak_aksesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter, which hak_akses to fetch.
     */
    where?: hak_aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hak_akses to fetch.
     */
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hak_akses.
     */
    cursor?: hak_aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hak_akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hak_akses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hak_akses.
     */
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * hak_akses findMany
   */
  export type hak_aksesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter, which hak_akses to fetch.
     */
    where?: hak_aksesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hak_akses to fetch.
     */
    orderBy?: hak_aksesOrderByWithRelationInput | hak_aksesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hak_akses.
     */
    cursor?: hak_aksesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hak_akses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hak_akses.
     */
    skip?: number
    distinct?: Hak_aksesScalarFieldEnum | Hak_aksesScalarFieldEnum[]
  }


  /**
   * hak_akses create
   */
  export type hak_aksesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * The data needed to create a hak_akses.
     */
    data: XOR<hak_aksesCreateInput, hak_aksesUncheckedCreateInput>
  }


  /**
   * hak_akses createMany
   */
  export type hak_aksesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hak_akses.
     */
    data: hak_aksesCreateManyInput | hak_aksesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * hak_akses update
   */
  export type hak_aksesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * The data needed to update a hak_akses.
     */
    data: XOR<hak_aksesUpdateInput, hak_aksesUncheckedUpdateInput>
    /**
     * Choose, which hak_akses to update.
     */
    where: hak_aksesWhereUniqueInput
  }


  /**
   * hak_akses updateMany
   */
  export type hak_aksesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hak_akses.
     */
    data: XOR<hak_aksesUpdateManyMutationInput, hak_aksesUncheckedUpdateManyInput>
    /**
     * Filter which hak_akses to update
     */
    where?: hak_aksesWhereInput
  }


  /**
   * hak_akses upsert
   */
  export type hak_aksesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * The filter to search for the hak_akses to update in case it exists.
     */
    where: hak_aksesWhereUniqueInput
    /**
     * In case the hak_akses found by the `where` argument doesn't exist, create a new hak_akses with this data.
     */
    create: XOR<hak_aksesCreateInput, hak_aksesUncheckedCreateInput>
    /**
     * In case the hak_akses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hak_aksesUpdateInput, hak_aksesUncheckedUpdateInput>
  }


  /**
   * hak_akses delete
   */
  export type hak_aksesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
    /**
     * Filter which hak_akses to delete.
     */
    where: hak_aksesWhereUniqueInput
  }


  /**
   * hak_akses deleteMany
   */
  export type hak_aksesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hak_akses to delete
     */
    where?: hak_aksesWhereInput
  }


  /**
   * hak_akses without action
   */
  export type hak_aksesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hak_akses
     */
    select?: hak_aksesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hak_aksesInclude<ExtArgs> | null
  }



  /**
   * Model model_produk
   */

  export type AggregateModel_produk = {
    _count: Model_produkCountAggregateOutputType | null
    _avg: Model_produkAvgAggregateOutputType | null
    _sum: Model_produkSumAggregateOutputType | null
    _min: Model_produkMinAggregateOutputType | null
    _max: Model_produkMaxAggregateOutputType | null
  }

  export type Model_produkAvgAggregateOutputType = {
    id: number | null
    kategori_id: number | null
  }

  export type Model_produkSumAggregateOutputType = {
    id: number | null
    kategori_id: number | null
  }

  export type Model_produkMinAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    variasi: string | null
    deskripsi: string | null
    deleted_at: Date | null
    kategori_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Model_produkMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    variasi: string | null
    deskripsi: string | null
    deleted_at: Date | null
    kategori_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Model_produkCountAggregateOutputType = {
    id: number
    kode: number
    nama: number
    variasi: number
    deskripsi: number
    deleted_at: number
    kategori_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Model_produkAvgAggregateInputType = {
    id?: true
    kategori_id?: true
  }

  export type Model_produkSumAggregateInputType = {
    id?: true
    kategori_id?: true
  }

  export type Model_produkMinAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    variasi?: true
    deskripsi?: true
    deleted_at?: true
    kategori_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Model_produkMaxAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    variasi?: true
    deskripsi?: true
    deleted_at?: true
    kategori_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Model_produkCountAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    variasi?: true
    deskripsi?: true
    deleted_at?: true
    kategori_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Model_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_produk to aggregate.
     */
    where?: model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_produks to fetch.
     */
    orderBy?: model_produkOrderByWithRelationInput | model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned model_produks
    **/
    _count?: true | Model_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Model_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Model_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Model_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Model_produkMaxAggregateInputType
  }

  export type GetModel_produkAggregateType<T extends Model_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel_produk[P]>
      : GetScalarType<T[P], AggregateModel_produk[P]>
  }




  export type model_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_produkWhereInput
    orderBy?: model_produkOrderByWithAggregationInput | model_produkOrderByWithAggregationInput[]
    by: Model_produkScalarFieldEnum[] | Model_produkScalarFieldEnum
    having?: model_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Model_produkCountAggregateInputType | true
    _avg?: Model_produkAvgAggregateInputType
    _sum?: Model_produkSumAggregateInputType
    _min?: Model_produkMinAggregateInputType
    _max?: Model_produkMaxAggregateInputType
  }

  export type Model_produkGroupByOutputType = {
    id: number
    kode: string
    nama: string
    variasi: string
    deskripsi: string | null
    deleted_at: Date | null
    kategori_id: number
    created_at: Date
    updated_at: Date
    _count: Model_produkCountAggregateOutputType | null
    _avg: Model_produkAvgAggregateOutputType | null
    _sum: Model_produkSumAggregateOutputType | null
    _min: Model_produkMinAggregateOutputType | null
    _max: Model_produkMaxAggregateOutputType | null
  }

  type GetModel_produkGroupByPayload<T extends model_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Model_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Model_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Model_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Model_produkGroupByOutputType[P]>
        }
      >
    >


  export type model_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    nama?: boolean
    variasi?: boolean
    deskripsi?: boolean
    deleted_at?: boolean
    kategori_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    kategori?: boolean | kategori_produkDefaultArgs<ExtArgs>
    foto_produk?: boolean | model_produk$foto_produkArgs<ExtArgs>
    detail_model_produk?: boolean | model_produk$detail_model_produkArgs<ExtArgs>
    _count?: boolean | Model_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_produk"]>

  export type model_produkSelectScalar = {
    id?: boolean
    kode?: boolean
    nama?: boolean
    variasi?: boolean
    deskripsi?: boolean
    deleted_at?: boolean
    kategori_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type model_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | kategori_produkDefaultArgs<ExtArgs>
    foto_produk?: boolean | model_produk$foto_produkArgs<ExtArgs>
    detail_model_produk?: boolean | model_produk$detail_model_produkArgs<ExtArgs>
    _count?: boolean | Model_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $model_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "model_produk"
    objects: {
      kategori: Prisma.$kategori_produkPayload<ExtArgs>
      foto_produk: Prisma.$foto_produkPayload<ExtArgs>[]
      detail_model_produk: Prisma.$detail_model_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      nama: string
      variasi: string
      deskripsi: string | null
      deleted_at: Date | null
      kategori_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["model_produk"]>
    composites: {}
  }


  type model_produkGetPayload<S extends boolean | null | undefined | model_produkDefaultArgs> = $Result.GetResult<Prisma.$model_produkPayload, S>

  type model_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<model_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Model_produkCountAggregateInputType | true
    }

  export interface model_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['model_produk'], meta: { name: 'model_produk' } }
    /**
     * Find zero or one Model_produk that matches the filter.
     * @param {model_produkFindUniqueArgs} args - Arguments to find a Model_produk
     * @example
     * // Get one Model_produk
     * const model_produk = await prisma.model_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends model_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Model_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {model_produkFindUniqueOrThrowArgs} args - Arguments to find a Model_produk
     * @example
     * // Get one Model_produk
     * const model_produk = await prisma.model_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends model_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Model_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkFindFirstArgs} args - Arguments to find a Model_produk
     * @example
     * // Get one Model_produk
     * const model_produk = await prisma.model_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends model_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkFindFirstArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Model_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkFindFirstOrThrowArgs} args - Arguments to find a Model_produk
     * @example
     * // Get one Model_produk
     * const model_produk = await prisma.model_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends model_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Model_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Model_produks
     * const model_produks = await prisma.model_produk.findMany()
     * 
     * // Get first 10 Model_produks
     * const model_produks = await prisma.model_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const model_produkWithIdOnly = await prisma.model_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends model_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Model_produk.
     * @param {model_produkCreateArgs} args - Arguments to create a Model_produk.
     * @example
     * // Create one Model_produk
     * const Model_produk = await prisma.model_produk.create({
     *   data: {
     *     // ... data to create a Model_produk
     *   }
     * })
     * 
    **/
    create<T extends model_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkCreateArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Model_produks.
     *     @param {model_produkCreateManyArgs} args - Arguments to create many Model_produks.
     *     @example
     *     // Create many Model_produks
     *     const model_produk = await prisma.model_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends model_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model_produk.
     * @param {model_produkDeleteArgs} args - Arguments to delete one Model_produk.
     * @example
     * // Delete one Model_produk
     * const Model_produk = await prisma.model_produk.delete({
     *   where: {
     *     // ... filter to delete one Model_produk
     *   }
     * })
     * 
    **/
    delete<T extends model_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkDeleteArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Model_produk.
     * @param {model_produkUpdateArgs} args - Arguments to update one Model_produk.
     * @example
     * // Update one Model_produk
     * const model_produk = await prisma.model_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends model_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkUpdateArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Model_produks.
     * @param {model_produkDeleteManyArgs} args - Arguments to filter Model_produks to delete.
     * @example
     * // Delete a few Model_produks
     * const { count } = await prisma.model_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends model_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, model_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Model_produks
     * const model_produk = await prisma.model_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends model_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model_produk.
     * @param {model_produkUpsertArgs} args - Arguments to update or create a Model_produk.
     * @example
     * // Update or create a Model_produk
     * const model_produk = await prisma.model_produk.upsert({
     *   create: {
     *     // ... data to create a Model_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model_produk we want to update
     *   }
     * })
    **/
    upsert<T extends model_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, model_produkUpsertArgs<ExtArgs>>
    ): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Model_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkCountArgs} args - Arguments to filter Model_produks to count.
     * @example
     * // Count the number of Model_produks
     * const count = await prisma.model_produk.count({
     *   where: {
     *     // ... the filter for the Model_produks we want to count
     *   }
     * })
    **/
    count<T extends model_produkCountArgs>(
      args?: Subset<T, model_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Model_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Model_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Model_produkAggregateArgs>(args: Subset<T, Model_produkAggregateArgs>): Prisma.PrismaPromise<GetModel_produkAggregateType<T>>

    /**
     * Group by Model_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends model_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: model_produkGroupByArgs['orderBy'] }
        : { orderBy?: model_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, model_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModel_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the model_produk model
   */
  readonly fields: model_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for model_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__model_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    kategori<T extends kategori_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategori_produkDefaultArgs<ExtArgs>>): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    foto_produk<T extends model_produk$foto_produkArgs<ExtArgs> = {}>(args?: Subset<T, model_produk$foto_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    detail_model_produk<T extends model_produk$detail_model_produkArgs<ExtArgs> = {}>(args?: Subset<T, model_produk$detail_model_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the model_produk model
   */ 
  interface model_produkFieldRefs {
    readonly id: FieldRef<"model_produk", 'Int'>
    readonly kode: FieldRef<"model_produk", 'String'>
    readonly nama: FieldRef<"model_produk", 'String'>
    readonly variasi: FieldRef<"model_produk", 'String'>
    readonly deskripsi: FieldRef<"model_produk", 'String'>
    readonly deleted_at: FieldRef<"model_produk", 'DateTime'>
    readonly kategori_id: FieldRef<"model_produk", 'Int'>
    readonly created_at: FieldRef<"model_produk", 'DateTime'>
    readonly updated_at: FieldRef<"model_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * model_produk findUnique
   */
  export type model_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter, which model_produk to fetch.
     */
    where: model_produkWhereUniqueInput
  }


  /**
   * model_produk findUniqueOrThrow
   */
  export type model_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter, which model_produk to fetch.
     */
    where: model_produkWhereUniqueInput
  }


  /**
   * model_produk findFirst
   */
  export type model_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter, which model_produk to fetch.
     */
    where?: model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_produks to fetch.
     */
    orderBy?: model_produkOrderByWithRelationInput | model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_produks.
     */
    cursor?: model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_produks.
     */
    distinct?: Model_produkScalarFieldEnum | Model_produkScalarFieldEnum[]
  }


  /**
   * model_produk findFirstOrThrow
   */
  export type model_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter, which model_produk to fetch.
     */
    where?: model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_produks to fetch.
     */
    orderBy?: model_produkOrderByWithRelationInput | model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_produks.
     */
    cursor?: model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_produks.
     */
    distinct?: Model_produkScalarFieldEnum | Model_produkScalarFieldEnum[]
  }


  /**
   * model_produk findMany
   */
  export type model_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter, which model_produks to fetch.
     */
    where?: model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_produks to fetch.
     */
    orderBy?: model_produkOrderByWithRelationInput | model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing model_produks.
     */
    cursor?: model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_produks.
     */
    skip?: number
    distinct?: Model_produkScalarFieldEnum | Model_produkScalarFieldEnum[]
  }


  /**
   * model_produk create
   */
  export type model_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a model_produk.
     */
    data: XOR<model_produkCreateInput, model_produkUncheckedCreateInput>
  }


  /**
   * model_produk createMany
   */
  export type model_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many model_produks.
     */
    data: model_produkCreateManyInput | model_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * model_produk update
   */
  export type model_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a model_produk.
     */
    data: XOR<model_produkUpdateInput, model_produkUncheckedUpdateInput>
    /**
     * Choose, which model_produk to update.
     */
    where: model_produkWhereUniqueInput
  }


  /**
   * model_produk updateMany
   */
  export type model_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update model_produks.
     */
    data: XOR<model_produkUpdateManyMutationInput, model_produkUncheckedUpdateManyInput>
    /**
     * Filter which model_produks to update
     */
    where?: model_produkWhereInput
  }


  /**
   * model_produk upsert
   */
  export type model_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the model_produk to update in case it exists.
     */
    where: model_produkWhereUniqueInput
    /**
     * In case the model_produk found by the `where` argument doesn't exist, create a new model_produk with this data.
     */
    create: XOR<model_produkCreateInput, model_produkUncheckedCreateInput>
    /**
     * In case the model_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<model_produkUpdateInput, model_produkUncheckedUpdateInput>
  }


  /**
   * model_produk delete
   */
  export type model_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    /**
     * Filter which model_produk to delete.
     */
    where: model_produkWhereUniqueInput
  }


  /**
   * model_produk deleteMany
   */
  export type model_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_produks to delete
     */
    where?: model_produkWhereInput
  }


  /**
   * model_produk.foto_produk
   */
  export type model_produk$foto_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    where?: foto_produkWhereInput
    orderBy?: foto_produkOrderByWithRelationInput | foto_produkOrderByWithRelationInput[]
    cursor?: foto_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Foto_produkScalarFieldEnum | Foto_produkScalarFieldEnum[]
  }


  /**
   * model_produk.detail_model_produk
   */
  export type model_produk$detail_model_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    where?: detail_model_produkWhereInput
    orderBy?: detail_model_produkOrderByWithRelationInput | detail_model_produkOrderByWithRelationInput[]
    cursor?: detail_model_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detail_model_produkScalarFieldEnum | Detail_model_produkScalarFieldEnum[]
  }


  /**
   * model_produk without action
   */
  export type model_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
  }



  /**
   * Model foto_produk
   */

  export type AggregateFoto_produk = {
    _count: Foto_produkCountAggregateOutputType | null
    _avg: Foto_produkAvgAggregateOutputType | null
    _sum: Foto_produkSumAggregateOutputType | null
    _min: Foto_produkMinAggregateOutputType | null
    _max: Foto_produkMaxAggregateOutputType | null
  }

  export type Foto_produkAvgAggregateOutputType = {
    id: number | null
    model_produk_id: number | null
  }

  export type Foto_produkSumAggregateOutputType = {
    id: number | null
    model_produk_id: number | null
  }

  export type Foto_produkMinAggregateOutputType = {
    id: number | null
    filepath: string | null
    model_produk_id: number | null
  }

  export type Foto_produkMaxAggregateOutputType = {
    id: number | null
    filepath: string | null
    model_produk_id: number | null
  }

  export type Foto_produkCountAggregateOutputType = {
    id: number
    filepath: number
    model_produk_id: number
    _all: number
  }


  export type Foto_produkAvgAggregateInputType = {
    id?: true
    model_produk_id?: true
  }

  export type Foto_produkSumAggregateInputType = {
    id?: true
    model_produk_id?: true
  }

  export type Foto_produkMinAggregateInputType = {
    id?: true
    filepath?: true
    model_produk_id?: true
  }

  export type Foto_produkMaxAggregateInputType = {
    id?: true
    filepath?: true
    model_produk_id?: true
  }

  export type Foto_produkCountAggregateInputType = {
    id?: true
    filepath?: true
    model_produk_id?: true
    _all?: true
  }

  export type Foto_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which foto_produk to aggregate.
     */
    where?: foto_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foto_produks to fetch.
     */
    orderBy?: foto_produkOrderByWithRelationInput | foto_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: foto_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foto_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foto_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned foto_produks
    **/
    _count?: true | Foto_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Foto_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Foto_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Foto_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Foto_produkMaxAggregateInputType
  }

  export type GetFoto_produkAggregateType<T extends Foto_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateFoto_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoto_produk[P]>
      : GetScalarType<T[P], AggregateFoto_produk[P]>
  }




  export type foto_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: foto_produkWhereInput
    orderBy?: foto_produkOrderByWithAggregationInput | foto_produkOrderByWithAggregationInput[]
    by: Foto_produkScalarFieldEnum[] | Foto_produkScalarFieldEnum
    having?: foto_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Foto_produkCountAggregateInputType | true
    _avg?: Foto_produkAvgAggregateInputType
    _sum?: Foto_produkSumAggregateInputType
    _min?: Foto_produkMinAggregateInputType
    _max?: Foto_produkMaxAggregateInputType
  }

  export type Foto_produkGroupByOutputType = {
    id: number
    filepath: string
    model_produk_id: number
    _count: Foto_produkCountAggregateOutputType | null
    _avg: Foto_produkAvgAggregateOutputType | null
    _sum: Foto_produkSumAggregateOutputType | null
    _min: Foto_produkMinAggregateOutputType | null
    _max: Foto_produkMaxAggregateOutputType | null
  }

  type GetFoto_produkGroupByPayload<T extends foto_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Foto_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Foto_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Foto_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Foto_produkGroupByOutputType[P]>
        }
      >
    >


  export type foto_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filepath?: boolean
    model_produk_id?: boolean
    model_produk?: boolean | model_produkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foto_produk"]>

  export type foto_produkSelectScalar = {
    id?: boolean
    filepath?: boolean
    model_produk_id?: boolean
  }

  export type foto_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_produk?: boolean | model_produkDefaultArgs<ExtArgs>
  }


  export type $foto_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "foto_produk"
    objects: {
      model_produk: Prisma.$model_produkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filepath: string
      model_produk_id: number
    }, ExtArgs["result"]["foto_produk"]>
    composites: {}
  }


  type foto_produkGetPayload<S extends boolean | null | undefined | foto_produkDefaultArgs> = $Result.GetResult<Prisma.$foto_produkPayload, S>

  type foto_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<foto_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Foto_produkCountAggregateInputType | true
    }

  export interface foto_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['foto_produk'], meta: { name: 'foto_produk' } }
    /**
     * Find zero or one Foto_produk that matches the filter.
     * @param {foto_produkFindUniqueArgs} args - Arguments to find a Foto_produk
     * @example
     * // Get one Foto_produk
     * const foto_produk = await prisma.foto_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends foto_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foto_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {foto_produkFindUniqueOrThrowArgs} args - Arguments to find a Foto_produk
     * @example
     * // Get one Foto_produk
     * const foto_produk = await prisma.foto_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends foto_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foto_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkFindFirstArgs} args - Arguments to find a Foto_produk
     * @example
     * // Get one Foto_produk
     * const foto_produk = await prisma.foto_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends foto_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkFindFirstArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foto_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkFindFirstOrThrowArgs} args - Arguments to find a Foto_produk
     * @example
     * // Get one Foto_produk
     * const foto_produk = await prisma.foto_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends foto_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Foto_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foto_produks
     * const foto_produks = await prisma.foto_produk.findMany()
     * 
     * // Get first 10 Foto_produks
     * const foto_produks = await prisma.foto_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foto_produkWithIdOnly = await prisma.foto_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends foto_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foto_produk.
     * @param {foto_produkCreateArgs} args - Arguments to create a Foto_produk.
     * @example
     * // Create one Foto_produk
     * const Foto_produk = await prisma.foto_produk.create({
     *   data: {
     *     // ... data to create a Foto_produk
     *   }
     * })
     * 
    **/
    create<T extends foto_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkCreateArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Foto_produks.
     *     @param {foto_produkCreateManyArgs} args - Arguments to create many Foto_produks.
     *     @example
     *     // Create many Foto_produks
     *     const foto_produk = await prisma.foto_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends foto_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foto_produk.
     * @param {foto_produkDeleteArgs} args - Arguments to delete one Foto_produk.
     * @example
     * // Delete one Foto_produk
     * const Foto_produk = await prisma.foto_produk.delete({
     *   where: {
     *     // ... filter to delete one Foto_produk
     *   }
     * })
     * 
    **/
    delete<T extends foto_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkDeleteArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foto_produk.
     * @param {foto_produkUpdateArgs} args - Arguments to update one Foto_produk.
     * @example
     * // Update one Foto_produk
     * const foto_produk = await prisma.foto_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends foto_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkUpdateArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Foto_produks.
     * @param {foto_produkDeleteManyArgs} args - Arguments to filter Foto_produks to delete.
     * @example
     * // Delete a few Foto_produks
     * const { count } = await prisma.foto_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends foto_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foto_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foto_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foto_produks
     * const foto_produk = await prisma.foto_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends foto_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foto_produk.
     * @param {foto_produkUpsertArgs} args - Arguments to update or create a Foto_produk.
     * @example
     * // Update or create a Foto_produk
     * const foto_produk = await prisma.foto_produk.upsert({
     *   create: {
     *     // ... data to create a Foto_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foto_produk we want to update
     *   }
     * })
    **/
    upsert<T extends foto_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, foto_produkUpsertArgs<ExtArgs>>
    ): Prisma__foto_produkClient<$Result.GetResult<Prisma.$foto_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Foto_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkCountArgs} args - Arguments to filter Foto_produks to count.
     * @example
     * // Count the number of Foto_produks
     * const count = await prisma.foto_produk.count({
     *   where: {
     *     // ... the filter for the Foto_produks we want to count
     *   }
     * })
    **/
    count<T extends foto_produkCountArgs>(
      args?: Subset<T, foto_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Foto_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foto_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Foto_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Foto_produkAggregateArgs>(args: Subset<T, Foto_produkAggregateArgs>): Prisma.PrismaPromise<GetFoto_produkAggregateType<T>>

    /**
     * Group by Foto_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foto_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends foto_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: foto_produkGroupByArgs['orderBy'] }
        : { orderBy?: foto_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, foto_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoto_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the foto_produk model
   */
  readonly fields: foto_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for foto_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__foto_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    model_produk<T extends model_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, model_produkDefaultArgs<ExtArgs>>): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the foto_produk model
   */ 
  interface foto_produkFieldRefs {
    readonly id: FieldRef<"foto_produk", 'Int'>
    readonly filepath: FieldRef<"foto_produk", 'String'>
    readonly model_produk_id: FieldRef<"foto_produk", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * foto_produk findUnique
   */
  export type foto_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter, which foto_produk to fetch.
     */
    where: foto_produkWhereUniqueInput
  }


  /**
   * foto_produk findUniqueOrThrow
   */
  export type foto_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter, which foto_produk to fetch.
     */
    where: foto_produkWhereUniqueInput
  }


  /**
   * foto_produk findFirst
   */
  export type foto_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter, which foto_produk to fetch.
     */
    where?: foto_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foto_produks to fetch.
     */
    orderBy?: foto_produkOrderByWithRelationInput | foto_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foto_produks.
     */
    cursor?: foto_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foto_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foto_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foto_produks.
     */
    distinct?: Foto_produkScalarFieldEnum | Foto_produkScalarFieldEnum[]
  }


  /**
   * foto_produk findFirstOrThrow
   */
  export type foto_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter, which foto_produk to fetch.
     */
    where?: foto_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foto_produks to fetch.
     */
    orderBy?: foto_produkOrderByWithRelationInput | foto_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foto_produks.
     */
    cursor?: foto_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foto_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foto_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foto_produks.
     */
    distinct?: Foto_produkScalarFieldEnum | Foto_produkScalarFieldEnum[]
  }


  /**
   * foto_produk findMany
   */
  export type foto_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter, which foto_produks to fetch.
     */
    where?: foto_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foto_produks to fetch.
     */
    orderBy?: foto_produkOrderByWithRelationInput | foto_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing foto_produks.
     */
    cursor?: foto_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foto_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foto_produks.
     */
    skip?: number
    distinct?: Foto_produkScalarFieldEnum | Foto_produkScalarFieldEnum[]
  }


  /**
   * foto_produk create
   */
  export type foto_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a foto_produk.
     */
    data: XOR<foto_produkCreateInput, foto_produkUncheckedCreateInput>
  }


  /**
   * foto_produk createMany
   */
  export type foto_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many foto_produks.
     */
    data: foto_produkCreateManyInput | foto_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * foto_produk update
   */
  export type foto_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a foto_produk.
     */
    data: XOR<foto_produkUpdateInput, foto_produkUncheckedUpdateInput>
    /**
     * Choose, which foto_produk to update.
     */
    where: foto_produkWhereUniqueInput
  }


  /**
   * foto_produk updateMany
   */
  export type foto_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update foto_produks.
     */
    data: XOR<foto_produkUpdateManyMutationInput, foto_produkUncheckedUpdateManyInput>
    /**
     * Filter which foto_produks to update
     */
    where?: foto_produkWhereInput
  }


  /**
   * foto_produk upsert
   */
  export type foto_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the foto_produk to update in case it exists.
     */
    where: foto_produkWhereUniqueInput
    /**
     * In case the foto_produk found by the `where` argument doesn't exist, create a new foto_produk with this data.
     */
    create: XOR<foto_produkCreateInput, foto_produkUncheckedCreateInput>
    /**
     * In case the foto_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<foto_produkUpdateInput, foto_produkUncheckedUpdateInput>
  }


  /**
   * foto_produk delete
   */
  export type foto_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
    /**
     * Filter which foto_produk to delete.
     */
    where: foto_produkWhereUniqueInput
  }


  /**
   * foto_produk deleteMany
   */
  export type foto_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which foto_produks to delete
     */
    where?: foto_produkWhereInput
  }


  /**
   * foto_produk without action
   */
  export type foto_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foto_produk
     */
    select?: foto_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foto_produkInclude<ExtArgs> | null
  }



  /**
   * Model kategori_produk
   */

  export type AggregateKategori_produk = {
    _count: Kategori_produkCountAggregateOutputType | null
    _avg: Kategori_produkAvgAggregateOutputType | null
    _sum: Kategori_produkSumAggregateOutputType | null
    _min: Kategori_produkMinAggregateOutputType | null
    _max: Kategori_produkMaxAggregateOutputType | null
  }

  export type Kategori_produkAvgAggregateOutputType = {
    id: number | null
  }

  export type Kategori_produkSumAggregateOutputType = {
    id: number | null
  }

  export type Kategori_produkMinAggregateOutputType = {
    id: number | null
    nama: string | null
    tipe: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kategori_produkMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    tipe: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kategori_produkCountAggregateOutputType = {
    id: number
    nama: number
    tipe: number
    deleted_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Kategori_produkAvgAggregateInputType = {
    id?: true
  }

  export type Kategori_produkSumAggregateInputType = {
    id?: true
  }

  export type Kategori_produkMinAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Kategori_produkMaxAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Kategori_produkCountAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Kategori_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategori_produk to aggregate.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategori_produks
    **/
    _count?: true | Kategori_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kategori_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kategori_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kategori_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kategori_produkMaxAggregateInputType
  }

  export type GetKategori_produkAggregateType<T extends Kategori_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateKategori_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategori_produk[P]>
      : GetScalarType<T[P], AggregateKategori_produk[P]>
  }




  export type kategori_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kategori_produkWhereInput
    orderBy?: kategori_produkOrderByWithAggregationInput | kategori_produkOrderByWithAggregationInput[]
    by: Kategori_produkScalarFieldEnum[] | Kategori_produkScalarFieldEnum
    having?: kategori_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kategori_produkCountAggregateInputType | true
    _avg?: Kategori_produkAvgAggregateInputType
    _sum?: Kategori_produkSumAggregateInputType
    _min?: Kategori_produkMinAggregateInputType
    _max?: Kategori_produkMaxAggregateInputType
  }

  export type Kategori_produkGroupByOutputType = {
    id: number
    nama: string
    tipe: string
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    _count: Kategori_produkCountAggregateOutputType | null
    _avg: Kategori_produkAvgAggregateOutputType | null
    _sum: Kategori_produkSumAggregateOutputType | null
    _min: Kategori_produkMinAggregateOutputType | null
    _max: Kategori_produkMaxAggregateOutputType | null
  }

  type GetKategori_produkGroupByPayload<T extends kategori_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kategori_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kategori_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kategori_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Kategori_produkGroupByOutputType[P]>
        }
      >
    >


  export type kategori_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    tipe?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_produk?: boolean | kategori_produk$model_produkArgs<ExtArgs>
    _count?: boolean | Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategori_produk"]>

  export type kategori_produkSelectScalar = {
    id?: boolean
    nama?: boolean
    tipe?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type kategori_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_produk?: boolean | kategori_produk$model_produkArgs<ExtArgs>
    _count?: boolean | Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $kategori_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kategori_produk"
    objects: {
      model_produk: Prisma.$model_produkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      tipe: string
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["kategori_produk"]>
    composites: {}
  }


  type kategori_produkGetPayload<S extends boolean | null | undefined | kategori_produkDefaultArgs> = $Result.GetResult<Prisma.$kategori_produkPayload, S>

  type kategori_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kategori_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Kategori_produkCountAggregateInputType | true
    }

  export interface kategori_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategori_produk'], meta: { name: 'kategori_produk' } }
    /**
     * Find zero or one Kategori_produk that matches the filter.
     * @param {kategori_produkFindUniqueArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kategori_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Kategori_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kategori_produkFindUniqueOrThrowArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kategori_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Kategori_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindFirstArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kategori_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindFirstArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Kategori_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindFirstOrThrowArgs} args - Arguments to find a Kategori_produk
     * @example
     * // Get one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kategori_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Kategori_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kategori_produks
     * const kategori_produks = await prisma.kategori_produk.findMany()
     * 
     * // Get first 10 Kategori_produks
     * const kategori_produks = await prisma.kategori_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kategori_produkWithIdOnly = await prisma.kategori_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kategori_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Kategori_produk.
     * @param {kategori_produkCreateArgs} args - Arguments to create a Kategori_produk.
     * @example
     * // Create one Kategori_produk
     * const Kategori_produk = await prisma.kategori_produk.create({
     *   data: {
     *     // ... data to create a Kategori_produk
     *   }
     * })
     * 
    **/
    create<T extends kategori_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkCreateArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Kategori_produks.
     *     @param {kategori_produkCreateManyArgs} args - Arguments to create many Kategori_produks.
     *     @example
     *     // Create many Kategori_produks
     *     const kategori_produk = await prisma.kategori_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kategori_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kategori_produk.
     * @param {kategori_produkDeleteArgs} args - Arguments to delete one Kategori_produk.
     * @example
     * // Delete one Kategori_produk
     * const Kategori_produk = await prisma.kategori_produk.delete({
     *   where: {
     *     // ... filter to delete one Kategori_produk
     *   }
     * })
     * 
    **/
    delete<T extends kategori_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkDeleteArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Kategori_produk.
     * @param {kategori_produkUpdateArgs} args - Arguments to update one Kategori_produk.
     * @example
     * // Update one Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kategori_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpdateArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Kategori_produks.
     * @param {kategori_produkDeleteManyArgs} args - Arguments to filter Kategori_produks to delete.
     * @example
     * // Delete a few Kategori_produks
     * const { count } = await prisma.kategori_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kategori_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kategori_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategori_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kategori_produks
     * const kategori_produk = await prisma.kategori_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kategori_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kategori_produk.
     * @param {kategori_produkUpsertArgs} args - Arguments to update or create a Kategori_produk.
     * @example
     * // Update or create a Kategori_produk
     * const kategori_produk = await prisma.kategori_produk.upsert({
     *   create: {
     *     // ... data to create a Kategori_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kategori_produk we want to update
     *   }
     * })
    **/
    upsert<T extends kategori_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, kategori_produkUpsertArgs<ExtArgs>>
    ): Prisma__kategori_produkClient<$Result.GetResult<Prisma.$kategori_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Kategori_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkCountArgs} args - Arguments to filter Kategori_produks to count.
     * @example
     * // Count the number of Kategori_produks
     * const count = await prisma.kategori_produk.count({
     *   where: {
     *     // ... the filter for the Kategori_produks we want to count
     *   }
     * })
    **/
    count<T extends kategori_produkCountArgs>(
      args?: Subset<T, kategori_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kategori_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kategori_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kategori_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kategori_produkAggregateArgs>(args: Subset<T, Kategori_produkAggregateArgs>): Prisma.PrismaPromise<GetKategori_produkAggregateType<T>>

    /**
     * Group by Kategori_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategori_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategori_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategori_produkGroupByArgs['orderBy'] }
        : { orderBy?: kategori_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategori_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategori_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategori_produk model
   */
  readonly fields: kategori_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategori_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategori_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    model_produk<T extends kategori_produk$model_produkArgs<ExtArgs> = {}>(args?: Subset<T, kategori_produk$model_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the kategori_produk model
   */ 
  interface kategori_produkFieldRefs {
    readonly id: FieldRef<"kategori_produk", 'Int'>
    readonly nama: FieldRef<"kategori_produk", 'String'>
    readonly tipe: FieldRef<"kategori_produk", 'String'>
    readonly deleted_at: FieldRef<"kategori_produk", 'DateTime'>
    readonly created_at: FieldRef<"kategori_produk", 'DateTime'>
    readonly updated_at: FieldRef<"kategori_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * kategori_produk findUnique
   */
  export type kategori_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk findUniqueOrThrow
   */
  export type kategori_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk findFirst
   */
  export type kategori_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategori_produks.
     */
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk findFirstOrThrow
   */
  export type kategori_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produk to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategori_produks.
     */
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk findMany
   */
  export type kategori_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter, which kategori_produks to fetch.
     */
    where?: kategori_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategori_produks to fetch.
     */
    orderBy?: kategori_produkOrderByWithRelationInput | kategori_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategori_produks.
     */
    cursor?: kategori_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategori_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategori_produks.
     */
    skip?: number
    distinct?: Kategori_produkScalarFieldEnum | Kategori_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk create
   */
  export type kategori_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a kategori_produk.
     */
    data: XOR<kategori_produkCreateInput, kategori_produkUncheckedCreateInput>
  }


  /**
   * kategori_produk createMany
   */
  export type kategori_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategori_produks.
     */
    data: kategori_produkCreateManyInput | kategori_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * kategori_produk update
   */
  export type kategori_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a kategori_produk.
     */
    data: XOR<kategori_produkUpdateInput, kategori_produkUncheckedUpdateInput>
    /**
     * Choose, which kategori_produk to update.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk updateMany
   */
  export type kategori_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategori_produks.
     */
    data: XOR<kategori_produkUpdateManyMutationInput, kategori_produkUncheckedUpdateManyInput>
    /**
     * Filter which kategori_produks to update
     */
    where?: kategori_produkWhereInput
  }


  /**
   * kategori_produk upsert
   */
  export type kategori_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the kategori_produk to update in case it exists.
     */
    where: kategori_produkWhereUniqueInput
    /**
     * In case the kategori_produk found by the `where` argument doesn't exist, create a new kategori_produk with this data.
     */
    create: XOR<kategori_produkCreateInput, kategori_produkUncheckedCreateInput>
    /**
     * In case the kategori_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategori_produkUpdateInput, kategori_produkUncheckedUpdateInput>
  }


  /**
   * kategori_produk delete
   */
  export type kategori_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
    /**
     * Filter which kategori_produk to delete.
     */
    where: kategori_produkWhereUniqueInput
  }


  /**
   * kategori_produk deleteMany
   */
  export type kategori_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategori_produks to delete
     */
    where?: kategori_produkWhereInput
  }


  /**
   * kategori_produk.model_produk
   */
  export type kategori_produk$model_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_produk
     */
    select?: model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: model_produkInclude<ExtArgs> | null
    where?: model_produkWhereInput
    orderBy?: model_produkOrderByWithRelationInput | model_produkOrderByWithRelationInput[]
    cursor?: model_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Model_produkScalarFieldEnum | Model_produkScalarFieldEnum[]
  }


  /**
   * kategori_produk without action
   */
  export type kategori_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategori_produk
     */
    select?: kategori_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kategori_produkInclude<ExtArgs> | null
  }



  /**
   * Model detail_model_produk
   */

  export type AggregateDetail_model_produk = {
    _count: Detail_model_produkCountAggregateOutputType | null
    _avg: Detail_model_produkAvgAggregateOutputType | null
    _sum: Detail_model_produkSumAggregateOutputType | null
    _min: Detail_model_produkMinAggregateOutputType | null
    _max: Detail_model_produkMaxAggregateOutputType | null
  }

  export type Detail_model_produkAvgAggregateOutputType = {
    id: number | null
    biaya_jahit: number | null
    hpp: number | null
    harga_jual: number | null
    model_produk_id: number | null
  }

  export type Detail_model_produkSumAggregateOutputType = {
    id: number | null
    biaya_jahit: number | null
    hpp: number | null
    harga_jual: number | null
    model_produk_id: number | null
  }

  export type Detail_model_produkMinAggregateOutputType = {
    id: number | null
    ukuran: string | null
    biaya_jahit: number | null
    hpp: number | null
    harga_jual: number | null
    deleted_at: Date | null
    model_produk_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Detail_model_produkMaxAggregateOutputType = {
    id: number | null
    ukuran: string | null
    biaya_jahit: number | null
    hpp: number | null
    harga_jual: number | null
    deleted_at: Date | null
    model_produk_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Detail_model_produkCountAggregateOutputType = {
    id: number
    ukuran: number
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at: number
    model_produk_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Detail_model_produkAvgAggregateInputType = {
    id?: true
    biaya_jahit?: true
    hpp?: true
    harga_jual?: true
    model_produk_id?: true
  }

  export type Detail_model_produkSumAggregateInputType = {
    id?: true
    biaya_jahit?: true
    hpp?: true
    harga_jual?: true
    model_produk_id?: true
  }

  export type Detail_model_produkMinAggregateInputType = {
    id?: true
    ukuran?: true
    biaya_jahit?: true
    hpp?: true
    harga_jual?: true
    deleted_at?: true
    model_produk_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Detail_model_produkMaxAggregateInputType = {
    id?: true
    ukuran?: true
    biaya_jahit?: true
    hpp?: true
    harga_jual?: true
    deleted_at?: true
    model_produk_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Detail_model_produkCountAggregateInputType = {
    id?: true
    ukuran?: true
    biaya_jahit?: true
    hpp?: true
    harga_jual?: true
    deleted_at?: true
    model_produk_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Detail_model_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_model_produk to aggregate.
     */
    where?: detail_model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_model_produks to fetch.
     */
    orderBy?: detail_model_produkOrderByWithRelationInput | detail_model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detail_model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detail_model_produks
    **/
    _count?: true | Detail_model_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detail_model_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detail_model_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detail_model_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detail_model_produkMaxAggregateInputType
  }

  export type GetDetail_model_produkAggregateType<T extends Detail_model_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateDetail_model_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetail_model_produk[P]>
      : GetScalarType<T[P], AggregateDetail_model_produk[P]>
  }




  export type detail_model_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detail_model_produkWhereInput
    orderBy?: detail_model_produkOrderByWithAggregationInput | detail_model_produkOrderByWithAggregationInput[]
    by: Detail_model_produkScalarFieldEnum[] | Detail_model_produkScalarFieldEnum
    having?: detail_model_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detail_model_produkCountAggregateInputType | true
    _avg?: Detail_model_produkAvgAggregateInputType
    _sum?: Detail_model_produkSumAggregateInputType
    _min?: Detail_model_produkMinAggregateInputType
    _max?: Detail_model_produkMaxAggregateInputType
  }

  export type Detail_model_produkGroupByOutputType = {
    id: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at: Date | null
    model_produk_id: number
    created_at: Date
    updated_at: Date
    _count: Detail_model_produkCountAggregateOutputType | null
    _avg: Detail_model_produkAvgAggregateOutputType | null
    _sum: Detail_model_produkSumAggregateOutputType | null
    _min: Detail_model_produkMinAggregateOutputType | null
    _max: Detail_model_produkMaxAggregateOutputType | null
  }

  type GetDetail_model_produkGroupByPayload<T extends detail_model_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detail_model_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detail_model_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detail_model_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Detail_model_produkGroupByOutputType[P]>
        }
      >
    >


  export type detail_model_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ukuran?: boolean
    biaya_jahit?: boolean
    hpp?: boolean
    harga_jual?: boolean
    deleted_at?: boolean
    model_produk_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_produk?: boolean | model_produkDefaultArgs<ExtArgs>
    bahan_produk?: boolean | detail_model_produk$bahan_produkArgs<ExtArgs>
    daftar_produk?: boolean | detail_model_produk$daftar_produkArgs<ExtArgs>
    produksi?: boolean | detail_model_produk$produksiArgs<ExtArgs>
    _count?: boolean | Detail_model_produkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detail_model_produk"]>

  export type detail_model_produkSelectScalar = {
    id?: boolean
    ukuran?: boolean
    biaya_jahit?: boolean
    hpp?: boolean
    harga_jual?: boolean
    deleted_at?: boolean
    model_produk_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type detail_model_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_produk?: boolean | model_produkDefaultArgs<ExtArgs>
    bahan_produk?: boolean | detail_model_produk$bahan_produkArgs<ExtArgs>
    daftar_produk?: boolean | detail_model_produk$daftar_produkArgs<ExtArgs>
    produksi?: boolean | detail_model_produk$produksiArgs<ExtArgs>
    _count?: boolean | Detail_model_produkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $detail_model_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detail_model_produk"
    objects: {
      model_produk: Prisma.$model_produkPayload<ExtArgs>
      bahan_produk: Prisma.$bahan_produkPayload<ExtArgs>[]
      daftar_produk: Prisma.$daftar_produkPayload<ExtArgs>[]
      produksi: Prisma.$produksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ukuran: string
      biaya_jahit: number
      hpp: number
      harga_jual: number
      deleted_at: Date | null
      model_produk_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["detail_model_produk"]>
    composites: {}
  }


  type detail_model_produkGetPayload<S extends boolean | null | undefined | detail_model_produkDefaultArgs> = $Result.GetResult<Prisma.$detail_model_produkPayload, S>

  type detail_model_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detail_model_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Detail_model_produkCountAggregateInputType | true
    }

  export interface detail_model_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detail_model_produk'], meta: { name: 'detail_model_produk' } }
    /**
     * Find zero or one Detail_model_produk that matches the filter.
     * @param {detail_model_produkFindUniqueArgs} args - Arguments to find a Detail_model_produk
     * @example
     * // Get one Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detail_model_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detail_model_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detail_model_produkFindUniqueOrThrowArgs} args - Arguments to find a Detail_model_produk
     * @example
     * // Get one Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detail_model_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detail_model_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkFindFirstArgs} args - Arguments to find a Detail_model_produk
     * @example
     * // Get one Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detail_model_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkFindFirstArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detail_model_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkFindFirstOrThrowArgs} args - Arguments to find a Detail_model_produk
     * @example
     * // Get one Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detail_model_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detail_model_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detail_model_produks
     * const detail_model_produks = await prisma.detail_model_produk.findMany()
     * 
     * // Get first 10 Detail_model_produks
     * const detail_model_produks = await prisma.detail_model_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detail_model_produkWithIdOnly = await prisma.detail_model_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detail_model_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detail_model_produk.
     * @param {detail_model_produkCreateArgs} args - Arguments to create a Detail_model_produk.
     * @example
     * // Create one Detail_model_produk
     * const Detail_model_produk = await prisma.detail_model_produk.create({
     *   data: {
     *     // ... data to create a Detail_model_produk
     *   }
     * })
     * 
    **/
    create<T extends detail_model_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkCreateArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detail_model_produks.
     *     @param {detail_model_produkCreateManyArgs} args - Arguments to create many Detail_model_produks.
     *     @example
     *     // Create many Detail_model_produks
     *     const detail_model_produk = await prisma.detail_model_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detail_model_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detail_model_produk.
     * @param {detail_model_produkDeleteArgs} args - Arguments to delete one Detail_model_produk.
     * @example
     * // Delete one Detail_model_produk
     * const Detail_model_produk = await prisma.detail_model_produk.delete({
     *   where: {
     *     // ... filter to delete one Detail_model_produk
     *   }
     * })
     * 
    **/
    delete<T extends detail_model_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkDeleteArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detail_model_produk.
     * @param {detail_model_produkUpdateArgs} args - Arguments to update one Detail_model_produk.
     * @example
     * // Update one Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detail_model_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkUpdateArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detail_model_produks.
     * @param {detail_model_produkDeleteManyArgs} args - Arguments to filter Detail_model_produks to delete.
     * @example
     * // Delete a few Detail_model_produks
     * const { count } = await prisma.detail_model_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detail_model_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detail_model_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detail_model_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detail_model_produks
     * const detail_model_produk = await prisma.detail_model_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detail_model_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detail_model_produk.
     * @param {detail_model_produkUpsertArgs} args - Arguments to update or create a Detail_model_produk.
     * @example
     * // Update or create a Detail_model_produk
     * const detail_model_produk = await prisma.detail_model_produk.upsert({
     *   create: {
     *     // ... data to create a Detail_model_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detail_model_produk we want to update
     *   }
     * })
    **/
    upsert<T extends detail_model_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detail_model_produkUpsertArgs<ExtArgs>>
    ): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detail_model_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkCountArgs} args - Arguments to filter Detail_model_produks to count.
     * @example
     * // Count the number of Detail_model_produks
     * const count = await prisma.detail_model_produk.count({
     *   where: {
     *     // ... the filter for the Detail_model_produks we want to count
     *   }
     * })
    **/
    count<T extends detail_model_produkCountArgs>(
      args?: Subset<T, detail_model_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detail_model_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detail_model_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detail_model_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detail_model_produkAggregateArgs>(args: Subset<T, Detail_model_produkAggregateArgs>): Prisma.PrismaPromise<GetDetail_model_produkAggregateType<T>>

    /**
     * Group by Detail_model_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detail_model_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detail_model_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detail_model_produkGroupByArgs['orderBy'] }
        : { orderBy?: detail_model_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detail_model_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetail_model_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detail_model_produk model
   */
  readonly fields: detail_model_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detail_model_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detail_model_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    model_produk<T extends model_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, model_produkDefaultArgs<ExtArgs>>): Prisma__model_produkClient<$Result.GetResult<Prisma.$model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bahan_produk<T extends detail_model_produk$bahan_produkArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produk$bahan_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    daftar_produk<T extends detail_model_produk$daftar_produkArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produk$daftar_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    produksi<T extends detail_model_produk$produksiArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produk$produksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detail_model_produk model
   */ 
  interface detail_model_produkFieldRefs {
    readonly id: FieldRef<"detail_model_produk", 'Int'>
    readonly ukuran: FieldRef<"detail_model_produk", 'String'>
    readonly biaya_jahit: FieldRef<"detail_model_produk", 'Float'>
    readonly hpp: FieldRef<"detail_model_produk", 'Float'>
    readonly harga_jual: FieldRef<"detail_model_produk", 'Float'>
    readonly deleted_at: FieldRef<"detail_model_produk", 'DateTime'>
    readonly model_produk_id: FieldRef<"detail_model_produk", 'Int'>
    readonly created_at: FieldRef<"detail_model_produk", 'DateTime'>
    readonly updated_at: FieldRef<"detail_model_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * detail_model_produk findUnique
   */
  export type detail_model_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_model_produk to fetch.
     */
    where: detail_model_produkWhereUniqueInput
  }


  /**
   * detail_model_produk findUniqueOrThrow
   */
  export type detail_model_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_model_produk to fetch.
     */
    where: detail_model_produkWhereUniqueInput
  }


  /**
   * detail_model_produk findFirst
   */
  export type detail_model_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_model_produk to fetch.
     */
    where?: detail_model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_model_produks to fetch.
     */
    orderBy?: detail_model_produkOrderByWithRelationInput | detail_model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_model_produks.
     */
    cursor?: detail_model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_model_produks.
     */
    distinct?: Detail_model_produkScalarFieldEnum | Detail_model_produkScalarFieldEnum[]
  }


  /**
   * detail_model_produk findFirstOrThrow
   */
  export type detail_model_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_model_produk to fetch.
     */
    where?: detail_model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_model_produks to fetch.
     */
    orderBy?: detail_model_produkOrderByWithRelationInput | detail_model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detail_model_produks.
     */
    cursor?: detail_model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_model_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detail_model_produks.
     */
    distinct?: Detail_model_produkScalarFieldEnum | Detail_model_produkScalarFieldEnum[]
  }


  /**
   * detail_model_produk findMany
   */
  export type detail_model_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter, which detail_model_produks to fetch.
     */
    where?: detail_model_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detail_model_produks to fetch.
     */
    orderBy?: detail_model_produkOrderByWithRelationInput | detail_model_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detail_model_produks.
     */
    cursor?: detail_model_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detail_model_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detail_model_produks.
     */
    skip?: number
    distinct?: Detail_model_produkScalarFieldEnum | Detail_model_produkScalarFieldEnum[]
  }


  /**
   * detail_model_produk create
   */
  export type detail_model_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a detail_model_produk.
     */
    data: XOR<detail_model_produkCreateInput, detail_model_produkUncheckedCreateInput>
  }


  /**
   * detail_model_produk createMany
   */
  export type detail_model_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detail_model_produks.
     */
    data: detail_model_produkCreateManyInput | detail_model_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detail_model_produk update
   */
  export type detail_model_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a detail_model_produk.
     */
    data: XOR<detail_model_produkUpdateInput, detail_model_produkUncheckedUpdateInput>
    /**
     * Choose, which detail_model_produk to update.
     */
    where: detail_model_produkWhereUniqueInput
  }


  /**
   * detail_model_produk updateMany
   */
  export type detail_model_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detail_model_produks.
     */
    data: XOR<detail_model_produkUpdateManyMutationInput, detail_model_produkUncheckedUpdateManyInput>
    /**
     * Filter which detail_model_produks to update
     */
    where?: detail_model_produkWhereInput
  }


  /**
   * detail_model_produk upsert
   */
  export type detail_model_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the detail_model_produk to update in case it exists.
     */
    where: detail_model_produkWhereUniqueInput
    /**
     * In case the detail_model_produk found by the `where` argument doesn't exist, create a new detail_model_produk with this data.
     */
    create: XOR<detail_model_produkCreateInput, detail_model_produkUncheckedCreateInput>
    /**
     * In case the detail_model_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detail_model_produkUpdateInput, detail_model_produkUncheckedUpdateInput>
  }


  /**
   * detail_model_produk delete
   */
  export type detail_model_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
    /**
     * Filter which detail_model_produk to delete.
     */
    where: detail_model_produkWhereUniqueInput
  }


  /**
   * detail_model_produk deleteMany
   */
  export type detail_model_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detail_model_produks to delete
     */
    where?: detail_model_produkWhereInput
  }


  /**
   * detail_model_produk.bahan_produk
   */
  export type detail_model_produk$bahan_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    where?: bahan_produkWhereInput
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    cursor?: bahan_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bahan_produkScalarFieldEnum | Bahan_produkScalarFieldEnum[]
  }


  /**
   * detail_model_produk.daftar_produk
   */
  export type detail_model_produk$daftar_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    where?: daftar_produkWhereInput
    orderBy?: daftar_produkOrderByWithRelationInput | daftar_produkOrderByWithRelationInput[]
    cursor?: daftar_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Daftar_produkScalarFieldEnum | Daftar_produkScalarFieldEnum[]
  }


  /**
   * detail_model_produk.produksi
   */
  export type detail_model_produk$produksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    cursor?: produksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * detail_model_produk without action
   */
  export type detail_model_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detail_model_produk
     */
    select?: detail_model_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detail_model_produkInclude<ExtArgs> | null
  }



  /**
   * Model bahan_produk
   */

  export type AggregateBahan_produk = {
    _count: Bahan_produkCountAggregateOutputType | null
    _avg: Bahan_produkAvgAggregateOutputType | null
    _sum: Bahan_produkSumAggregateOutputType | null
    _min: Bahan_produkMinAggregateOutputType | null
    _max: Bahan_produkMaxAggregateOutputType | null
  }

  export type Bahan_produkAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    daftar_bahan_id: number | null
  }

  export type Bahan_produkSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    daftar_bahan_id: number | null
  }

  export type Bahan_produkMinAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    daftar_bahan_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Bahan_produkMaxAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    daftar_bahan_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Bahan_produkCountAggregateOutputType = {
    id: number
    jumlah: number
    detail_model_produk_id: number
    daftar_bahan_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Bahan_produkAvgAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    daftar_bahan_id?: true
  }

  export type Bahan_produkSumAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    daftar_bahan_id?: true
  }

  export type Bahan_produkMinAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    daftar_bahan_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Bahan_produkMaxAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    daftar_bahan_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Bahan_produkCountAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    daftar_bahan_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Bahan_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bahan_produk to aggregate.
     */
    where?: bahan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produks to fetch.
     */
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bahan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bahan_produks
    **/
    _count?: true | Bahan_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bahan_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bahan_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bahan_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bahan_produkMaxAggregateInputType
  }

  export type GetBahan_produkAggregateType<T extends Bahan_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateBahan_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahan_produk[P]>
      : GetScalarType<T[P], AggregateBahan_produk[P]>
  }




  export type bahan_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bahan_produkWhereInput
    orderBy?: bahan_produkOrderByWithAggregationInput | bahan_produkOrderByWithAggregationInput[]
    by: Bahan_produkScalarFieldEnum[] | Bahan_produkScalarFieldEnum
    having?: bahan_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bahan_produkCountAggregateInputType | true
    _avg?: Bahan_produkAvgAggregateInputType
    _sum?: Bahan_produkSumAggregateInputType
    _min?: Bahan_produkMinAggregateInputType
    _max?: Bahan_produkMaxAggregateInputType
  }

  export type Bahan_produkGroupByOutputType = {
    id: number
    jumlah: number
    detail_model_produk_id: number
    daftar_bahan_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Bahan_produkCountAggregateOutputType | null
    _avg: Bahan_produkAvgAggregateOutputType | null
    _sum: Bahan_produkSumAggregateOutputType | null
    _min: Bahan_produkMinAggregateOutputType | null
    _max: Bahan_produkMaxAggregateOutputType | null
  }

  type GetBahan_produkGroupByPayload<T extends bahan_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bahan_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bahan_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bahan_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Bahan_produkGroupByOutputType[P]>
        }
      >
    >


  export type bahan_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jumlah?: boolean
    detail_model_produk_id?: boolean
    daftar_bahan_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
    daftar_bahan?: boolean | daftar_bahanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahan_produk"]>

  export type bahan_produkSelectScalar = {
    id?: boolean
    jumlah?: boolean
    detail_model_produk_id?: boolean
    daftar_bahan_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type bahan_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
    daftar_bahan?: boolean | daftar_bahanDefaultArgs<ExtArgs>
  }


  export type $bahan_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bahan_produk"
    objects: {
      detail_model_produk: Prisma.$detail_model_produkPayload<ExtArgs>
      daftar_bahan: Prisma.$daftar_bahanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jumlah: number
      detail_model_produk_id: number
      daftar_bahan_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["bahan_produk"]>
    composites: {}
  }


  type bahan_produkGetPayload<S extends boolean | null | undefined | bahan_produkDefaultArgs> = $Result.GetResult<Prisma.$bahan_produkPayload, S>

  type bahan_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bahan_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Bahan_produkCountAggregateInputType | true
    }

  export interface bahan_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bahan_produk'], meta: { name: 'bahan_produk' } }
    /**
     * Find zero or one Bahan_produk that matches the filter.
     * @param {bahan_produkFindUniqueArgs} args - Arguments to find a Bahan_produk
     * @example
     * // Get one Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bahan_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bahan_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bahan_produkFindUniqueOrThrowArgs} args - Arguments to find a Bahan_produk
     * @example
     * // Get one Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bahan_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bahan_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkFindFirstArgs} args - Arguments to find a Bahan_produk
     * @example
     * // Get one Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bahan_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkFindFirstArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bahan_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkFindFirstOrThrowArgs} args - Arguments to find a Bahan_produk
     * @example
     * // Get one Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bahan_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bahan_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bahan_produks
     * const bahan_produks = await prisma.bahan_produk.findMany()
     * 
     * // Get first 10 Bahan_produks
     * const bahan_produks = await prisma.bahan_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bahan_produkWithIdOnly = await prisma.bahan_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bahan_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bahan_produk.
     * @param {bahan_produkCreateArgs} args - Arguments to create a Bahan_produk.
     * @example
     * // Create one Bahan_produk
     * const Bahan_produk = await prisma.bahan_produk.create({
     *   data: {
     *     // ... data to create a Bahan_produk
     *   }
     * })
     * 
    **/
    create<T extends bahan_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkCreateArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bahan_produks.
     *     @param {bahan_produkCreateManyArgs} args - Arguments to create many Bahan_produks.
     *     @example
     *     // Create many Bahan_produks
     *     const bahan_produk = await prisma.bahan_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bahan_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bahan_produk.
     * @param {bahan_produkDeleteArgs} args - Arguments to delete one Bahan_produk.
     * @example
     * // Delete one Bahan_produk
     * const Bahan_produk = await prisma.bahan_produk.delete({
     *   where: {
     *     // ... filter to delete one Bahan_produk
     *   }
     * })
     * 
    **/
    delete<T extends bahan_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkDeleteArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bahan_produk.
     * @param {bahan_produkUpdateArgs} args - Arguments to update one Bahan_produk.
     * @example
     * // Update one Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bahan_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkUpdateArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bahan_produks.
     * @param {bahan_produkDeleteManyArgs} args - Arguments to filter Bahan_produks to delete.
     * @example
     * // Delete a few Bahan_produks
     * const { count } = await prisma.bahan_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bahan_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bahan_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bahan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bahan_produks
     * const bahan_produk = await prisma.bahan_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bahan_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bahan_produk.
     * @param {bahan_produkUpsertArgs} args - Arguments to update or create a Bahan_produk.
     * @example
     * // Update or create a Bahan_produk
     * const bahan_produk = await prisma.bahan_produk.upsert({
     *   create: {
     *     // ... data to create a Bahan_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bahan_produk we want to update
     *   }
     * })
    **/
    upsert<T extends bahan_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bahan_produkUpsertArgs<ExtArgs>>
    ): Prisma__bahan_produkClient<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bahan_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkCountArgs} args - Arguments to filter Bahan_produks to count.
     * @example
     * // Count the number of Bahan_produks
     * const count = await prisma.bahan_produk.count({
     *   where: {
     *     // ... the filter for the Bahan_produks we want to count
     *   }
     * })
    **/
    count<T extends bahan_produkCountArgs>(
      args?: Subset<T, bahan_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bahan_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bahan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bahan_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bahan_produkAggregateArgs>(args: Subset<T, Bahan_produkAggregateArgs>): Prisma.PrismaPromise<GetBahan_produkAggregateType<T>>

    /**
     * Group by Bahan_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bahan_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bahan_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bahan_produkGroupByArgs['orderBy'] }
        : { orderBy?: bahan_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bahan_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahan_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bahan_produk model
   */
  readonly fields: bahan_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bahan_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bahan_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_model_produk<T extends detail_model_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produkDefaultArgs<ExtArgs>>): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    daftar_bahan<T extends daftar_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, daftar_bahanDefaultArgs<ExtArgs>>): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bahan_produk model
   */ 
  interface bahan_produkFieldRefs {
    readonly id: FieldRef<"bahan_produk", 'Int'>
    readonly jumlah: FieldRef<"bahan_produk", 'Float'>
    readonly detail_model_produk_id: FieldRef<"bahan_produk", 'Int'>
    readonly daftar_bahan_id: FieldRef<"bahan_produk", 'Int'>
    readonly created_at: FieldRef<"bahan_produk", 'DateTime'>
    readonly updated_at: FieldRef<"bahan_produk", 'DateTime'>
    readonly deleted_at: FieldRef<"bahan_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bahan_produk findUnique
   */
  export type bahan_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produk to fetch.
     */
    where: bahan_produkWhereUniqueInput
  }


  /**
   * bahan_produk findUniqueOrThrow
   */
  export type bahan_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produk to fetch.
     */
    where: bahan_produkWhereUniqueInput
  }


  /**
   * bahan_produk findFirst
   */
  export type bahan_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produk to fetch.
     */
    where?: bahan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produks to fetch.
     */
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bahan_produks.
     */
    cursor?: bahan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bahan_produks.
     */
    distinct?: Bahan_produkScalarFieldEnum | Bahan_produkScalarFieldEnum[]
  }


  /**
   * bahan_produk findFirstOrThrow
   */
  export type bahan_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produk to fetch.
     */
    where?: bahan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produks to fetch.
     */
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bahan_produks.
     */
    cursor?: bahan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bahan_produks.
     */
    distinct?: Bahan_produkScalarFieldEnum | Bahan_produkScalarFieldEnum[]
  }


  /**
   * bahan_produk findMany
   */
  export type bahan_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter, which bahan_produks to fetch.
     */
    where?: bahan_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bahan_produks to fetch.
     */
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bahan_produks.
     */
    cursor?: bahan_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bahan_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bahan_produks.
     */
    skip?: number
    distinct?: Bahan_produkScalarFieldEnum | Bahan_produkScalarFieldEnum[]
  }


  /**
   * bahan_produk create
   */
  export type bahan_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a bahan_produk.
     */
    data: XOR<bahan_produkCreateInput, bahan_produkUncheckedCreateInput>
  }


  /**
   * bahan_produk createMany
   */
  export type bahan_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bahan_produks.
     */
    data: bahan_produkCreateManyInput | bahan_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bahan_produk update
   */
  export type bahan_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a bahan_produk.
     */
    data: XOR<bahan_produkUpdateInput, bahan_produkUncheckedUpdateInput>
    /**
     * Choose, which bahan_produk to update.
     */
    where: bahan_produkWhereUniqueInput
  }


  /**
   * bahan_produk updateMany
   */
  export type bahan_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bahan_produks.
     */
    data: XOR<bahan_produkUpdateManyMutationInput, bahan_produkUncheckedUpdateManyInput>
    /**
     * Filter which bahan_produks to update
     */
    where?: bahan_produkWhereInput
  }


  /**
   * bahan_produk upsert
   */
  export type bahan_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the bahan_produk to update in case it exists.
     */
    where: bahan_produkWhereUniqueInput
    /**
     * In case the bahan_produk found by the `where` argument doesn't exist, create a new bahan_produk with this data.
     */
    create: XOR<bahan_produkCreateInput, bahan_produkUncheckedCreateInput>
    /**
     * In case the bahan_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bahan_produkUpdateInput, bahan_produkUncheckedUpdateInput>
  }


  /**
   * bahan_produk delete
   */
  export type bahan_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    /**
     * Filter which bahan_produk to delete.
     */
    where: bahan_produkWhereUniqueInput
  }


  /**
   * bahan_produk deleteMany
   */
  export type bahan_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bahan_produks to delete
     */
    where?: bahan_produkWhereInput
  }


  /**
   * bahan_produk without action
   */
  export type bahan_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
  }



  /**
   * Model daftar_bahan
   */

  export type AggregateDaftar_bahan = {
    _count: Daftar_bahanCountAggregateOutputType | null
    _avg: Daftar_bahanAvgAggregateOutputType | null
    _sum: Daftar_bahanSumAggregateOutputType | null
    _min: Daftar_bahanMinAggregateOutputType | null
    _max: Daftar_bahanMaxAggregateOutputType | null
  }

  export type Daftar_bahanAvgAggregateOutputType = {
    id: number | null
    stok: number | null
  }

  export type Daftar_bahanSumAggregateOutputType = {
    id: number | null
    stok: number | null
  }

  export type Daftar_bahanMinAggregateOutputType = {
    id: number | null
    kode: string | null
    stok: number | null
    nama: string | null
    satuan: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Daftar_bahanMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    stok: number | null
    nama: string | null
    satuan: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Daftar_bahanCountAggregateOutputType = {
    id: number
    kode: number
    stok: number
    nama: number
    satuan: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Daftar_bahanAvgAggregateInputType = {
    id?: true
    stok?: true
  }

  export type Daftar_bahanSumAggregateInputType = {
    id?: true
    stok?: true
  }

  export type Daftar_bahanMinAggregateInputType = {
    id?: true
    kode?: true
    stok?: true
    nama?: true
    satuan?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Daftar_bahanMaxAggregateInputType = {
    id?: true
    kode?: true
    stok?: true
    nama?: true
    satuan?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Daftar_bahanCountAggregateInputType = {
    id?: true
    kode?: true
    stok?: true
    nama?: true
    satuan?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Daftar_bahanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daftar_bahan to aggregate.
     */
    where?: daftar_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_bahans to fetch.
     */
    orderBy?: daftar_bahanOrderByWithRelationInput | daftar_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: daftar_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned daftar_bahans
    **/
    _count?: true | Daftar_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Daftar_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Daftar_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Daftar_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Daftar_bahanMaxAggregateInputType
  }

  export type GetDaftar_bahanAggregateType<T extends Daftar_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateDaftar_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaftar_bahan[P]>
      : GetScalarType<T[P], AggregateDaftar_bahan[P]>
  }




  export type daftar_bahanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daftar_bahanWhereInput
    orderBy?: daftar_bahanOrderByWithAggregationInput | daftar_bahanOrderByWithAggregationInput[]
    by: Daftar_bahanScalarFieldEnum[] | Daftar_bahanScalarFieldEnum
    having?: daftar_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Daftar_bahanCountAggregateInputType | true
    _avg?: Daftar_bahanAvgAggregateInputType
    _sum?: Daftar_bahanSumAggregateInputType
    _min?: Daftar_bahanMinAggregateInputType
    _max?: Daftar_bahanMaxAggregateInputType
  }

  export type Daftar_bahanGroupByOutputType = {
    id: number
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Daftar_bahanCountAggregateOutputType | null
    _avg: Daftar_bahanAvgAggregateOutputType | null
    _sum: Daftar_bahanSumAggregateOutputType | null
    _min: Daftar_bahanMinAggregateOutputType | null
    _max: Daftar_bahanMaxAggregateOutputType | null
  }

  type GetDaftar_bahanGroupByPayload<T extends daftar_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Daftar_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Daftar_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Daftar_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Daftar_bahanGroupByOutputType[P]>
        }
      >
    >


  export type daftar_bahanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    stok?: boolean
    nama?: boolean
    satuan?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    bahan_produk?: boolean | daftar_bahan$bahan_produkArgs<ExtArgs>
    restok_bahan?: boolean | daftar_bahan$restok_bahanArgs<ExtArgs>
    _count?: boolean | Daftar_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["daftar_bahan"]>

  export type daftar_bahanSelectScalar = {
    id?: boolean
    kode?: boolean
    stok?: boolean
    nama?: boolean
    satuan?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type daftar_bahanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bahan_produk?: boolean | daftar_bahan$bahan_produkArgs<ExtArgs>
    restok_bahan?: boolean | daftar_bahan$restok_bahanArgs<ExtArgs>
    _count?: boolean | Daftar_bahanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $daftar_bahanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "daftar_bahan"
    objects: {
      bahan_produk: Prisma.$bahan_produkPayload<ExtArgs>[]
      restok_bahan: Prisma.$restok_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      stok: number
      nama: string
      satuan: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["daftar_bahan"]>
    composites: {}
  }


  type daftar_bahanGetPayload<S extends boolean | null | undefined | daftar_bahanDefaultArgs> = $Result.GetResult<Prisma.$daftar_bahanPayload, S>

  type daftar_bahanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<daftar_bahanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Daftar_bahanCountAggregateInputType | true
    }

  export interface daftar_bahanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['daftar_bahan'], meta: { name: 'daftar_bahan' } }
    /**
     * Find zero or one Daftar_bahan that matches the filter.
     * @param {daftar_bahanFindUniqueArgs} args - Arguments to find a Daftar_bahan
     * @example
     * // Get one Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends daftar_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Daftar_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {daftar_bahanFindUniqueOrThrowArgs} args - Arguments to find a Daftar_bahan
     * @example
     * // Get one Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends daftar_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Daftar_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanFindFirstArgs} args - Arguments to find a Daftar_bahan
     * @example
     * // Get one Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends daftar_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Daftar_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanFindFirstOrThrowArgs} args - Arguments to find a Daftar_bahan
     * @example
     * // Get one Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends daftar_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Daftar_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Daftar_bahans
     * const daftar_bahans = await prisma.daftar_bahan.findMany()
     * 
     * // Get first 10 Daftar_bahans
     * const daftar_bahans = await prisma.daftar_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const daftar_bahanWithIdOnly = await prisma.daftar_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends daftar_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Daftar_bahan.
     * @param {daftar_bahanCreateArgs} args - Arguments to create a Daftar_bahan.
     * @example
     * // Create one Daftar_bahan
     * const Daftar_bahan = await prisma.daftar_bahan.create({
     *   data: {
     *     // ... data to create a Daftar_bahan
     *   }
     * })
     * 
    **/
    create<T extends daftar_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanCreateArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Daftar_bahans.
     *     @param {daftar_bahanCreateManyArgs} args - Arguments to create many Daftar_bahans.
     *     @example
     *     // Create many Daftar_bahans
     *     const daftar_bahan = await prisma.daftar_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends daftar_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Daftar_bahan.
     * @param {daftar_bahanDeleteArgs} args - Arguments to delete one Daftar_bahan.
     * @example
     * // Delete one Daftar_bahan
     * const Daftar_bahan = await prisma.daftar_bahan.delete({
     *   where: {
     *     // ... filter to delete one Daftar_bahan
     *   }
     * })
     * 
    **/
    delete<T extends daftar_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanDeleteArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Daftar_bahan.
     * @param {daftar_bahanUpdateArgs} args - Arguments to update one Daftar_bahan.
     * @example
     * // Update one Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends daftar_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanUpdateArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Daftar_bahans.
     * @param {daftar_bahanDeleteManyArgs} args - Arguments to filter Daftar_bahans to delete.
     * @example
     * // Delete a few Daftar_bahans
     * const { count } = await prisma.daftar_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends daftar_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Daftar_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Daftar_bahans
     * const daftar_bahan = await prisma.daftar_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends daftar_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Daftar_bahan.
     * @param {daftar_bahanUpsertArgs} args - Arguments to update or create a Daftar_bahan.
     * @example
     * // Update or create a Daftar_bahan
     * const daftar_bahan = await prisma.daftar_bahan.upsert({
     *   create: {
     *     // ... data to create a Daftar_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Daftar_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends daftar_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_bahanUpsertArgs<ExtArgs>>
    ): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Daftar_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanCountArgs} args - Arguments to filter Daftar_bahans to count.
     * @example
     * // Count the number of Daftar_bahans
     * const count = await prisma.daftar_bahan.count({
     *   where: {
     *     // ... the filter for the Daftar_bahans we want to count
     *   }
     * })
    **/
    count<T extends daftar_bahanCountArgs>(
      args?: Subset<T, daftar_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Daftar_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Daftar_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Daftar_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Daftar_bahanAggregateArgs>(args: Subset<T, Daftar_bahanAggregateArgs>): Prisma.PrismaPromise<GetDaftar_bahanAggregateType<T>>

    /**
     * Group by Daftar_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends daftar_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: daftar_bahanGroupByArgs['orderBy'] }
        : { orderBy?: daftar_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, daftar_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaftar_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the daftar_bahan model
   */
  readonly fields: daftar_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for daftar_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__daftar_bahanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bahan_produk<T extends daftar_bahan$bahan_produkArgs<ExtArgs> = {}>(args?: Subset<T, daftar_bahan$bahan_produkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bahan_produkPayload<ExtArgs>, T, 'findMany'> | Null>;

    restok_bahan<T extends daftar_bahan$restok_bahanArgs<ExtArgs> = {}>(args?: Subset<T, daftar_bahan$restok_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the daftar_bahan model
   */ 
  interface daftar_bahanFieldRefs {
    readonly id: FieldRef<"daftar_bahan", 'Int'>
    readonly kode: FieldRef<"daftar_bahan", 'String'>
    readonly stok: FieldRef<"daftar_bahan", 'Float'>
    readonly nama: FieldRef<"daftar_bahan", 'String'>
    readonly satuan: FieldRef<"daftar_bahan", 'String'>
    readonly created_at: FieldRef<"daftar_bahan", 'DateTime'>
    readonly updated_at: FieldRef<"daftar_bahan", 'DateTime'>
    readonly deleted_at: FieldRef<"daftar_bahan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * daftar_bahan findUnique
   */
  export type daftar_bahanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter, which daftar_bahan to fetch.
     */
    where: daftar_bahanWhereUniqueInput
  }


  /**
   * daftar_bahan findUniqueOrThrow
   */
  export type daftar_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter, which daftar_bahan to fetch.
     */
    where: daftar_bahanWhereUniqueInput
  }


  /**
   * daftar_bahan findFirst
   */
  export type daftar_bahanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter, which daftar_bahan to fetch.
     */
    where?: daftar_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_bahans to fetch.
     */
    orderBy?: daftar_bahanOrderByWithRelationInput | daftar_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daftar_bahans.
     */
    cursor?: daftar_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daftar_bahans.
     */
    distinct?: Daftar_bahanScalarFieldEnum | Daftar_bahanScalarFieldEnum[]
  }


  /**
   * daftar_bahan findFirstOrThrow
   */
  export type daftar_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter, which daftar_bahan to fetch.
     */
    where?: daftar_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_bahans to fetch.
     */
    orderBy?: daftar_bahanOrderByWithRelationInput | daftar_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daftar_bahans.
     */
    cursor?: daftar_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daftar_bahans.
     */
    distinct?: Daftar_bahanScalarFieldEnum | Daftar_bahanScalarFieldEnum[]
  }


  /**
   * daftar_bahan findMany
   */
  export type daftar_bahanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter, which daftar_bahans to fetch.
     */
    where?: daftar_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_bahans to fetch.
     */
    orderBy?: daftar_bahanOrderByWithRelationInput | daftar_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing daftar_bahans.
     */
    cursor?: daftar_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_bahans.
     */
    skip?: number
    distinct?: Daftar_bahanScalarFieldEnum | Daftar_bahanScalarFieldEnum[]
  }


  /**
   * daftar_bahan create
   */
  export type daftar_bahanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a daftar_bahan.
     */
    data: XOR<daftar_bahanCreateInput, daftar_bahanUncheckedCreateInput>
  }


  /**
   * daftar_bahan createMany
   */
  export type daftar_bahanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many daftar_bahans.
     */
    data: daftar_bahanCreateManyInput | daftar_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * daftar_bahan update
   */
  export type daftar_bahanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a daftar_bahan.
     */
    data: XOR<daftar_bahanUpdateInput, daftar_bahanUncheckedUpdateInput>
    /**
     * Choose, which daftar_bahan to update.
     */
    where: daftar_bahanWhereUniqueInput
  }


  /**
   * daftar_bahan updateMany
   */
  export type daftar_bahanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update daftar_bahans.
     */
    data: XOR<daftar_bahanUpdateManyMutationInput, daftar_bahanUncheckedUpdateManyInput>
    /**
     * Filter which daftar_bahans to update
     */
    where?: daftar_bahanWhereInput
  }


  /**
   * daftar_bahan upsert
   */
  export type daftar_bahanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the daftar_bahan to update in case it exists.
     */
    where: daftar_bahanWhereUniqueInput
    /**
     * In case the daftar_bahan found by the `where` argument doesn't exist, create a new daftar_bahan with this data.
     */
    create: XOR<daftar_bahanCreateInput, daftar_bahanUncheckedCreateInput>
    /**
     * In case the daftar_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<daftar_bahanUpdateInput, daftar_bahanUncheckedUpdateInput>
  }


  /**
   * daftar_bahan delete
   */
  export type daftar_bahanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
    /**
     * Filter which daftar_bahan to delete.
     */
    where: daftar_bahanWhereUniqueInput
  }


  /**
   * daftar_bahan deleteMany
   */
  export type daftar_bahanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daftar_bahans to delete
     */
    where?: daftar_bahanWhereInput
  }


  /**
   * daftar_bahan.bahan_produk
   */
  export type daftar_bahan$bahan_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bahan_produk
     */
    select?: bahan_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bahan_produkInclude<ExtArgs> | null
    where?: bahan_produkWhereInput
    orderBy?: bahan_produkOrderByWithRelationInput | bahan_produkOrderByWithRelationInput[]
    cursor?: bahan_produkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bahan_produkScalarFieldEnum | Bahan_produkScalarFieldEnum[]
  }


  /**
   * daftar_bahan.restok_bahan
   */
  export type daftar_bahan$restok_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    where?: restok_bahanWhereInput
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    cursor?: restok_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Restok_bahanScalarFieldEnum | Restok_bahanScalarFieldEnum[]
  }


  /**
   * daftar_bahan without action
   */
  export type daftar_bahanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_bahan
     */
    select?: daftar_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_bahanInclude<ExtArgs> | null
  }



  /**
   * Model restok_bahan
   */

  export type AggregateRestok_bahan = {
    _count: Restok_bahanCountAggregateOutputType | null
    _avg: Restok_bahanAvgAggregateOutputType | null
    _sum: Restok_bahanSumAggregateOutputType | null
    _min: Restok_bahanMinAggregateOutputType | null
    _max: Restok_bahanMaxAggregateOutputType | null
  }

  export type Restok_bahanAvgAggregateOutputType = {
    id: number | null
    harga_satuan: number | null
    jumlah: number | null
    daftar_bahan_id: number | null
    supplier_id: number | null
  }

  export type Restok_bahanSumAggregateOutputType = {
    id: number | null
    harga_satuan: number | null
    jumlah: number | null
    daftar_bahan_id: number | null
    supplier_id: number | null
  }

  export type Restok_bahanMinAggregateOutputType = {
    id: number | null
    tanggal_pesan: Date | null
    tanggal_terima: Date | null
    harga_satuan: number | null
    jumlah: number | null
    daftar_bahan_id: number | null
    supplier_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Restok_bahanMaxAggregateOutputType = {
    id: number | null
    tanggal_pesan: Date | null
    tanggal_terima: Date | null
    harga_satuan: number | null
    jumlah: number | null
    daftar_bahan_id: number | null
    supplier_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Restok_bahanCountAggregateOutputType = {
    id: number
    tanggal_pesan: number
    tanggal_terima: number
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    supplier_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Restok_bahanAvgAggregateInputType = {
    id?: true
    harga_satuan?: true
    jumlah?: true
    daftar_bahan_id?: true
    supplier_id?: true
  }

  export type Restok_bahanSumAggregateInputType = {
    id?: true
    harga_satuan?: true
    jumlah?: true
    daftar_bahan_id?: true
    supplier_id?: true
  }

  export type Restok_bahanMinAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    harga_satuan?: true
    jumlah?: true
    daftar_bahan_id?: true
    supplier_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Restok_bahanMaxAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    harga_satuan?: true
    jumlah?: true
    daftar_bahan_id?: true
    supplier_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Restok_bahanCountAggregateInputType = {
    id?: true
    tanggal_pesan?: true
    tanggal_terima?: true
    harga_satuan?: true
    jumlah?: true
    daftar_bahan_id?: true
    supplier_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Restok_bahanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which restok_bahan to aggregate.
     */
    where?: restok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of restok_bahans to fetch.
     */
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: restok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` restok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` restok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned restok_bahans
    **/
    _count?: true | Restok_bahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Restok_bahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Restok_bahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Restok_bahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Restok_bahanMaxAggregateInputType
  }

  export type GetRestok_bahanAggregateType<T extends Restok_bahanAggregateArgs> = {
        [P in keyof T & keyof AggregateRestok_bahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestok_bahan[P]>
      : GetScalarType<T[P], AggregateRestok_bahan[P]>
  }




  export type restok_bahanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: restok_bahanWhereInput
    orderBy?: restok_bahanOrderByWithAggregationInput | restok_bahanOrderByWithAggregationInput[]
    by: Restok_bahanScalarFieldEnum[] | Restok_bahanScalarFieldEnum
    having?: restok_bahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Restok_bahanCountAggregateInputType | true
    _avg?: Restok_bahanAvgAggregateInputType
    _sum?: Restok_bahanSumAggregateInputType
    _min?: Restok_bahanMinAggregateInputType
    _max?: Restok_bahanMaxAggregateInputType
  }

  export type Restok_bahanGroupByOutputType = {
    id: number
    tanggal_pesan: Date
    tanggal_terima: Date
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    supplier_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Restok_bahanCountAggregateOutputType | null
    _avg: Restok_bahanAvgAggregateOutputType | null
    _sum: Restok_bahanSumAggregateOutputType | null
    _min: Restok_bahanMinAggregateOutputType | null
    _max: Restok_bahanMaxAggregateOutputType | null
  }

  type GetRestok_bahanGroupByPayload<T extends restok_bahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Restok_bahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Restok_bahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Restok_bahanGroupByOutputType[P]>
            : GetScalarType<T[P], Restok_bahanGroupByOutputType[P]>
        }
      >
    >


  export type restok_bahanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal_pesan?: boolean
    tanggal_terima?: boolean
    harga_satuan?: boolean
    jumlah?: boolean
    daftar_bahan_id?: boolean
    supplier_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    daftar_bahan?: boolean | daftar_bahanDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restok_bahan"]>

  export type restok_bahanSelectScalar = {
    id?: boolean
    tanggal_pesan?: boolean
    tanggal_terima?: boolean
    harga_satuan?: boolean
    jumlah?: boolean
    daftar_bahan_id?: boolean
    supplier_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type restok_bahanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    daftar_bahan?: boolean | daftar_bahanDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }


  export type $restok_bahanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "restok_bahan"
    objects: {
      daftar_bahan: Prisma.$daftar_bahanPayload<ExtArgs>
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal_pesan: Date
      tanggal_terima: Date
      harga_satuan: number
      jumlah: number
      daftar_bahan_id: number
      supplier_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["restok_bahan"]>
    composites: {}
  }


  type restok_bahanGetPayload<S extends boolean | null | undefined | restok_bahanDefaultArgs> = $Result.GetResult<Prisma.$restok_bahanPayload, S>

  type restok_bahanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<restok_bahanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Restok_bahanCountAggregateInputType | true
    }

  export interface restok_bahanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['restok_bahan'], meta: { name: 'restok_bahan' } }
    /**
     * Find zero or one Restok_bahan that matches the filter.
     * @param {restok_bahanFindUniqueArgs} args - Arguments to find a Restok_bahan
     * @example
     * // Get one Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends restok_bahanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanFindUniqueArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Restok_bahan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {restok_bahanFindUniqueOrThrowArgs} args - Arguments to find a Restok_bahan
     * @example
     * // Get one Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends restok_bahanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Restok_bahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanFindFirstArgs} args - Arguments to find a Restok_bahan
     * @example
     * // Get one Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends restok_bahanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanFindFirstArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Restok_bahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanFindFirstOrThrowArgs} args - Arguments to find a Restok_bahan
     * @example
     * // Get one Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends restok_bahanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Restok_bahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restok_bahans
     * const restok_bahans = await prisma.restok_bahan.findMany()
     * 
     * // Get first 10 Restok_bahans
     * const restok_bahans = await prisma.restok_bahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restok_bahanWithIdOnly = await prisma.restok_bahan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends restok_bahanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Restok_bahan.
     * @param {restok_bahanCreateArgs} args - Arguments to create a Restok_bahan.
     * @example
     * // Create one Restok_bahan
     * const Restok_bahan = await prisma.restok_bahan.create({
     *   data: {
     *     // ... data to create a Restok_bahan
     *   }
     * })
     * 
    **/
    create<T extends restok_bahanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanCreateArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Restok_bahans.
     *     @param {restok_bahanCreateManyArgs} args - Arguments to create many Restok_bahans.
     *     @example
     *     // Create many Restok_bahans
     *     const restok_bahan = await prisma.restok_bahan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends restok_bahanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Restok_bahan.
     * @param {restok_bahanDeleteArgs} args - Arguments to delete one Restok_bahan.
     * @example
     * // Delete one Restok_bahan
     * const Restok_bahan = await prisma.restok_bahan.delete({
     *   where: {
     *     // ... filter to delete one Restok_bahan
     *   }
     * })
     * 
    **/
    delete<T extends restok_bahanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanDeleteArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Restok_bahan.
     * @param {restok_bahanUpdateArgs} args - Arguments to update one Restok_bahan.
     * @example
     * // Update one Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends restok_bahanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanUpdateArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Restok_bahans.
     * @param {restok_bahanDeleteManyArgs} args - Arguments to filter Restok_bahans to delete.
     * @example
     * // Delete a few Restok_bahans
     * const { count } = await prisma.restok_bahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends restok_bahanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, restok_bahanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restok_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restok_bahans
     * const restok_bahan = await prisma.restok_bahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends restok_bahanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restok_bahan.
     * @param {restok_bahanUpsertArgs} args - Arguments to update or create a Restok_bahan.
     * @example
     * // Update or create a Restok_bahan
     * const restok_bahan = await prisma.restok_bahan.upsert({
     *   create: {
     *     // ... data to create a Restok_bahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restok_bahan we want to update
     *   }
     * })
    **/
    upsert<T extends restok_bahanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, restok_bahanUpsertArgs<ExtArgs>>
    ): Prisma__restok_bahanClient<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Restok_bahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanCountArgs} args - Arguments to filter Restok_bahans to count.
     * @example
     * // Count the number of Restok_bahans
     * const count = await prisma.restok_bahan.count({
     *   where: {
     *     // ... the filter for the Restok_bahans we want to count
     *   }
     * })
    **/
    count<T extends restok_bahanCountArgs>(
      args?: Subset<T, restok_bahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Restok_bahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restok_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Restok_bahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Restok_bahanAggregateArgs>(args: Subset<T, Restok_bahanAggregateArgs>): Prisma.PrismaPromise<GetRestok_bahanAggregateType<T>>

    /**
     * Group by Restok_bahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {restok_bahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends restok_bahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: restok_bahanGroupByArgs['orderBy'] }
        : { orderBy?: restok_bahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, restok_bahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestok_bahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the restok_bahan model
   */
  readonly fields: restok_bahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for restok_bahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__restok_bahanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    daftar_bahan<T extends daftar_bahanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, daftar_bahanDefaultArgs<ExtArgs>>): Prisma__daftar_bahanClient<$Result.GetResult<Prisma.$daftar_bahanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the restok_bahan model
   */ 
  interface restok_bahanFieldRefs {
    readonly id: FieldRef<"restok_bahan", 'Int'>
    readonly tanggal_pesan: FieldRef<"restok_bahan", 'DateTime'>
    readonly tanggal_terima: FieldRef<"restok_bahan", 'DateTime'>
    readonly harga_satuan: FieldRef<"restok_bahan", 'Float'>
    readonly jumlah: FieldRef<"restok_bahan", 'Float'>
    readonly daftar_bahan_id: FieldRef<"restok_bahan", 'Int'>
    readonly supplier_id: FieldRef<"restok_bahan", 'Int'>
    readonly created_at: FieldRef<"restok_bahan", 'DateTime'>
    readonly updated_at: FieldRef<"restok_bahan", 'DateTime'>
    readonly deleted_at: FieldRef<"restok_bahan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * restok_bahan findUnique
   */
  export type restok_bahanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which restok_bahan to fetch.
     */
    where: restok_bahanWhereUniqueInput
  }


  /**
   * restok_bahan findUniqueOrThrow
   */
  export type restok_bahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which restok_bahan to fetch.
     */
    where: restok_bahanWhereUniqueInput
  }


  /**
   * restok_bahan findFirst
   */
  export type restok_bahanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which restok_bahan to fetch.
     */
    where?: restok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of restok_bahans to fetch.
     */
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for restok_bahans.
     */
    cursor?: restok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` restok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` restok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of restok_bahans.
     */
    distinct?: Restok_bahanScalarFieldEnum | Restok_bahanScalarFieldEnum[]
  }


  /**
   * restok_bahan findFirstOrThrow
   */
  export type restok_bahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which restok_bahan to fetch.
     */
    where?: restok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of restok_bahans to fetch.
     */
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for restok_bahans.
     */
    cursor?: restok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` restok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` restok_bahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of restok_bahans.
     */
    distinct?: Restok_bahanScalarFieldEnum | Restok_bahanScalarFieldEnum[]
  }


  /**
   * restok_bahan findMany
   */
  export type restok_bahanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter, which restok_bahans to fetch.
     */
    where?: restok_bahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of restok_bahans to fetch.
     */
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing restok_bahans.
     */
    cursor?: restok_bahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` restok_bahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` restok_bahans.
     */
    skip?: number
    distinct?: Restok_bahanScalarFieldEnum | Restok_bahanScalarFieldEnum[]
  }


  /**
   * restok_bahan create
   */
  export type restok_bahanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * The data needed to create a restok_bahan.
     */
    data: XOR<restok_bahanCreateInput, restok_bahanUncheckedCreateInput>
  }


  /**
   * restok_bahan createMany
   */
  export type restok_bahanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many restok_bahans.
     */
    data: restok_bahanCreateManyInput | restok_bahanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * restok_bahan update
   */
  export type restok_bahanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * The data needed to update a restok_bahan.
     */
    data: XOR<restok_bahanUpdateInput, restok_bahanUncheckedUpdateInput>
    /**
     * Choose, which restok_bahan to update.
     */
    where: restok_bahanWhereUniqueInput
  }


  /**
   * restok_bahan updateMany
   */
  export type restok_bahanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update restok_bahans.
     */
    data: XOR<restok_bahanUpdateManyMutationInput, restok_bahanUncheckedUpdateManyInput>
    /**
     * Filter which restok_bahans to update
     */
    where?: restok_bahanWhereInput
  }


  /**
   * restok_bahan upsert
   */
  export type restok_bahanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * The filter to search for the restok_bahan to update in case it exists.
     */
    where: restok_bahanWhereUniqueInput
    /**
     * In case the restok_bahan found by the `where` argument doesn't exist, create a new restok_bahan with this data.
     */
    create: XOR<restok_bahanCreateInput, restok_bahanUncheckedCreateInput>
    /**
     * In case the restok_bahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<restok_bahanUpdateInput, restok_bahanUncheckedUpdateInput>
  }


  /**
   * restok_bahan delete
   */
  export type restok_bahanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    /**
     * Filter which restok_bahan to delete.
     */
    where: restok_bahanWhereUniqueInput
  }


  /**
   * restok_bahan deleteMany
   */
  export type restok_bahanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which restok_bahans to delete
     */
    where?: restok_bahanWhereInput
  }


  /**
   * restok_bahan without action
   */
  export type restok_bahanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
  }



  /**
   * Model supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    kontak: string | null
    no_rek: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    kontak: string | null
    no_rek: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    kode: number
    nama: number
    alamat: number
    kontak: number
    no_rek: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    kontak?: true
    no_rek?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    kontak?: true
    no_rek?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    kontak?: true
    no_rek?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier to aggregate.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type supplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierWhereInput
    orderBy?: supplierOrderByWithAggregationInput | supplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends supplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    kontak?: boolean
    no_rek?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    restok_bahan?: boolean | supplier$restok_bahanArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type supplierSelectScalar = {
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    kontak?: boolean
    no_rek?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type supplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restok_bahan?: boolean | supplier$restok_bahanArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $supplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplier"
    objects: {
      restok_bahan: Prisma.$restok_bahanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      nama: string
      alamat: string
      kontak: string
      no_rek: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type supplierGetPayload<S extends boolean | null | undefined | supplierDefaultArgs> = $Result.GetResult<Prisma.$supplierPayload, S>

  type supplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supplierFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface supplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier'], meta: { name: 'supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, supplierFindUniqueArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {supplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends supplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends supplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends supplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends supplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierCreateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends supplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends supplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, supplierDeleteArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends supplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, supplierUpsertArgs<ExtArgs>>
    ): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierGroupByArgs['orderBy'] }
        : { orderBy?: supplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier model
   */
  readonly fields: supplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    restok_bahan<T extends supplier$restok_bahanArgs<ExtArgs> = {}>(args?: Subset<T, supplier$restok_bahanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$restok_bahanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the supplier model
   */ 
  interface supplierFieldRefs {
    readonly id: FieldRef<"supplier", 'Int'>
    readonly kode: FieldRef<"supplier", 'String'>
    readonly nama: FieldRef<"supplier", 'String'>
    readonly alamat: FieldRef<"supplier", 'String'>
    readonly kontak: FieldRef<"supplier", 'String'>
    readonly no_rek: FieldRef<"supplier", 'String'>
    readonly created_at: FieldRef<"supplier", 'DateTime'>
    readonly updated_at: FieldRef<"supplier", 'DateTime'>
    readonly deleted_at: FieldRef<"supplier", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findUniqueOrThrow
   */
  export type supplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier findFirstOrThrow
   */
  export type supplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier findMany
   */
  export type supplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which suppliers to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * supplier create
   */
  export type supplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to create a supplier.
     */
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }


  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * supplier update
   */
  export type supplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to update a supplier.
     */
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
  }


  /**
   * supplier upsert
   */
  export type supplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The filter to search for the supplier to update in case it exists.
     */
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     */
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }


  /**
   * supplier delete
   */
  export type supplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter which supplier to delete.
     */
    where: supplierWhereUniqueInput
  }


  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suppliers to delete
     */
    where?: supplierWhereInput
  }


  /**
   * supplier.restok_bahan
   */
  export type supplier$restok_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the restok_bahan
     */
    select?: restok_bahanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: restok_bahanInclude<ExtArgs> | null
    where?: restok_bahanWhereInput
    orderBy?: restok_bahanOrderByWithRelationInput | restok_bahanOrderByWithRelationInput[]
    cursor?: restok_bahanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Restok_bahanScalarFieldEnum | Restok_bahanScalarFieldEnum[]
  }


  /**
   * supplier without action
   */
  export type supplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: supplierInclude<ExtArgs> | null
  }



  /**
   * Model produksi
   */

  export type AggregateProduksi = {
    _count: ProduksiCountAggregateOutputType | null
    _avg: ProduksiAvgAggregateOutputType | null
    _sum: ProduksiSumAggregateOutputType | null
    _min: ProduksiMinAggregateOutputType | null
    _max: ProduksiMaxAggregateOutputType | null
  }

  export type ProduksiAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    user_id: number | null
  }

  export type ProduksiSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
    detail_model_produk_id: number | null
    user_id: number | null
  }

  export type ProduksiMinAggregateOutputType = {
    id: number | null
    produksi: string | null
    tanggal_mulai: Date | null
    tanggal_selesai: Date | null
    jumlah: number | null
    detail_model_produk_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProduksiMaxAggregateOutputType = {
    id: number | null
    produksi: string | null
    tanggal_mulai: Date | null
    tanggal_selesai: Date | null
    jumlah: number | null
    detail_model_produk_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProduksiCountAggregateOutputType = {
    id: number
    produksi: number
    tanggal_mulai: number
    tanggal_selesai: number
    jumlah: number
    detail_model_produk_id: number
    user_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ProduksiAvgAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    user_id?: true
  }

  export type ProduksiSumAggregateInputType = {
    id?: true
    jumlah?: true
    detail_model_produk_id?: true
    user_id?: true
  }

  export type ProduksiMinAggregateInputType = {
    id?: true
    produksi?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
    jumlah?: true
    detail_model_produk_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProduksiMaxAggregateInputType = {
    id?: true
    produksi?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
    jumlah?: true
    detail_model_produk_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProduksiCountAggregateInputType = {
    id?: true
    produksi?: true
    tanggal_mulai?: true
    tanggal_selesai?: true
    jumlah?: true
    detail_model_produk_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ProduksiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produksi to aggregate.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produksis
    **/
    _count?: true | ProduksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduksiMaxAggregateInputType
  }

  export type GetProduksiAggregateType<T extends ProduksiAggregateArgs> = {
        [P in keyof T & keyof AggregateProduksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduksi[P]>
      : GetScalarType<T[P], AggregateProduksi[P]>
  }




  export type produksiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produksiWhereInput
    orderBy?: produksiOrderByWithAggregationInput | produksiOrderByWithAggregationInput[]
    by: ProduksiScalarFieldEnum[] | ProduksiScalarFieldEnum
    having?: produksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduksiCountAggregateInputType | true
    _avg?: ProduksiAvgAggregateInputType
    _sum?: ProduksiSumAggregateInputType
    _min?: ProduksiMinAggregateInputType
    _max?: ProduksiMaxAggregateInputType
  }

  export type ProduksiGroupByOutputType = {
    id: number
    produksi: string
    tanggal_mulai: Date
    tanggal_selesai: Date | null
    jumlah: number
    detail_model_produk_id: number
    user_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ProduksiCountAggregateOutputType | null
    _avg: ProduksiAvgAggregateOutputType | null
    _sum: ProduksiSumAggregateOutputType | null
    _min: ProduksiMinAggregateOutputType | null
    _max: ProduksiMaxAggregateOutputType | null
  }

  type GetProduksiGroupByPayload<T extends produksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduksiGroupByOutputType[P]>
            : GetScalarType<T[P], ProduksiGroupByOutputType[P]>
        }
      >
    >


  export type produksiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produksi?: boolean
    tanggal_mulai?: boolean
    tanggal_selesai?: boolean
    jumlah?: boolean
    detail_model_produk_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    qcproduksi?: boolean | produksi$qcproduksiArgs<ExtArgs>
    _count?: boolean | ProduksiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produksi"]>

  export type produksiSelectScalar = {
    id?: boolean
    produksi?: boolean
    tanggal_mulai?: boolean
    tanggal_selesai?: boolean
    jumlah?: boolean
    detail_model_produk_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type produksiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    qcproduksi?: boolean | produksi$qcproduksiArgs<ExtArgs>
    _count?: boolean | ProduksiCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $produksiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "produksi"
    objects: {
      detail_model_produk: Prisma.$detail_model_produkPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
      qcproduksi: Prisma.$qcproduksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produksi: string
      tanggal_mulai: Date
      tanggal_selesai: Date | null
      jumlah: number
      detail_model_produk_id: number
      user_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["produksi"]>
    composites: {}
  }


  type produksiGetPayload<S extends boolean | null | undefined | produksiDefaultArgs> = $Result.GetResult<Prisma.$produksiPayload, S>

  type produksiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<produksiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProduksiCountAggregateInputType | true
    }

  export interface produksiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produksi'], meta: { name: 'produksi' } }
    /**
     * Find zero or one Produksi that matches the filter.
     * @param {produksiFindUniqueArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends produksiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, produksiFindUniqueArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Produksi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {produksiFindUniqueOrThrowArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends produksiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Produksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindFirstArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends produksiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindFirstArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Produksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindFirstOrThrowArgs} args - Arguments to find a Produksi
     * @example
     * // Get one Produksi
     * const produksi = await prisma.produksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends produksiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Produksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produksis
     * const produksis = await prisma.produksi.findMany()
     * 
     * // Get first 10 Produksis
     * const produksis = await prisma.produksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produksiWithIdOnly = await prisma.produksi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends produksiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Produksi.
     * @param {produksiCreateArgs} args - Arguments to create a Produksi.
     * @example
     * // Create one Produksi
     * const Produksi = await prisma.produksi.create({
     *   data: {
     *     // ... data to create a Produksi
     *   }
     * })
     * 
    **/
    create<T extends produksiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, produksiCreateArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Produksis.
     *     @param {produksiCreateManyArgs} args - Arguments to create many Produksis.
     *     @example
     *     // Create many Produksis
     *     const produksi = await prisma.produksi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends produksiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produksi.
     * @param {produksiDeleteArgs} args - Arguments to delete one Produksi.
     * @example
     * // Delete one Produksi
     * const Produksi = await prisma.produksi.delete({
     *   where: {
     *     // ... filter to delete one Produksi
     *   }
     * })
     * 
    **/
    delete<T extends produksiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, produksiDeleteArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Produksi.
     * @param {produksiUpdateArgs} args - Arguments to update one Produksi.
     * @example
     * // Update one Produksi
     * const produksi = await prisma.produksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends produksiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpdateArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Produksis.
     * @param {produksiDeleteManyArgs} args - Arguments to filter Produksis to delete.
     * @example
     * // Delete a few Produksis
     * const { count } = await prisma.produksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends produksiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produksiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produksis
     * const produksi = await prisma.produksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends produksiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produksi.
     * @param {produksiUpsertArgs} args - Arguments to update or create a Produksi.
     * @example
     * // Update or create a Produksi
     * const produksi = await prisma.produksi.upsert({
     *   create: {
     *     // ... data to create a Produksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produksi we want to update
     *   }
     * })
    **/
    upsert<T extends produksiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, produksiUpsertArgs<ExtArgs>>
    ): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Produksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiCountArgs} args - Arguments to filter Produksis to count.
     * @example
     * // Count the number of Produksis
     * const count = await prisma.produksi.count({
     *   where: {
     *     // ... the filter for the Produksis we want to count
     *   }
     * })
    **/
    count<T extends produksiCountArgs>(
      args?: Subset<T, produksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduksiAggregateArgs>(args: Subset<T, ProduksiAggregateArgs>): Prisma.PrismaPromise<GetProduksiAggregateType<T>>

    /**
     * Group by Produksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produksiGroupByArgs['orderBy'] }
        : { orderBy?: produksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produksi model
   */
  readonly fields: produksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produksiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_model_produk<T extends detail_model_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produkDefaultArgs<ExtArgs>>): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    qcproduksi<T extends produksi$qcproduksiArgs<ExtArgs> = {}>(args?: Subset<T, produksi$qcproduksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the produksi model
   */ 
  interface produksiFieldRefs {
    readonly id: FieldRef<"produksi", 'Int'>
    readonly produksi: FieldRef<"produksi", 'String'>
    readonly tanggal_mulai: FieldRef<"produksi", 'DateTime'>
    readonly tanggal_selesai: FieldRef<"produksi", 'DateTime'>
    readonly jumlah: FieldRef<"produksi", 'Int'>
    readonly detail_model_produk_id: FieldRef<"produksi", 'Int'>
    readonly user_id: FieldRef<"produksi", 'Int'>
    readonly created_at: FieldRef<"produksi", 'DateTime'>
    readonly updated_at: FieldRef<"produksi", 'DateTime'>
    readonly deleted_at: FieldRef<"produksi", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * produksi findUnique
   */
  export type produksiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi findUniqueOrThrow
   */
  export type produksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi findFirst
   */
  export type produksiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produksis.
     */
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi findFirstOrThrow
   */
  export type produksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksi to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produksis.
     */
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi findMany
   */
  export type produksiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter, which produksis to fetch.
     */
    where?: produksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produksis to fetch.
     */
    orderBy?: produksiOrderByWithRelationInput | produksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produksis.
     */
    cursor?: produksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produksis.
     */
    skip?: number
    distinct?: ProduksiScalarFieldEnum | ProduksiScalarFieldEnum[]
  }


  /**
   * produksi create
   */
  export type produksiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The data needed to create a produksi.
     */
    data: XOR<produksiCreateInput, produksiUncheckedCreateInput>
  }


  /**
   * produksi createMany
   */
  export type produksiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produksis.
     */
    data: produksiCreateManyInput | produksiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * produksi update
   */
  export type produksiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The data needed to update a produksi.
     */
    data: XOR<produksiUpdateInput, produksiUncheckedUpdateInput>
    /**
     * Choose, which produksi to update.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi updateMany
   */
  export type produksiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produksis.
     */
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyInput>
    /**
     * Filter which produksis to update
     */
    where?: produksiWhereInput
  }


  /**
   * produksi upsert
   */
  export type produksiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * The filter to search for the produksi to update in case it exists.
     */
    where: produksiWhereUniqueInput
    /**
     * In case the produksi found by the `where` argument doesn't exist, create a new produksi with this data.
     */
    create: XOR<produksiCreateInput, produksiUncheckedCreateInput>
    /**
     * In case the produksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produksiUpdateInput, produksiUncheckedUpdateInput>
  }


  /**
   * produksi delete
   */
  export type produksiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
    /**
     * Filter which produksi to delete.
     */
    where: produksiWhereUniqueInput
  }


  /**
   * produksi deleteMany
   */
  export type produksiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produksis to delete
     */
    where?: produksiWhereInput
  }


  /**
   * produksi.qcproduksi
   */
  export type produksi$qcproduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    where?: qcproduksiWhereInput
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    cursor?: qcproduksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcproduksiScalarFieldEnum | QcproduksiScalarFieldEnum[]
  }


  /**
   * produksi without action
   */
  export type produksiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produksi
     */
    select?: produksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: produksiInclude<ExtArgs> | null
  }



  /**
   * Model qcproduksi
   */

  export type AggregateQcproduksi = {
    _count: QcproduksiCountAggregateOutputType | null
    _avg: QcproduksiAvgAggregateOutputType | null
    _sum: QcproduksiSumAggregateOutputType | null
    _min: QcproduksiMinAggregateOutputType | null
    _max: QcproduksiMaxAggregateOutputType | null
  }

  export type QcproduksiAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    produksi_id: number | null
  }

  export type QcproduksiSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    produksi_id: number | null
  }

  export type QcproduksiMinAggregateOutputType = {
    id: number | null
    waktu: Date | null
    deskripsi: string | null
    status: string | null
    user_id: number | null
    produksi_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QcproduksiMaxAggregateOutputType = {
    id: number | null
    waktu: Date | null
    deskripsi: string | null
    status: string | null
    user_id: number | null
    produksi_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QcproduksiCountAggregateOutputType = {
    id: number
    waktu: number
    deskripsi: number
    status: number
    user_id: number
    produksi_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type QcproduksiAvgAggregateInputType = {
    id?: true
    user_id?: true
    produksi_id?: true
  }

  export type QcproduksiSumAggregateInputType = {
    id?: true
    user_id?: true
    produksi_id?: true
  }

  export type QcproduksiMinAggregateInputType = {
    id?: true
    waktu?: true
    deskripsi?: true
    status?: true
    user_id?: true
    produksi_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QcproduksiMaxAggregateInputType = {
    id?: true
    waktu?: true
    deskripsi?: true
    status?: true
    user_id?: true
    produksi_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QcproduksiCountAggregateInputType = {
    id?: true
    waktu?: true
    deskripsi?: true
    status?: true
    user_id?: true
    produksi_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type QcproduksiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcproduksi to aggregate.
     */
    where?: qcproduksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcproduksis to fetch.
     */
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qcproduksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcproduksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcproduksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qcproduksis
    **/
    _count?: true | QcproduksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcproduksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcproduksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcproduksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcproduksiMaxAggregateInputType
  }

  export type GetQcproduksiAggregateType<T extends QcproduksiAggregateArgs> = {
        [P in keyof T & keyof AggregateQcproduksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcproduksi[P]>
      : GetScalarType<T[P], AggregateQcproduksi[P]>
  }




  export type qcproduksiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qcproduksiWhereInput
    orderBy?: qcproduksiOrderByWithAggregationInput | qcproduksiOrderByWithAggregationInput[]
    by: QcproduksiScalarFieldEnum[] | QcproduksiScalarFieldEnum
    having?: qcproduksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcproduksiCountAggregateInputType | true
    _avg?: QcproduksiAvgAggregateInputType
    _sum?: QcproduksiSumAggregateInputType
    _min?: QcproduksiMinAggregateInputType
    _max?: QcproduksiMaxAggregateInputType
  }

  export type QcproduksiGroupByOutputType = {
    id: number
    waktu: Date
    deskripsi: string
    status: string
    user_id: number
    produksi_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: QcproduksiCountAggregateOutputType | null
    _avg: QcproduksiAvgAggregateOutputType | null
    _sum: QcproduksiSumAggregateOutputType | null
    _min: QcproduksiMinAggregateOutputType | null
    _max: QcproduksiMaxAggregateOutputType | null
  }

  type GetQcproduksiGroupByPayload<T extends qcproduksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcproduksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcproduksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcproduksiGroupByOutputType[P]>
            : GetScalarType<T[P], QcproduksiGroupByOutputType[P]>
        }
      >
    >


  export type qcproduksiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    waktu?: boolean
    deskripsi?: boolean
    status?: boolean
    user_id?: boolean
    produksi_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcproduksi"]>

  export type qcproduksiSelectScalar = {
    id?: boolean
    waktu?: boolean
    deskripsi?: boolean
    status?: boolean
    user_id?: boolean
    produksi_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type qcproduksiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    produksi?: boolean | produksiDefaultArgs<ExtArgs>
  }


  export type $qcproduksiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qcproduksi"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      produksi: Prisma.$produksiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      waktu: Date
      deskripsi: string
      status: string
      user_id: number
      produksi_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["qcproduksi"]>
    composites: {}
  }


  type qcproduksiGetPayload<S extends boolean | null | undefined | qcproduksiDefaultArgs> = $Result.GetResult<Prisma.$qcproduksiPayload, S>

  type qcproduksiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<qcproduksiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: QcproduksiCountAggregateInputType | true
    }

  export interface qcproduksiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qcproduksi'], meta: { name: 'qcproduksi' } }
    /**
     * Find zero or one Qcproduksi that matches the filter.
     * @param {qcproduksiFindUniqueArgs} args - Arguments to find a Qcproduksi
     * @example
     * // Get one Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qcproduksiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiFindUniqueArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Qcproduksi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {qcproduksiFindUniqueOrThrowArgs} args - Arguments to find a Qcproduksi
     * @example
     * // Get one Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends qcproduksiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Qcproduksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiFindFirstArgs} args - Arguments to find a Qcproduksi
     * @example
     * // Get one Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qcproduksiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiFindFirstArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Qcproduksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiFindFirstOrThrowArgs} args - Arguments to find a Qcproduksi
     * @example
     * // Get one Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends qcproduksiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Qcproduksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qcproduksis
     * const qcproduksis = await prisma.qcproduksi.findMany()
     * 
     * // Get first 10 Qcproduksis
     * const qcproduksis = await prisma.qcproduksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcproduksiWithIdOnly = await prisma.qcproduksi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends qcproduksiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Qcproduksi.
     * @param {qcproduksiCreateArgs} args - Arguments to create a Qcproduksi.
     * @example
     * // Create one Qcproduksi
     * const Qcproduksi = await prisma.qcproduksi.create({
     *   data: {
     *     // ... data to create a Qcproduksi
     *   }
     * })
     * 
    **/
    create<T extends qcproduksiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiCreateArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Qcproduksis.
     *     @param {qcproduksiCreateManyArgs} args - Arguments to create many Qcproduksis.
     *     @example
     *     // Create many Qcproduksis
     *     const qcproduksi = await prisma.qcproduksi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qcproduksiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qcproduksi.
     * @param {qcproduksiDeleteArgs} args - Arguments to delete one Qcproduksi.
     * @example
     * // Delete one Qcproduksi
     * const Qcproduksi = await prisma.qcproduksi.delete({
     *   where: {
     *     // ... filter to delete one Qcproduksi
     *   }
     * })
     * 
    **/
    delete<T extends qcproduksiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiDeleteArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Qcproduksi.
     * @param {qcproduksiUpdateArgs} args - Arguments to update one Qcproduksi.
     * @example
     * // Update one Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qcproduksiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiUpdateArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Qcproduksis.
     * @param {qcproduksiDeleteManyArgs} args - Arguments to filter Qcproduksis to delete.
     * @example
     * // Delete a few Qcproduksis
     * const { count } = await prisma.qcproduksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qcproduksiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcproduksiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qcproduksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qcproduksis
     * const qcproduksi = await prisma.qcproduksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qcproduksiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qcproduksi.
     * @param {qcproduksiUpsertArgs} args - Arguments to update or create a Qcproduksi.
     * @example
     * // Update or create a Qcproduksi
     * const qcproduksi = await prisma.qcproduksi.upsert({
     *   create: {
     *     // ... data to create a Qcproduksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qcproduksi we want to update
     *   }
     * })
    **/
    upsert<T extends qcproduksiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, qcproduksiUpsertArgs<ExtArgs>>
    ): Prisma__qcproduksiClient<$Result.GetResult<Prisma.$qcproduksiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Qcproduksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiCountArgs} args - Arguments to filter Qcproduksis to count.
     * @example
     * // Count the number of Qcproduksis
     * const count = await prisma.qcproduksi.count({
     *   where: {
     *     // ... the filter for the Qcproduksis we want to count
     *   }
     * })
    **/
    count<T extends qcproduksiCountArgs>(
      args?: Subset<T, qcproduksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcproduksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qcproduksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcproduksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcproduksiAggregateArgs>(args: Subset<T, QcproduksiAggregateArgs>): Prisma.PrismaPromise<GetQcproduksiAggregateType<T>>

    /**
     * Group by Qcproduksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcproduksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qcproduksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qcproduksiGroupByArgs['orderBy'] }
        : { orderBy?: qcproduksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qcproduksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcproduksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qcproduksi model
   */
  readonly fields: qcproduksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qcproduksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qcproduksiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    produksi<T extends produksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produksiDefaultArgs<ExtArgs>>): Prisma__produksiClient<$Result.GetResult<Prisma.$produksiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the qcproduksi model
   */ 
  interface qcproduksiFieldRefs {
    readonly id: FieldRef<"qcproduksi", 'Int'>
    readonly waktu: FieldRef<"qcproduksi", 'DateTime'>
    readonly deskripsi: FieldRef<"qcproduksi", 'String'>
    readonly status: FieldRef<"qcproduksi", 'String'>
    readonly user_id: FieldRef<"qcproduksi", 'Int'>
    readonly produksi_id: FieldRef<"qcproduksi", 'Int'>
    readonly created_at: FieldRef<"qcproduksi", 'DateTime'>
    readonly updated_at: FieldRef<"qcproduksi", 'DateTime'>
    readonly deleted_at: FieldRef<"qcproduksi", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * qcproduksi findUnique
   */
  export type qcproduksiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter, which qcproduksi to fetch.
     */
    where: qcproduksiWhereUniqueInput
  }


  /**
   * qcproduksi findUniqueOrThrow
   */
  export type qcproduksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter, which qcproduksi to fetch.
     */
    where: qcproduksiWhereUniqueInput
  }


  /**
   * qcproduksi findFirst
   */
  export type qcproduksiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter, which qcproduksi to fetch.
     */
    where?: qcproduksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcproduksis to fetch.
     */
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcproduksis.
     */
    cursor?: qcproduksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcproduksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcproduksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcproduksis.
     */
    distinct?: QcproduksiScalarFieldEnum | QcproduksiScalarFieldEnum[]
  }


  /**
   * qcproduksi findFirstOrThrow
   */
  export type qcproduksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter, which qcproduksi to fetch.
     */
    where?: qcproduksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcproduksis to fetch.
     */
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcproduksis.
     */
    cursor?: qcproduksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcproduksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcproduksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcproduksis.
     */
    distinct?: QcproduksiScalarFieldEnum | QcproduksiScalarFieldEnum[]
  }


  /**
   * qcproduksi findMany
   */
  export type qcproduksiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter, which qcproduksis to fetch.
     */
    where?: qcproduksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcproduksis to fetch.
     */
    orderBy?: qcproduksiOrderByWithRelationInput | qcproduksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qcproduksis.
     */
    cursor?: qcproduksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcproduksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcproduksis.
     */
    skip?: number
    distinct?: QcproduksiScalarFieldEnum | QcproduksiScalarFieldEnum[]
  }


  /**
   * qcproduksi create
   */
  export type qcproduksiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * The data needed to create a qcproduksi.
     */
    data: XOR<qcproduksiCreateInput, qcproduksiUncheckedCreateInput>
  }


  /**
   * qcproduksi createMany
   */
  export type qcproduksiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qcproduksis.
     */
    data: qcproduksiCreateManyInput | qcproduksiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * qcproduksi update
   */
  export type qcproduksiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * The data needed to update a qcproduksi.
     */
    data: XOR<qcproduksiUpdateInput, qcproduksiUncheckedUpdateInput>
    /**
     * Choose, which qcproduksi to update.
     */
    where: qcproduksiWhereUniqueInput
  }


  /**
   * qcproduksi updateMany
   */
  export type qcproduksiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qcproduksis.
     */
    data: XOR<qcproduksiUpdateManyMutationInput, qcproduksiUncheckedUpdateManyInput>
    /**
     * Filter which qcproduksis to update
     */
    where?: qcproduksiWhereInput
  }


  /**
   * qcproduksi upsert
   */
  export type qcproduksiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * The filter to search for the qcproduksi to update in case it exists.
     */
    where: qcproduksiWhereUniqueInput
    /**
     * In case the qcproduksi found by the `where` argument doesn't exist, create a new qcproduksi with this data.
     */
    create: XOR<qcproduksiCreateInput, qcproduksiUncheckedCreateInput>
    /**
     * In case the qcproduksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qcproduksiUpdateInput, qcproduksiUncheckedUpdateInput>
  }


  /**
   * qcproduksi delete
   */
  export type qcproduksiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
    /**
     * Filter which qcproduksi to delete.
     */
    where: qcproduksiWhereUniqueInput
  }


  /**
   * qcproduksi deleteMany
   */
  export type qcproduksiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcproduksis to delete
     */
    where?: qcproduksiWhereInput
  }


  /**
   * qcproduksi without action
   */
  export type qcproduksiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcproduksi
     */
    select?: qcproduksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcproduksiInclude<ExtArgs> | null
  }



  /**
   * Model daftar_produk
   */

  export type AggregateDaftar_produk = {
    _count: Daftar_produkCountAggregateOutputType | null
    _avg: Daftar_produkAvgAggregateOutputType | null
    _sum: Daftar_produkSumAggregateOutputType | null
    _min: Daftar_produkMinAggregateOutputType | null
    _max: Daftar_produkMaxAggregateOutputType | null
  }

  export type Daftar_produkAvgAggregateOutputType = {
    id: number | null
    detail_model_produk_id: number | null
  }

  export type Daftar_produkSumAggregateOutputType = {
    id: number | null
    detail_model_produk_id: number | null
  }

  export type Daftar_produkMinAggregateOutputType = {
    id: number | null
    sku: string | null
    detail_model_produk_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Daftar_produkMaxAggregateOutputType = {
    id: number | null
    sku: string | null
    detail_model_produk_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Daftar_produkCountAggregateOutputType = {
    id: number
    sku: number
    detail_model_produk_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Daftar_produkAvgAggregateInputType = {
    id?: true
    detail_model_produk_id?: true
  }

  export type Daftar_produkSumAggregateInputType = {
    id?: true
    detail_model_produk_id?: true
  }

  export type Daftar_produkMinAggregateInputType = {
    id?: true
    sku?: true
    detail_model_produk_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Daftar_produkMaxAggregateInputType = {
    id?: true
    sku?: true
    detail_model_produk_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Daftar_produkCountAggregateInputType = {
    id?: true
    sku?: true
    detail_model_produk_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Daftar_produkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daftar_produk to aggregate.
     */
    where?: daftar_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_produks to fetch.
     */
    orderBy?: daftar_produkOrderByWithRelationInput | daftar_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: daftar_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned daftar_produks
    **/
    _count?: true | Daftar_produkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Daftar_produkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Daftar_produkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Daftar_produkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Daftar_produkMaxAggregateInputType
  }

  export type GetDaftar_produkAggregateType<T extends Daftar_produkAggregateArgs> = {
        [P in keyof T & keyof AggregateDaftar_produk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaftar_produk[P]>
      : GetScalarType<T[P], AggregateDaftar_produk[P]>
  }




  export type daftar_produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daftar_produkWhereInput
    orderBy?: daftar_produkOrderByWithAggregationInput | daftar_produkOrderByWithAggregationInput[]
    by: Daftar_produkScalarFieldEnum[] | Daftar_produkScalarFieldEnum
    having?: daftar_produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Daftar_produkCountAggregateInputType | true
    _avg?: Daftar_produkAvgAggregateInputType
    _sum?: Daftar_produkSumAggregateInputType
    _min?: Daftar_produkMinAggregateInputType
    _max?: Daftar_produkMaxAggregateInputType
  }

  export type Daftar_produkGroupByOutputType = {
    id: number
    sku: string
    detail_model_produk_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Daftar_produkCountAggregateOutputType | null
    _avg: Daftar_produkAvgAggregateOutputType | null
    _sum: Daftar_produkSumAggregateOutputType | null
    _min: Daftar_produkMinAggregateOutputType | null
    _max: Daftar_produkMaxAggregateOutputType | null
  }

  type GetDaftar_produkGroupByPayload<T extends daftar_produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Daftar_produkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Daftar_produkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Daftar_produkGroupByOutputType[P]>
            : GetScalarType<T[P], Daftar_produkGroupByOutputType[P]>
        }
      >
    >


  export type daftar_produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    detail_model_produk_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["daftar_produk"]>

  export type daftar_produkSelectScalar = {
    id?: boolean
    sku?: boolean
    detail_model_produk_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type daftar_produkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail_model_produk?: boolean | detail_model_produkDefaultArgs<ExtArgs>
  }


  export type $daftar_produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "daftar_produk"
    objects: {
      detail_model_produk: Prisma.$detail_model_produkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sku: string
      detail_model_produk_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["daftar_produk"]>
    composites: {}
  }


  type daftar_produkGetPayload<S extends boolean | null | undefined | daftar_produkDefaultArgs> = $Result.GetResult<Prisma.$daftar_produkPayload, S>

  type daftar_produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<daftar_produkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Daftar_produkCountAggregateInputType | true
    }

  export interface daftar_produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['daftar_produk'], meta: { name: 'daftar_produk' } }
    /**
     * Find zero or one Daftar_produk that matches the filter.
     * @param {daftar_produkFindUniqueArgs} args - Arguments to find a Daftar_produk
     * @example
     * // Get one Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends daftar_produkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkFindUniqueArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Daftar_produk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {daftar_produkFindUniqueOrThrowArgs} args - Arguments to find a Daftar_produk
     * @example
     * // Get one Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends daftar_produkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Daftar_produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkFindFirstArgs} args - Arguments to find a Daftar_produk
     * @example
     * // Get one Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends daftar_produkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkFindFirstArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Daftar_produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkFindFirstOrThrowArgs} args - Arguments to find a Daftar_produk
     * @example
     * // Get one Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends daftar_produkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Daftar_produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Daftar_produks
     * const daftar_produks = await prisma.daftar_produk.findMany()
     * 
     * // Get first 10 Daftar_produks
     * const daftar_produks = await prisma.daftar_produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const daftar_produkWithIdOnly = await prisma.daftar_produk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends daftar_produkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Daftar_produk.
     * @param {daftar_produkCreateArgs} args - Arguments to create a Daftar_produk.
     * @example
     * // Create one Daftar_produk
     * const Daftar_produk = await prisma.daftar_produk.create({
     *   data: {
     *     // ... data to create a Daftar_produk
     *   }
     * })
     * 
    **/
    create<T extends daftar_produkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkCreateArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Daftar_produks.
     *     @param {daftar_produkCreateManyArgs} args - Arguments to create many Daftar_produks.
     *     @example
     *     // Create many Daftar_produks
     *     const daftar_produk = await prisma.daftar_produk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends daftar_produkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Daftar_produk.
     * @param {daftar_produkDeleteArgs} args - Arguments to delete one Daftar_produk.
     * @example
     * // Delete one Daftar_produk
     * const Daftar_produk = await prisma.daftar_produk.delete({
     *   where: {
     *     // ... filter to delete one Daftar_produk
     *   }
     * })
     * 
    **/
    delete<T extends daftar_produkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkDeleteArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Daftar_produk.
     * @param {daftar_produkUpdateArgs} args - Arguments to update one Daftar_produk.
     * @example
     * // Update one Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends daftar_produkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkUpdateArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Daftar_produks.
     * @param {daftar_produkDeleteManyArgs} args - Arguments to filter Daftar_produks to delete.
     * @example
     * // Delete a few Daftar_produks
     * const { count } = await prisma.daftar_produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends daftar_produkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, daftar_produkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Daftar_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Daftar_produks
     * const daftar_produk = await prisma.daftar_produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends daftar_produkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Daftar_produk.
     * @param {daftar_produkUpsertArgs} args - Arguments to update or create a Daftar_produk.
     * @example
     * // Update or create a Daftar_produk
     * const daftar_produk = await prisma.daftar_produk.upsert({
     *   create: {
     *     // ... data to create a Daftar_produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Daftar_produk we want to update
     *   }
     * })
    **/
    upsert<T extends daftar_produkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, daftar_produkUpsertArgs<ExtArgs>>
    ): Prisma__daftar_produkClient<$Result.GetResult<Prisma.$daftar_produkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Daftar_produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkCountArgs} args - Arguments to filter Daftar_produks to count.
     * @example
     * // Count the number of Daftar_produks
     * const count = await prisma.daftar_produk.count({
     *   where: {
     *     // ... the filter for the Daftar_produks we want to count
     *   }
     * })
    **/
    count<T extends daftar_produkCountArgs>(
      args?: Subset<T, daftar_produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Daftar_produkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Daftar_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Daftar_produkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Daftar_produkAggregateArgs>(args: Subset<T, Daftar_produkAggregateArgs>): Prisma.PrismaPromise<GetDaftar_produkAggregateType<T>>

    /**
     * Group by Daftar_produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daftar_produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends daftar_produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: daftar_produkGroupByArgs['orderBy'] }
        : { orderBy?: daftar_produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, daftar_produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaftar_produkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the daftar_produk model
   */
  readonly fields: daftar_produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for daftar_produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__daftar_produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detail_model_produk<T extends detail_model_produkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, detail_model_produkDefaultArgs<ExtArgs>>): Prisma__detail_model_produkClient<$Result.GetResult<Prisma.$detail_model_produkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the daftar_produk model
   */ 
  interface daftar_produkFieldRefs {
    readonly id: FieldRef<"daftar_produk", 'Int'>
    readonly sku: FieldRef<"daftar_produk", 'String'>
    readonly detail_model_produk_id: FieldRef<"daftar_produk", 'Int'>
    readonly created_at: FieldRef<"daftar_produk", 'DateTime'>
    readonly updated_at: FieldRef<"daftar_produk", 'DateTime'>
    readonly deleted_at: FieldRef<"daftar_produk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * daftar_produk findUnique
   */
  export type daftar_produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter, which daftar_produk to fetch.
     */
    where: daftar_produkWhereUniqueInput
  }


  /**
   * daftar_produk findUniqueOrThrow
   */
  export type daftar_produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter, which daftar_produk to fetch.
     */
    where: daftar_produkWhereUniqueInput
  }


  /**
   * daftar_produk findFirst
   */
  export type daftar_produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter, which daftar_produk to fetch.
     */
    where?: daftar_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_produks to fetch.
     */
    orderBy?: daftar_produkOrderByWithRelationInput | daftar_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daftar_produks.
     */
    cursor?: daftar_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daftar_produks.
     */
    distinct?: Daftar_produkScalarFieldEnum | Daftar_produkScalarFieldEnum[]
  }


  /**
   * daftar_produk findFirstOrThrow
   */
  export type daftar_produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter, which daftar_produk to fetch.
     */
    where?: daftar_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_produks to fetch.
     */
    orderBy?: daftar_produkOrderByWithRelationInput | daftar_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daftar_produks.
     */
    cursor?: daftar_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daftar_produks.
     */
    distinct?: Daftar_produkScalarFieldEnum | Daftar_produkScalarFieldEnum[]
  }


  /**
   * daftar_produk findMany
   */
  export type daftar_produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter, which daftar_produks to fetch.
     */
    where?: daftar_produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daftar_produks to fetch.
     */
    orderBy?: daftar_produkOrderByWithRelationInput | daftar_produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing daftar_produks.
     */
    cursor?: daftar_produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daftar_produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daftar_produks.
     */
    skip?: number
    distinct?: Daftar_produkScalarFieldEnum | Daftar_produkScalarFieldEnum[]
  }


  /**
   * daftar_produk create
   */
  export type daftar_produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * The data needed to create a daftar_produk.
     */
    data: XOR<daftar_produkCreateInput, daftar_produkUncheckedCreateInput>
  }


  /**
   * daftar_produk createMany
   */
  export type daftar_produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many daftar_produks.
     */
    data: daftar_produkCreateManyInput | daftar_produkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * daftar_produk update
   */
  export type daftar_produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * The data needed to update a daftar_produk.
     */
    data: XOR<daftar_produkUpdateInput, daftar_produkUncheckedUpdateInput>
    /**
     * Choose, which daftar_produk to update.
     */
    where: daftar_produkWhereUniqueInput
  }


  /**
   * daftar_produk updateMany
   */
  export type daftar_produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update daftar_produks.
     */
    data: XOR<daftar_produkUpdateManyMutationInput, daftar_produkUncheckedUpdateManyInput>
    /**
     * Filter which daftar_produks to update
     */
    where?: daftar_produkWhereInput
  }


  /**
   * daftar_produk upsert
   */
  export type daftar_produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * The filter to search for the daftar_produk to update in case it exists.
     */
    where: daftar_produkWhereUniqueInput
    /**
     * In case the daftar_produk found by the `where` argument doesn't exist, create a new daftar_produk with this data.
     */
    create: XOR<daftar_produkCreateInput, daftar_produkUncheckedCreateInput>
    /**
     * In case the daftar_produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<daftar_produkUpdateInput, daftar_produkUncheckedUpdateInput>
  }


  /**
   * daftar_produk delete
   */
  export type daftar_produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
    /**
     * Filter which daftar_produk to delete.
     */
    where: daftar_produkWhereUniqueInput
  }


  /**
   * daftar_produk deleteMany
   */
  export type daftar_produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daftar_produks to delete
     */
    where?: daftar_produkWhereInput
  }


  /**
   * daftar_produk without action
   */
  export type daftar_produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daftar_produk
     */
    select?: daftar_produkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: daftar_produkInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    karyawan_id: 'karyawan_id',
    role_id: 'role_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const KaryawanScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    nik: 'nik',
    alamat: 'alamat',
    kontak: 'kontak',
    tanggal_lahir: 'tanggal_lahir',
    jenis_kelamin: 'jenis_kelamin',
    no_rekening: 'no_rekening',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type KaryawanScalarFieldEnum = (typeof KaryawanScalarFieldEnum)[keyof typeof KaryawanScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const AksesScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type AksesScalarFieldEnum = (typeof AksesScalarFieldEnum)[keyof typeof AksesScalarFieldEnum]


  export const FungsiScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type FungsiScalarFieldEnum = (typeof FungsiScalarFieldEnum)[keyof typeof FungsiScalarFieldEnum]


  export const Hak_aksesScalarFieldEnum: {
    id: 'id',
    role_id: 'role_id',
    fungsi_id: 'fungsi_id',
    akses_id: 'akses_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Hak_aksesScalarFieldEnum = (typeof Hak_aksesScalarFieldEnum)[keyof typeof Hak_aksesScalarFieldEnum]


  export const Model_produkScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    nama: 'nama',
    variasi: 'variasi',
    deskripsi: 'deskripsi',
    deleted_at: 'deleted_at',
    kategori_id: 'kategori_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Model_produkScalarFieldEnum = (typeof Model_produkScalarFieldEnum)[keyof typeof Model_produkScalarFieldEnum]


  export const Foto_produkScalarFieldEnum: {
    id: 'id',
    filepath: 'filepath',
    model_produk_id: 'model_produk_id'
  };

  export type Foto_produkScalarFieldEnum = (typeof Foto_produkScalarFieldEnum)[keyof typeof Foto_produkScalarFieldEnum]


  export const Kategori_produkScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    tipe: 'tipe',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Kategori_produkScalarFieldEnum = (typeof Kategori_produkScalarFieldEnum)[keyof typeof Kategori_produkScalarFieldEnum]


  export const Detail_model_produkScalarFieldEnum: {
    id: 'id',
    ukuran: 'ukuran',
    biaya_jahit: 'biaya_jahit',
    hpp: 'hpp',
    harga_jual: 'harga_jual',
    deleted_at: 'deleted_at',
    model_produk_id: 'model_produk_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Detail_model_produkScalarFieldEnum = (typeof Detail_model_produkScalarFieldEnum)[keyof typeof Detail_model_produkScalarFieldEnum]


  export const Bahan_produkScalarFieldEnum: {
    id: 'id',
    jumlah: 'jumlah',
    detail_model_produk_id: 'detail_model_produk_id',
    daftar_bahan_id: 'daftar_bahan_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Bahan_produkScalarFieldEnum = (typeof Bahan_produkScalarFieldEnum)[keyof typeof Bahan_produkScalarFieldEnum]


  export const Daftar_bahanScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    stok: 'stok',
    nama: 'nama',
    satuan: 'satuan',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Daftar_bahanScalarFieldEnum = (typeof Daftar_bahanScalarFieldEnum)[keyof typeof Daftar_bahanScalarFieldEnum]


  export const Restok_bahanScalarFieldEnum: {
    id: 'id',
    tanggal_pesan: 'tanggal_pesan',
    tanggal_terima: 'tanggal_terima',
    harga_satuan: 'harga_satuan',
    jumlah: 'jumlah',
    daftar_bahan_id: 'daftar_bahan_id',
    supplier_id: 'supplier_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Restok_bahanScalarFieldEnum = (typeof Restok_bahanScalarFieldEnum)[keyof typeof Restok_bahanScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    nama: 'nama',
    alamat: 'alamat',
    kontak: 'kontak',
    no_rek: 'no_rek',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ProduksiScalarFieldEnum: {
    id: 'id',
    produksi: 'produksi',
    tanggal_mulai: 'tanggal_mulai',
    tanggal_selesai: 'tanggal_selesai',
    jumlah: 'jumlah',
    detail_model_produk_id: 'detail_model_produk_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ProduksiScalarFieldEnum = (typeof ProduksiScalarFieldEnum)[keyof typeof ProduksiScalarFieldEnum]


  export const QcproduksiScalarFieldEnum: {
    id: 'id',
    waktu: 'waktu',
    deskripsi: 'deskripsi',
    status: 'status',
    user_id: 'user_id',
    produksi_id: 'produksi_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type QcproduksiScalarFieldEnum = (typeof QcproduksiScalarFieldEnum)[keyof typeof QcproduksiScalarFieldEnum]


  export const Daftar_produkScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    detail_model_produk_id: 'detail_model_produk_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Daftar_produkScalarFieldEnum = (typeof Daftar_produkScalarFieldEnum)[keyof typeof Daftar_produkScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    karyawan_id?: IntFilter<"user"> | number
    role_id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    karyawan?: XOR<KaryawanRelationFilter, karyawanWhereInput>
    role?: XOR<RoleRelationFilter, roleWhereInput>
    produksi?: ProduksiListRelationFilter
    qcproduksi?: QcproduksiListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    karyawan?: karyawanOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
    produksi?: produksiOrderByRelationAggregateInput
    qcproduksi?: qcproduksiOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    karyawan_id?: IntFilter<"user"> | number
    role_id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    karyawan?: XOR<KaryawanRelationFilter, karyawanWhereInput>
    role?: XOR<RoleRelationFilter, roleWhereInput>
    produksi?: ProduksiListRelationFilter
    qcproduksi?: QcproduksiListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    karyawan_id?: IntWithAggregatesFilter<"user"> | number
    role_id?: IntWithAggregatesFilter<"user"> | number
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type karyawanWhereInput = {
    AND?: karyawanWhereInput | karyawanWhereInput[]
    OR?: karyawanWhereInput[]
    NOT?: karyawanWhereInput | karyawanWhereInput[]
    id?: IntFilter<"karyawan"> | number
    nama?: StringFilter<"karyawan"> | string
    nik?: StringFilter<"karyawan"> | string
    alamat?: StringFilter<"karyawan"> | string
    kontak?: StringFilter<"karyawan"> | string
    tanggal_lahir?: DateTimeFilter<"karyawan"> | Date | string
    jenis_kelamin?: StringFilter<"karyawan"> | string
    no_rekening?: StringFilter<"karyawan"> | string
    created_at?: DateTimeFilter<"karyawan"> | Date | string
    updated_at?: DateTimeFilter<"karyawan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"karyawan"> | Date | string | null
    users?: UserListRelationFilter
  }

  export type karyawanOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    tanggal_lahir?: SortOrder
    jenis_kelamin?: SortOrder
    no_rekening?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: userOrderByRelationAggregateInput
  }

  export type karyawanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nik?: string
    AND?: karyawanWhereInput | karyawanWhereInput[]
    OR?: karyawanWhereInput[]
    NOT?: karyawanWhereInput | karyawanWhereInput[]
    nama?: StringFilter<"karyawan"> | string
    alamat?: StringFilter<"karyawan"> | string
    kontak?: StringFilter<"karyawan"> | string
    tanggal_lahir?: DateTimeFilter<"karyawan"> | Date | string
    jenis_kelamin?: StringFilter<"karyawan"> | string
    no_rekening?: StringFilter<"karyawan"> | string
    created_at?: DateTimeFilter<"karyawan"> | Date | string
    updated_at?: DateTimeFilter<"karyawan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"karyawan"> | Date | string | null
    users?: UserListRelationFilter
  }, "id" | "nik">

  export type karyawanOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    tanggal_lahir?: SortOrder
    jenis_kelamin?: SortOrder
    no_rekening?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: karyawanCountOrderByAggregateInput
    _avg?: karyawanAvgOrderByAggregateInput
    _max?: karyawanMaxOrderByAggregateInput
    _min?: karyawanMinOrderByAggregateInput
    _sum?: karyawanSumOrderByAggregateInput
  }

  export type karyawanScalarWhereWithAggregatesInput = {
    AND?: karyawanScalarWhereWithAggregatesInput | karyawanScalarWhereWithAggregatesInput[]
    OR?: karyawanScalarWhereWithAggregatesInput[]
    NOT?: karyawanScalarWhereWithAggregatesInput | karyawanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"karyawan"> | number
    nama?: StringWithAggregatesFilter<"karyawan"> | string
    nik?: StringWithAggregatesFilter<"karyawan"> | string
    alamat?: StringWithAggregatesFilter<"karyawan"> | string
    kontak?: StringWithAggregatesFilter<"karyawan"> | string
    tanggal_lahir?: DateTimeWithAggregatesFilter<"karyawan"> | Date | string
    jenis_kelamin?: StringWithAggregatesFilter<"karyawan"> | string
    no_rekening?: StringWithAggregatesFilter<"karyawan"> | string
    created_at?: DateTimeWithAggregatesFilter<"karyawan"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"karyawan"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"karyawan"> | Date | string | null
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: IntFilter<"role"> | number
    nama?: StringFilter<"role"> | string
    created_at?: DateTimeFilter<"role"> | Date | string
    updated_at?: DateTimeFilter<"role"> | Date | string
    deleted_at?: DateTimeNullableFilter<"role"> | Date | string | null
    users?: UserListRelationFilter
    hak_akses?: Hak_aksesListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: userOrderByRelationAggregateInput
    hak_akses?: hak_aksesOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    nama?: StringFilter<"role"> | string
    created_at?: DateTimeFilter<"role"> | Date | string
    updated_at?: DateTimeFilter<"role"> | Date | string
    deleted_at?: DateTimeNullableFilter<"role"> | Date | string | null
    users?: UserListRelationFilter
    hak_akses?: Hak_aksesListRelationFilter
  }, "id">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role"> | number
    nama?: StringWithAggregatesFilter<"role"> | string
    created_at?: DateTimeWithAggregatesFilter<"role"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"role"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"role"> | Date | string | null
  }

  export type aksesWhereInput = {
    AND?: aksesWhereInput | aksesWhereInput[]
    OR?: aksesWhereInput[]
    NOT?: aksesWhereInput | aksesWhereInput[]
    id?: IntFilter<"akses"> | number
    nama?: StringFilter<"akses"> | string
    created_at?: DateTimeFilter<"akses"> | Date | string
    updated_at?: DateTimeFilter<"akses"> | Date | string
    deleted_at?: DateTimeNullableFilter<"akses"> | Date | string | null
    hak_akses?: Hak_aksesListRelationFilter
  }

  export type aksesOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    hak_akses?: hak_aksesOrderByRelationAggregateInput
  }

  export type aksesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: aksesWhereInput | aksesWhereInput[]
    OR?: aksesWhereInput[]
    NOT?: aksesWhereInput | aksesWhereInput[]
    nama?: StringFilter<"akses"> | string
    created_at?: DateTimeFilter<"akses"> | Date | string
    updated_at?: DateTimeFilter<"akses"> | Date | string
    deleted_at?: DateTimeNullableFilter<"akses"> | Date | string | null
    hak_akses?: Hak_aksesListRelationFilter
  }, "id">

  export type aksesOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: aksesCountOrderByAggregateInput
    _avg?: aksesAvgOrderByAggregateInput
    _max?: aksesMaxOrderByAggregateInput
    _min?: aksesMinOrderByAggregateInput
    _sum?: aksesSumOrderByAggregateInput
  }

  export type aksesScalarWhereWithAggregatesInput = {
    AND?: aksesScalarWhereWithAggregatesInput | aksesScalarWhereWithAggregatesInput[]
    OR?: aksesScalarWhereWithAggregatesInput[]
    NOT?: aksesScalarWhereWithAggregatesInput | aksesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"akses"> | number
    nama?: StringWithAggregatesFilter<"akses"> | string
    created_at?: DateTimeWithAggregatesFilter<"akses"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"akses"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"akses"> | Date | string | null
  }

  export type fungsiWhereInput = {
    AND?: fungsiWhereInput | fungsiWhereInput[]
    OR?: fungsiWhereInput[]
    NOT?: fungsiWhereInput | fungsiWhereInput[]
    id?: IntFilter<"fungsi"> | number
    nama?: StringFilter<"fungsi"> | string
    created_at?: DateTimeFilter<"fungsi"> | Date | string
    updated_at?: DateTimeFilter<"fungsi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"fungsi"> | Date | string | null
    hak_akses?: Hak_aksesListRelationFilter
  }

  export type fungsiOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    hak_akses?: hak_aksesOrderByRelationAggregateInput
  }

  export type fungsiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fungsiWhereInput | fungsiWhereInput[]
    OR?: fungsiWhereInput[]
    NOT?: fungsiWhereInput | fungsiWhereInput[]
    nama?: StringFilter<"fungsi"> | string
    created_at?: DateTimeFilter<"fungsi"> | Date | string
    updated_at?: DateTimeFilter<"fungsi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"fungsi"> | Date | string | null
    hak_akses?: Hak_aksesListRelationFilter
  }, "id">

  export type fungsiOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: fungsiCountOrderByAggregateInput
    _avg?: fungsiAvgOrderByAggregateInput
    _max?: fungsiMaxOrderByAggregateInput
    _min?: fungsiMinOrderByAggregateInput
    _sum?: fungsiSumOrderByAggregateInput
  }

  export type fungsiScalarWhereWithAggregatesInput = {
    AND?: fungsiScalarWhereWithAggregatesInput | fungsiScalarWhereWithAggregatesInput[]
    OR?: fungsiScalarWhereWithAggregatesInput[]
    NOT?: fungsiScalarWhereWithAggregatesInput | fungsiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fungsi"> | number
    nama?: StringWithAggregatesFilter<"fungsi"> | string
    created_at?: DateTimeWithAggregatesFilter<"fungsi"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"fungsi"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"fungsi"> | Date | string | null
  }

  export type hak_aksesWhereInput = {
    AND?: hak_aksesWhereInput | hak_aksesWhereInput[]
    OR?: hak_aksesWhereInput[]
    NOT?: hak_aksesWhereInput | hak_aksesWhereInput[]
    id?: IntFilter<"hak_akses"> | number
    role_id?: IntFilter<"hak_akses"> | number
    fungsi_id?: IntFilter<"hak_akses"> | number
    akses_id?: IntFilter<"hak_akses"> | number
    created_at?: DateTimeFilter<"hak_akses"> | Date | string
    updated_at?: DateTimeFilter<"hak_akses"> | Date | string
    deleted_at?: DateTimeNullableFilter<"hak_akses"> | Date | string | null
    role?: XOR<RoleRelationFilter, roleWhereInput>
    fungsi?: XOR<FungsiRelationFilter, fungsiWhereInput>
    akses?: XOR<AksesRelationFilter, aksesWhereInput>
  }

  export type hak_aksesOrderByWithRelationInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    role?: roleOrderByWithRelationInput
    fungsi?: fungsiOrderByWithRelationInput
    akses?: aksesOrderByWithRelationInput
  }

  export type hak_aksesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    HakAksesConstraint?: hak_aksesHakAksesConstraintCompoundUniqueInput
    AND?: hak_aksesWhereInput | hak_aksesWhereInput[]
    OR?: hak_aksesWhereInput[]
    NOT?: hak_aksesWhereInput | hak_aksesWhereInput[]
    role_id?: IntFilter<"hak_akses"> | number
    fungsi_id?: IntFilter<"hak_akses"> | number
    akses_id?: IntFilter<"hak_akses"> | number
    created_at?: DateTimeFilter<"hak_akses"> | Date | string
    updated_at?: DateTimeFilter<"hak_akses"> | Date | string
    deleted_at?: DateTimeNullableFilter<"hak_akses"> | Date | string | null
    role?: XOR<RoleRelationFilter, roleWhereInput>
    fungsi?: XOR<FungsiRelationFilter, fungsiWhereInput>
    akses?: XOR<AksesRelationFilter, aksesWhereInput>
  }, "id" | "HakAksesConstraint">

  export type hak_aksesOrderByWithAggregationInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: hak_aksesCountOrderByAggregateInput
    _avg?: hak_aksesAvgOrderByAggregateInput
    _max?: hak_aksesMaxOrderByAggregateInput
    _min?: hak_aksesMinOrderByAggregateInput
    _sum?: hak_aksesSumOrderByAggregateInput
  }

  export type hak_aksesScalarWhereWithAggregatesInput = {
    AND?: hak_aksesScalarWhereWithAggregatesInput | hak_aksesScalarWhereWithAggregatesInput[]
    OR?: hak_aksesScalarWhereWithAggregatesInput[]
    NOT?: hak_aksesScalarWhereWithAggregatesInput | hak_aksesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"hak_akses"> | number
    role_id?: IntWithAggregatesFilter<"hak_akses"> | number
    fungsi_id?: IntWithAggregatesFilter<"hak_akses"> | number
    akses_id?: IntWithAggregatesFilter<"hak_akses"> | number
    created_at?: DateTimeWithAggregatesFilter<"hak_akses"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"hak_akses"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hak_akses"> | Date | string | null
  }

  export type model_produkWhereInput = {
    AND?: model_produkWhereInput | model_produkWhereInput[]
    OR?: model_produkWhereInput[]
    NOT?: model_produkWhereInput | model_produkWhereInput[]
    id?: IntFilter<"model_produk"> | number
    kode?: StringFilter<"model_produk"> | string
    nama?: StringFilter<"model_produk"> | string
    variasi?: StringFilter<"model_produk"> | string
    deskripsi?: StringNullableFilter<"model_produk"> | string | null
    deleted_at?: DateTimeNullableFilter<"model_produk"> | Date | string | null
    kategori_id?: IntFilter<"model_produk"> | number
    created_at?: DateTimeFilter<"model_produk"> | Date | string
    updated_at?: DateTimeFilter<"model_produk"> | Date | string
    kategori?: XOR<Kategori_produkRelationFilter, kategori_produkWhereInput>
    foto_produk?: Foto_produkListRelationFilter
    detail_model_produk?: Detail_model_produkListRelationFilter
  }

  export type model_produkOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    variasi?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    kategori_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    kategori?: kategori_produkOrderByWithRelationInput
    foto_produk?: foto_produkOrderByRelationAggregateInput
    detail_model_produk?: detail_model_produkOrderByRelationAggregateInput
  }

  export type model_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: model_produkWhereInput | model_produkWhereInput[]
    OR?: model_produkWhereInput[]
    NOT?: model_produkWhereInput | model_produkWhereInput[]
    kode?: StringFilter<"model_produk"> | string
    nama?: StringFilter<"model_produk"> | string
    variasi?: StringFilter<"model_produk"> | string
    deskripsi?: StringNullableFilter<"model_produk"> | string | null
    deleted_at?: DateTimeNullableFilter<"model_produk"> | Date | string | null
    kategori_id?: IntFilter<"model_produk"> | number
    created_at?: DateTimeFilter<"model_produk"> | Date | string
    updated_at?: DateTimeFilter<"model_produk"> | Date | string
    kategori?: XOR<Kategori_produkRelationFilter, kategori_produkWhereInput>
    foto_produk?: Foto_produkListRelationFilter
    detail_model_produk?: Detail_model_produkListRelationFilter
  }, "id">

  export type model_produkOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    variasi?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    kategori_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: model_produkCountOrderByAggregateInput
    _avg?: model_produkAvgOrderByAggregateInput
    _max?: model_produkMaxOrderByAggregateInput
    _min?: model_produkMinOrderByAggregateInput
    _sum?: model_produkSumOrderByAggregateInput
  }

  export type model_produkScalarWhereWithAggregatesInput = {
    AND?: model_produkScalarWhereWithAggregatesInput | model_produkScalarWhereWithAggregatesInput[]
    OR?: model_produkScalarWhereWithAggregatesInput[]
    NOT?: model_produkScalarWhereWithAggregatesInput | model_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"model_produk"> | number
    kode?: StringWithAggregatesFilter<"model_produk"> | string
    nama?: StringWithAggregatesFilter<"model_produk"> | string
    variasi?: StringWithAggregatesFilter<"model_produk"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"model_produk"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"model_produk"> | Date | string | null
    kategori_id?: IntWithAggregatesFilter<"model_produk"> | number
    created_at?: DateTimeWithAggregatesFilter<"model_produk"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"model_produk"> | Date | string
  }

  export type foto_produkWhereInput = {
    AND?: foto_produkWhereInput | foto_produkWhereInput[]
    OR?: foto_produkWhereInput[]
    NOT?: foto_produkWhereInput | foto_produkWhereInput[]
    id?: IntFilter<"foto_produk"> | number
    filepath?: StringFilter<"foto_produk"> | string
    model_produk_id?: IntFilter<"foto_produk"> | number
    model_produk?: XOR<Model_produkRelationFilter, model_produkWhereInput>
  }

  export type foto_produkOrderByWithRelationInput = {
    id?: SortOrder
    filepath?: SortOrder
    model_produk_id?: SortOrder
    model_produk?: model_produkOrderByWithRelationInput
  }

  export type foto_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: foto_produkWhereInput | foto_produkWhereInput[]
    OR?: foto_produkWhereInput[]
    NOT?: foto_produkWhereInput | foto_produkWhereInput[]
    filepath?: StringFilter<"foto_produk"> | string
    model_produk_id?: IntFilter<"foto_produk"> | number
    model_produk?: XOR<Model_produkRelationFilter, model_produkWhereInput>
  }, "id">

  export type foto_produkOrderByWithAggregationInput = {
    id?: SortOrder
    filepath?: SortOrder
    model_produk_id?: SortOrder
    _count?: foto_produkCountOrderByAggregateInput
    _avg?: foto_produkAvgOrderByAggregateInput
    _max?: foto_produkMaxOrderByAggregateInput
    _min?: foto_produkMinOrderByAggregateInput
    _sum?: foto_produkSumOrderByAggregateInput
  }

  export type foto_produkScalarWhereWithAggregatesInput = {
    AND?: foto_produkScalarWhereWithAggregatesInput | foto_produkScalarWhereWithAggregatesInput[]
    OR?: foto_produkScalarWhereWithAggregatesInput[]
    NOT?: foto_produkScalarWhereWithAggregatesInput | foto_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"foto_produk"> | number
    filepath?: StringWithAggregatesFilter<"foto_produk"> | string
    model_produk_id?: IntWithAggregatesFilter<"foto_produk"> | number
  }

  export type kategori_produkWhereInput = {
    AND?: kategori_produkWhereInput | kategori_produkWhereInput[]
    OR?: kategori_produkWhereInput[]
    NOT?: kategori_produkWhereInput | kategori_produkWhereInput[]
    id?: IntFilter<"kategori_produk"> | number
    nama?: StringFilter<"kategori_produk"> | string
    tipe?: StringFilter<"kategori_produk"> | string
    deleted_at?: DateTimeNullableFilter<"kategori_produk"> | Date | string | null
    created_at?: DateTimeFilter<"kategori_produk"> | Date | string
    updated_at?: DateTimeFilter<"kategori_produk"> | Date | string
    model_produk?: Model_produkListRelationFilter
  }

  export type kategori_produkOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    model_produk?: model_produkOrderByRelationAggregateInput
  }

  export type kategori_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kategori_produkWhereInput | kategori_produkWhereInput[]
    OR?: kategori_produkWhereInput[]
    NOT?: kategori_produkWhereInput | kategori_produkWhereInput[]
    nama?: StringFilter<"kategori_produk"> | string
    tipe?: StringFilter<"kategori_produk"> | string
    deleted_at?: DateTimeNullableFilter<"kategori_produk"> | Date | string | null
    created_at?: DateTimeFilter<"kategori_produk"> | Date | string
    updated_at?: DateTimeFilter<"kategori_produk"> | Date | string
    model_produk?: Model_produkListRelationFilter
  }, "id">

  export type kategori_produkOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: kategori_produkCountOrderByAggregateInput
    _avg?: kategori_produkAvgOrderByAggregateInput
    _max?: kategori_produkMaxOrderByAggregateInput
    _min?: kategori_produkMinOrderByAggregateInput
    _sum?: kategori_produkSumOrderByAggregateInput
  }

  export type kategori_produkScalarWhereWithAggregatesInput = {
    AND?: kategori_produkScalarWhereWithAggregatesInput | kategori_produkScalarWhereWithAggregatesInput[]
    OR?: kategori_produkScalarWhereWithAggregatesInput[]
    NOT?: kategori_produkScalarWhereWithAggregatesInput | kategori_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kategori_produk"> | number
    nama?: StringWithAggregatesFilter<"kategori_produk"> | string
    tipe?: StringWithAggregatesFilter<"kategori_produk"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"kategori_produk"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"kategori_produk"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"kategori_produk"> | Date | string
  }

  export type detail_model_produkWhereInput = {
    AND?: detail_model_produkWhereInput | detail_model_produkWhereInput[]
    OR?: detail_model_produkWhereInput[]
    NOT?: detail_model_produkWhereInput | detail_model_produkWhereInput[]
    id?: IntFilter<"detail_model_produk"> | number
    ukuran?: StringFilter<"detail_model_produk"> | string
    biaya_jahit?: FloatFilter<"detail_model_produk"> | number
    hpp?: FloatFilter<"detail_model_produk"> | number
    harga_jual?: FloatFilter<"detail_model_produk"> | number
    deleted_at?: DateTimeNullableFilter<"detail_model_produk"> | Date | string | null
    model_produk_id?: IntFilter<"detail_model_produk"> | number
    created_at?: DateTimeFilter<"detail_model_produk"> | Date | string
    updated_at?: DateTimeFilter<"detail_model_produk"> | Date | string
    model_produk?: XOR<Model_produkRelationFilter, model_produkWhereInput>
    bahan_produk?: Bahan_produkListRelationFilter
    daftar_produk?: Daftar_produkListRelationFilter
    produksi?: ProduksiListRelationFilter
  }

  export type detail_model_produkOrderByWithRelationInput = {
    id?: SortOrder
    ukuran?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    model_produk?: model_produkOrderByWithRelationInput
    bahan_produk?: bahan_produkOrderByRelationAggregateInput
    daftar_produk?: daftar_produkOrderByRelationAggregateInput
    produksi?: produksiOrderByRelationAggregateInput
  }

  export type detail_model_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detail_model_produkWhereInput | detail_model_produkWhereInput[]
    OR?: detail_model_produkWhereInput[]
    NOT?: detail_model_produkWhereInput | detail_model_produkWhereInput[]
    ukuran?: StringFilter<"detail_model_produk"> | string
    biaya_jahit?: FloatFilter<"detail_model_produk"> | number
    hpp?: FloatFilter<"detail_model_produk"> | number
    harga_jual?: FloatFilter<"detail_model_produk"> | number
    deleted_at?: DateTimeNullableFilter<"detail_model_produk"> | Date | string | null
    model_produk_id?: IntFilter<"detail_model_produk"> | number
    created_at?: DateTimeFilter<"detail_model_produk"> | Date | string
    updated_at?: DateTimeFilter<"detail_model_produk"> | Date | string
    model_produk?: XOR<Model_produkRelationFilter, model_produkWhereInput>
    bahan_produk?: Bahan_produkListRelationFilter
    daftar_produk?: Daftar_produkListRelationFilter
    produksi?: ProduksiListRelationFilter
  }, "id">

  export type detail_model_produkOrderByWithAggregationInput = {
    id?: SortOrder
    ukuran?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: detail_model_produkCountOrderByAggregateInput
    _avg?: detail_model_produkAvgOrderByAggregateInput
    _max?: detail_model_produkMaxOrderByAggregateInput
    _min?: detail_model_produkMinOrderByAggregateInput
    _sum?: detail_model_produkSumOrderByAggregateInput
  }

  export type detail_model_produkScalarWhereWithAggregatesInput = {
    AND?: detail_model_produkScalarWhereWithAggregatesInput | detail_model_produkScalarWhereWithAggregatesInput[]
    OR?: detail_model_produkScalarWhereWithAggregatesInput[]
    NOT?: detail_model_produkScalarWhereWithAggregatesInput | detail_model_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detail_model_produk"> | number
    ukuran?: StringWithAggregatesFilter<"detail_model_produk"> | string
    biaya_jahit?: FloatWithAggregatesFilter<"detail_model_produk"> | number
    hpp?: FloatWithAggregatesFilter<"detail_model_produk"> | number
    harga_jual?: FloatWithAggregatesFilter<"detail_model_produk"> | number
    deleted_at?: DateTimeNullableWithAggregatesFilter<"detail_model_produk"> | Date | string | null
    model_produk_id?: IntWithAggregatesFilter<"detail_model_produk"> | number
    created_at?: DateTimeWithAggregatesFilter<"detail_model_produk"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"detail_model_produk"> | Date | string
  }

  export type bahan_produkWhereInput = {
    AND?: bahan_produkWhereInput | bahan_produkWhereInput[]
    OR?: bahan_produkWhereInput[]
    NOT?: bahan_produkWhereInput | bahan_produkWhereInput[]
    id?: IntFilter<"bahan_produk"> | number
    jumlah?: FloatFilter<"bahan_produk"> | number
    detail_model_produk_id?: IntFilter<"bahan_produk"> | number
    daftar_bahan_id?: IntFilter<"bahan_produk"> | number
    created_at?: DateTimeFilter<"bahan_produk"> | Date | string
    updated_at?: DateTimeFilter<"bahan_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"bahan_produk"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
    daftar_bahan?: XOR<Daftar_bahanRelationFilter, daftar_bahanWhereInput>
  }

  export type bahan_produkOrderByWithRelationInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    detail_model_produk?: detail_model_produkOrderByWithRelationInput
    daftar_bahan?: daftar_bahanOrderByWithRelationInput
  }

  export type bahan_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bahan_produkWhereInput | bahan_produkWhereInput[]
    OR?: bahan_produkWhereInput[]
    NOT?: bahan_produkWhereInput | bahan_produkWhereInput[]
    jumlah?: FloatFilter<"bahan_produk"> | number
    detail_model_produk_id?: IntFilter<"bahan_produk"> | number
    daftar_bahan_id?: IntFilter<"bahan_produk"> | number
    created_at?: DateTimeFilter<"bahan_produk"> | Date | string
    updated_at?: DateTimeFilter<"bahan_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"bahan_produk"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
    daftar_bahan?: XOR<Daftar_bahanRelationFilter, daftar_bahanWhereInput>
  }, "id">

  export type bahan_produkOrderByWithAggregationInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: bahan_produkCountOrderByAggregateInput
    _avg?: bahan_produkAvgOrderByAggregateInput
    _max?: bahan_produkMaxOrderByAggregateInput
    _min?: bahan_produkMinOrderByAggregateInput
    _sum?: bahan_produkSumOrderByAggregateInput
  }

  export type bahan_produkScalarWhereWithAggregatesInput = {
    AND?: bahan_produkScalarWhereWithAggregatesInput | bahan_produkScalarWhereWithAggregatesInput[]
    OR?: bahan_produkScalarWhereWithAggregatesInput[]
    NOT?: bahan_produkScalarWhereWithAggregatesInput | bahan_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bahan_produk"> | number
    jumlah?: FloatWithAggregatesFilter<"bahan_produk"> | number
    detail_model_produk_id?: IntWithAggregatesFilter<"bahan_produk"> | number
    daftar_bahan_id?: IntWithAggregatesFilter<"bahan_produk"> | number
    created_at?: DateTimeWithAggregatesFilter<"bahan_produk"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"bahan_produk"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"bahan_produk"> | Date | string | null
  }

  export type daftar_bahanWhereInput = {
    AND?: daftar_bahanWhereInput | daftar_bahanWhereInput[]
    OR?: daftar_bahanWhereInput[]
    NOT?: daftar_bahanWhereInput | daftar_bahanWhereInput[]
    id?: IntFilter<"daftar_bahan"> | number
    kode?: StringFilter<"daftar_bahan"> | string
    stok?: FloatFilter<"daftar_bahan"> | number
    nama?: StringFilter<"daftar_bahan"> | string
    satuan?: StringFilter<"daftar_bahan"> | string
    created_at?: DateTimeFilter<"daftar_bahan"> | Date | string
    updated_at?: DateTimeFilter<"daftar_bahan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"daftar_bahan"> | Date | string | null
    bahan_produk?: Bahan_produkListRelationFilter
    restok_bahan?: Restok_bahanListRelationFilter
  }

  export type daftar_bahanOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    stok?: SortOrder
    nama?: SortOrder
    satuan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    bahan_produk?: bahan_produkOrderByRelationAggregateInput
    restok_bahan?: restok_bahanOrderByRelationAggregateInput
  }

  export type daftar_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: daftar_bahanWhereInput | daftar_bahanWhereInput[]
    OR?: daftar_bahanWhereInput[]
    NOT?: daftar_bahanWhereInput | daftar_bahanWhereInput[]
    kode?: StringFilter<"daftar_bahan"> | string
    stok?: FloatFilter<"daftar_bahan"> | number
    nama?: StringFilter<"daftar_bahan"> | string
    satuan?: StringFilter<"daftar_bahan"> | string
    created_at?: DateTimeFilter<"daftar_bahan"> | Date | string
    updated_at?: DateTimeFilter<"daftar_bahan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"daftar_bahan"> | Date | string | null
    bahan_produk?: Bahan_produkListRelationFilter
    restok_bahan?: Restok_bahanListRelationFilter
  }, "id">

  export type daftar_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    stok?: SortOrder
    nama?: SortOrder
    satuan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: daftar_bahanCountOrderByAggregateInput
    _avg?: daftar_bahanAvgOrderByAggregateInput
    _max?: daftar_bahanMaxOrderByAggregateInput
    _min?: daftar_bahanMinOrderByAggregateInput
    _sum?: daftar_bahanSumOrderByAggregateInput
  }

  export type daftar_bahanScalarWhereWithAggregatesInput = {
    AND?: daftar_bahanScalarWhereWithAggregatesInput | daftar_bahanScalarWhereWithAggregatesInput[]
    OR?: daftar_bahanScalarWhereWithAggregatesInput[]
    NOT?: daftar_bahanScalarWhereWithAggregatesInput | daftar_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"daftar_bahan"> | number
    kode?: StringWithAggregatesFilter<"daftar_bahan"> | string
    stok?: FloatWithAggregatesFilter<"daftar_bahan"> | number
    nama?: StringWithAggregatesFilter<"daftar_bahan"> | string
    satuan?: StringWithAggregatesFilter<"daftar_bahan"> | string
    created_at?: DateTimeWithAggregatesFilter<"daftar_bahan"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"daftar_bahan"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"daftar_bahan"> | Date | string | null
  }

  export type restok_bahanWhereInput = {
    AND?: restok_bahanWhereInput | restok_bahanWhereInput[]
    OR?: restok_bahanWhereInput[]
    NOT?: restok_bahanWhereInput | restok_bahanWhereInput[]
    id?: IntFilter<"restok_bahan"> | number
    tanggal_pesan?: DateTimeFilter<"restok_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"restok_bahan"> | Date | string
    harga_satuan?: FloatFilter<"restok_bahan"> | number
    jumlah?: FloatFilter<"restok_bahan"> | number
    daftar_bahan_id?: IntFilter<"restok_bahan"> | number
    supplier_id?: IntFilter<"restok_bahan"> | number
    created_at?: DateTimeFilter<"restok_bahan"> | Date | string
    updated_at?: DateTimeFilter<"restok_bahan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"restok_bahan"> | Date | string | null
    daftar_bahan?: XOR<Daftar_bahanRelationFilter, daftar_bahanWhereInput>
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }

  export type restok_bahanOrderByWithRelationInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    daftar_bahan?: daftar_bahanOrderByWithRelationInput
    supplier?: supplierOrderByWithRelationInput
  }

  export type restok_bahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: restok_bahanWhereInput | restok_bahanWhereInput[]
    OR?: restok_bahanWhereInput[]
    NOT?: restok_bahanWhereInput | restok_bahanWhereInput[]
    tanggal_pesan?: DateTimeFilter<"restok_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"restok_bahan"> | Date | string
    harga_satuan?: FloatFilter<"restok_bahan"> | number
    jumlah?: FloatFilter<"restok_bahan"> | number
    daftar_bahan_id?: IntFilter<"restok_bahan"> | number
    supplier_id?: IntFilter<"restok_bahan"> | number
    created_at?: DateTimeFilter<"restok_bahan"> | Date | string
    updated_at?: DateTimeFilter<"restok_bahan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"restok_bahan"> | Date | string | null
    daftar_bahan?: XOR<Daftar_bahanRelationFilter, daftar_bahanWhereInput>
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
  }, "id">

  export type restok_bahanOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: restok_bahanCountOrderByAggregateInput
    _avg?: restok_bahanAvgOrderByAggregateInput
    _max?: restok_bahanMaxOrderByAggregateInput
    _min?: restok_bahanMinOrderByAggregateInput
    _sum?: restok_bahanSumOrderByAggregateInput
  }

  export type restok_bahanScalarWhereWithAggregatesInput = {
    AND?: restok_bahanScalarWhereWithAggregatesInput | restok_bahanScalarWhereWithAggregatesInput[]
    OR?: restok_bahanScalarWhereWithAggregatesInput[]
    NOT?: restok_bahanScalarWhereWithAggregatesInput | restok_bahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"restok_bahan"> | number
    tanggal_pesan?: DateTimeWithAggregatesFilter<"restok_bahan"> | Date | string
    tanggal_terima?: DateTimeWithAggregatesFilter<"restok_bahan"> | Date | string
    harga_satuan?: FloatWithAggregatesFilter<"restok_bahan"> | number
    jumlah?: FloatWithAggregatesFilter<"restok_bahan"> | number
    daftar_bahan_id?: IntWithAggregatesFilter<"restok_bahan"> | number
    supplier_id?: IntWithAggregatesFilter<"restok_bahan"> | number
    created_at?: DateTimeWithAggregatesFilter<"restok_bahan"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"restok_bahan"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"restok_bahan"> | Date | string | null
  }

  export type supplierWhereInput = {
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    id?: IntFilter<"supplier"> | number
    kode?: StringFilter<"supplier"> | string
    nama?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    no_rek?: StringFilter<"supplier"> | string
    created_at?: DateTimeFilter<"supplier"> | Date | string
    updated_at?: DateTimeFilter<"supplier"> | Date | string
    deleted_at?: DateTimeNullableFilter<"supplier"> | Date | string | null
    restok_bahan?: Restok_bahanListRelationFilter
  }

  export type supplierOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    no_rek?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    restok_bahan?: restok_bahanOrderByRelationAggregateInput
  }

  export type supplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    kode?: StringFilter<"supplier"> | string
    nama?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    no_rek?: StringFilter<"supplier"> | string
    created_at?: DateTimeFilter<"supplier"> | Date | string
    updated_at?: DateTimeFilter<"supplier"> | Date | string
    deleted_at?: DateTimeNullableFilter<"supplier"> | Date | string | null
    restok_bahan?: Restok_bahanListRelationFilter
  }, "id">

  export type supplierOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    no_rek?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    OR?: supplierScalarWhereWithAggregatesInput[]
    NOT?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplier"> | number
    kode?: StringWithAggregatesFilter<"supplier"> | string
    nama?: StringWithAggregatesFilter<"supplier"> | string
    alamat?: StringWithAggregatesFilter<"supplier"> | string
    kontak?: StringWithAggregatesFilter<"supplier"> | string
    no_rek?: StringWithAggregatesFilter<"supplier"> | string
    created_at?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"supplier"> | Date | string | null
  }

  export type produksiWhereInput = {
    AND?: produksiWhereInput | produksiWhereInput[]
    OR?: produksiWhereInput[]
    NOT?: produksiWhereInput | produksiWhereInput[]
    id?: IntFilter<"produksi"> | number
    produksi?: StringFilter<"produksi"> | string
    tanggal_mulai?: DateTimeFilter<"produksi"> | Date | string
    tanggal_selesai?: DateTimeNullableFilter<"produksi"> | Date | string | null
    jumlah?: IntFilter<"produksi"> | number
    detail_model_produk_id?: IntFilter<"produksi"> | number
    user_id?: IntFilter<"produksi"> | number
    created_at?: DateTimeFilter<"produksi"> | Date | string
    updated_at?: DateTimeFilter<"produksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"produksi"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    qcproduksi?: QcproduksiListRelationFilter
  }

  export type produksiOrderByWithRelationInput = {
    id?: SortOrder
    produksi?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    detail_model_produk?: detail_model_produkOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    qcproduksi?: qcproduksiOrderByRelationAggregateInput
  }

  export type produksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produksiWhereInput | produksiWhereInput[]
    OR?: produksiWhereInput[]
    NOT?: produksiWhereInput | produksiWhereInput[]
    produksi?: StringFilter<"produksi"> | string
    tanggal_mulai?: DateTimeFilter<"produksi"> | Date | string
    tanggal_selesai?: DateTimeNullableFilter<"produksi"> | Date | string | null
    jumlah?: IntFilter<"produksi"> | number
    detail_model_produk_id?: IntFilter<"produksi"> | number
    user_id?: IntFilter<"produksi"> | number
    created_at?: DateTimeFilter<"produksi"> | Date | string
    updated_at?: DateTimeFilter<"produksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"produksi"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    qcproduksi?: QcproduksiListRelationFilter
  }, "id">

  export type produksiOrderByWithAggregationInput = {
    id?: SortOrder
    produksi?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: produksiCountOrderByAggregateInput
    _avg?: produksiAvgOrderByAggregateInput
    _max?: produksiMaxOrderByAggregateInput
    _min?: produksiMinOrderByAggregateInput
    _sum?: produksiSumOrderByAggregateInput
  }

  export type produksiScalarWhereWithAggregatesInput = {
    AND?: produksiScalarWhereWithAggregatesInput | produksiScalarWhereWithAggregatesInput[]
    OR?: produksiScalarWhereWithAggregatesInput[]
    NOT?: produksiScalarWhereWithAggregatesInput | produksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produksi"> | number
    produksi?: StringWithAggregatesFilter<"produksi"> | string
    tanggal_mulai?: DateTimeWithAggregatesFilter<"produksi"> | Date | string
    tanggal_selesai?: DateTimeNullableWithAggregatesFilter<"produksi"> | Date | string | null
    jumlah?: IntWithAggregatesFilter<"produksi"> | number
    detail_model_produk_id?: IntWithAggregatesFilter<"produksi"> | number
    user_id?: IntWithAggregatesFilter<"produksi"> | number
    created_at?: DateTimeWithAggregatesFilter<"produksi"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"produksi"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"produksi"> | Date | string | null
  }

  export type qcproduksiWhereInput = {
    AND?: qcproduksiWhereInput | qcproduksiWhereInput[]
    OR?: qcproduksiWhereInput[]
    NOT?: qcproduksiWhereInput | qcproduksiWhereInput[]
    id?: IntFilter<"qcproduksi"> | number
    waktu?: DateTimeFilter<"qcproduksi"> | Date | string
    deskripsi?: StringFilter<"qcproduksi"> | string
    status?: StringFilter<"qcproduksi"> | string
    user_id?: IntFilter<"qcproduksi"> | number
    produksi_id?: IntFilter<"qcproduksi"> | number
    created_at?: DateTimeFilter<"qcproduksi"> | Date | string
    updated_at?: DateTimeFilter<"qcproduksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"qcproduksi"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
  }

  export type qcproduksiOrderByWithRelationInput = {
    id?: SortOrder
    waktu?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    produksi?: produksiOrderByWithRelationInput
  }

  export type qcproduksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qcproduksiWhereInput | qcproduksiWhereInput[]
    OR?: qcproduksiWhereInput[]
    NOT?: qcproduksiWhereInput | qcproduksiWhereInput[]
    waktu?: DateTimeFilter<"qcproduksi"> | Date | string
    deskripsi?: StringFilter<"qcproduksi"> | string
    status?: StringFilter<"qcproduksi"> | string
    user_id?: IntFilter<"qcproduksi"> | number
    produksi_id?: IntFilter<"qcproduksi"> | number
    created_at?: DateTimeFilter<"qcproduksi"> | Date | string
    updated_at?: DateTimeFilter<"qcproduksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"qcproduksi"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    produksi?: XOR<ProduksiRelationFilter, produksiWhereInput>
  }, "id">

  export type qcproduksiOrderByWithAggregationInput = {
    id?: SortOrder
    waktu?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: qcproduksiCountOrderByAggregateInput
    _avg?: qcproduksiAvgOrderByAggregateInput
    _max?: qcproduksiMaxOrderByAggregateInput
    _min?: qcproduksiMinOrderByAggregateInput
    _sum?: qcproduksiSumOrderByAggregateInput
  }

  export type qcproduksiScalarWhereWithAggregatesInput = {
    AND?: qcproduksiScalarWhereWithAggregatesInput | qcproduksiScalarWhereWithAggregatesInput[]
    OR?: qcproduksiScalarWhereWithAggregatesInput[]
    NOT?: qcproduksiScalarWhereWithAggregatesInput | qcproduksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qcproduksi"> | number
    waktu?: DateTimeWithAggregatesFilter<"qcproduksi"> | Date | string
    deskripsi?: StringWithAggregatesFilter<"qcproduksi"> | string
    status?: StringWithAggregatesFilter<"qcproduksi"> | string
    user_id?: IntWithAggregatesFilter<"qcproduksi"> | number
    produksi_id?: IntWithAggregatesFilter<"qcproduksi"> | number
    created_at?: DateTimeWithAggregatesFilter<"qcproduksi"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"qcproduksi"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"qcproduksi"> | Date | string | null
  }

  export type daftar_produkWhereInput = {
    AND?: daftar_produkWhereInput | daftar_produkWhereInput[]
    OR?: daftar_produkWhereInput[]
    NOT?: daftar_produkWhereInput | daftar_produkWhereInput[]
    id?: IntFilter<"daftar_produk"> | number
    sku?: StringFilter<"daftar_produk"> | string
    detail_model_produk_id?: IntFilter<"daftar_produk"> | number
    created_at?: DateTimeFilter<"daftar_produk"> | Date | string
    updated_at?: DateTimeFilter<"daftar_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"daftar_produk"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
  }

  export type daftar_produkOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    detail_model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    detail_model_produk?: detail_model_produkOrderByWithRelationInput
  }

  export type daftar_produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: daftar_produkWhereInput | daftar_produkWhereInput[]
    OR?: daftar_produkWhereInput[]
    NOT?: daftar_produkWhereInput | daftar_produkWhereInput[]
    sku?: StringFilter<"daftar_produk"> | string
    detail_model_produk_id?: IntFilter<"daftar_produk"> | number
    created_at?: DateTimeFilter<"daftar_produk"> | Date | string
    updated_at?: DateTimeFilter<"daftar_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"daftar_produk"> | Date | string | null
    detail_model_produk?: XOR<Detail_model_produkRelationFilter, detail_model_produkWhereInput>
  }, "id">

  export type daftar_produkOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    detail_model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: daftar_produkCountOrderByAggregateInput
    _avg?: daftar_produkAvgOrderByAggregateInput
    _max?: daftar_produkMaxOrderByAggregateInput
    _min?: daftar_produkMinOrderByAggregateInput
    _sum?: daftar_produkSumOrderByAggregateInput
  }

  export type daftar_produkScalarWhereWithAggregatesInput = {
    AND?: daftar_produkScalarWhereWithAggregatesInput | daftar_produkScalarWhereWithAggregatesInput[]
    OR?: daftar_produkScalarWhereWithAggregatesInput[]
    NOT?: daftar_produkScalarWhereWithAggregatesInput | daftar_produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"daftar_produk"> | number
    sku?: StringWithAggregatesFilter<"daftar_produk"> | string
    detail_model_produk_id?: IntWithAggregatesFilter<"daftar_produk"> | number
    created_at?: DateTimeWithAggregatesFilter<"daftar_produk"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"daftar_produk"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"daftar_produk"> | Date | string | null
  }

  export type userCreateInput = {
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    karyawan: karyawanCreateNestedOneWithoutUsersInput
    role: roleCreateNestedOneWithoutUsersInput
    produksi?: produksiCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    produksi?: produksiUncheckedCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    karyawan?: karyawanUpdateOneRequiredWithoutUsersNestedInput
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
    produksi?: produksiUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produksi?: produksiUncheckedUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type karyawanCreateInput = {
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date | string
    jenis_kelamin: string
    no_rekening: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userCreateNestedManyWithoutKaryawanInput
  }

  export type karyawanUncheckedCreateInput = {
    id?: number
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date | string
    jenis_kelamin: string
    no_rekening: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userUncheckedCreateNestedManyWithoutKaryawanInput
  }

  export type karyawanUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUpdateManyWithoutKaryawanNestedInput
  }

  export type karyawanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUncheckedUpdateManyWithoutKaryawanNestedInput
  }

  export type karyawanCreateManyInput = {
    id?: number
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date | string
    jenis_kelamin: string
    no_rekening: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type karyawanUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type karyawanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleCreateInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userCreateNestedManyWithoutRoleInput
    hak_akses?: hak_aksesCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userUncheckedCreateNestedManyWithoutRoleInput
    hak_akses?: hak_aksesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUpdateManyWithoutRoleNestedInput
    hak_akses?: hak_aksesUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUncheckedUpdateManyWithoutRoleNestedInput
    hak_akses?: hak_aksesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type roleUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aksesCreateInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesCreateNestedManyWithoutAksesInput
  }

  export type aksesUncheckedCreateInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesUncheckedCreateNestedManyWithoutAksesInput
  }

  export type aksesUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUpdateManyWithoutAksesNestedInput
  }

  export type aksesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUncheckedUpdateManyWithoutAksesNestedInput
  }

  export type aksesCreateManyInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type aksesUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aksesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fungsiCreateInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesCreateNestedManyWithoutFungsiInput
  }

  export type fungsiUncheckedCreateInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesUncheckedCreateNestedManyWithoutFungsiInput
  }

  export type fungsiUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUpdateManyWithoutFungsiNestedInput
  }

  export type fungsiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUncheckedUpdateManyWithoutFungsiNestedInput
  }

  export type fungsiCreateManyInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type fungsiUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fungsiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    role: roleCreateNestedOneWithoutHak_aksesInput
    fungsi: fungsiCreateNestedOneWithoutHak_aksesInput
    akses: aksesCreateNestedOneWithoutHak_aksesInput
  }

  export type hak_aksesUncheckedCreateInput = {
    id?: number
    role_id: number
    fungsi_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutHak_aksesNestedInput
    fungsi?: fungsiUpdateOneRequiredWithoutHak_aksesNestedInput
    akses?: aksesUpdateOneRequiredWithoutHak_aksesNestedInput
  }

  export type hak_aksesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesCreateManyInput = {
    id?: number
    role_id: number
    fungsi_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type model_produkCreateInput = {
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    kategori: kategori_produkCreateNestedOneWithoutModel_produkInput
    foto_produk?: foto_produkCreateNestedManyWithoutModel_produkInput
    detail_model_produk?: detail_model_produkCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkUncheckedCreateInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    kategori_id: number
    created_at?: Date | string
    updated_at?: Date | string
    foto_produk?: foto_produkUncheckedCreateNestedManyWithoutModel_produkInput
    detail_model_produk?: detail_model_produkUncheckedCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kategori?: kategori_produkUpdateOneRequiredWithoutModel_produkNestedInput
    foto_produk?: foto_produkUpdateManyWithoutModel_produkNestedInput
    detail_model_produk?: detail_model_produkUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategori_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    foto_produk?: foto_produkUncheckedUpdateManyWithoutModel_produkNestedInput
    detail_model_produk?: detail_model_produkUncheckedUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkCreateManyInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    kategori_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type model_produkUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type model_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategori_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type foto_produkCreateInput = {
    filepath: string
    model_produk: model_produkCreateNestedOneWithoutFoto_produkInput
  }

  export type foto_produkUncheckedCreateInput = {
    id?: number
    filepath: string
    model_produk_id: number
  }

  export type foto_produkUpdateInput = {
    filepath?: StringFieldUpdateOperationsInput | string
    model_produk?: model_produkUpdateOneRequiredWithoutFoto_produkNestedInput
  }

  export type foto_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filepath?: StringFieldUpdateOperationsInput | string
    model_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type foto_produkCreateManyInput = {
    id?: number
    filepath: string
    model_produk_id: number
  }

  export type foto_produkUpdateManyMutationInput = {
    filepath?: StringFieldUpdateOperationsInput | string
  }

  export type foto_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filepath?: StringFieldUpdateOperationsInput | string
    model_produk_id?: IntFieldUpdateOperationsInput | number
  }

  export type kategori_produkCreateInput = {
    nama: string
    tipe: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk?: model_produkCreateNestedManyWithoutKategoriInput
  }

  export type kategori_produkUncheckedCreateInput = {
    id?: number
    nama: string
    tipe: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk?: model_produkUncheckedCreateNestedManyWithoutKategoriInput
  }

  export type kategori_produkUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUpdateManyWithoutKategoriNestedInput
  }

  export type kategori_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUncheckedUpdateManyWithoutKategoriNestedInput
  }

  export type kategori_produkCreateManyInput = {
    id?: number
    nama: string
    tipe: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type kategori_produkUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kategori_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type detail_model_produkCreateInput = {
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk: model_produkCreateNestedOneWithoutDetail_model_produkInput
    bahan_produk?: bahan_produkCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUncheckedCreateInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiUncheckedCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUpdateInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUpdateOneRequiredWithoutDetail_model_produkNestedInput
    bahan_produk?: bahan_produkUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUncheckedUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkCreateManyInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type detail_model_produkUpdateManyMutationInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type detail_model_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bahan_produkCreateInput = {
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutBahan_produkInput
    daftar_bahan: daftar_bahanCreateNestedOneWithoutBahan_produkInput
  }

  export type bahan_produkUncheckedCreateInput = {
    id?: number
    jumlah: number
    detail_model_produk_id: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkUpdateInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutBahan_produkNestedInput
    daftar_bahan?: daftar_bahanUpdateOneRequiredWithoutBahan_produkNestedInput
  }

  export type bahan_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bahan_produkCreateManyInput = {
    id?: number
    jumlah: number
    detail_model_produk_id: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkUpdateManyMutationInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bahan_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_bahanCreateInput = {
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    bahan_produk?: bahan_produkCreateNestedManyWithoutDaftar_bahanInput
    restok_bahan?: restok_bahanCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanUncheckedCreateInput = {
    id?: number
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDaftar_bahanInput
    restok_bahan?: restok_bahanUncheckedCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bahan_produk?: bahan_produkUpdateManyWithoutDaftar_bahanNestedInput
    restok_bahan?: restok_bahanUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type daftar_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDaftar_bahanNestedInput
    restok_bahan?: restok_bahanUncheckedUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type daftar_bahanCreateManyInput = {
    id?: number
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_bahanUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanCreateInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    daftar_bahan: daftar_bahanCreateNestedOneWithoutRestok_bahanInput
    supplier: supplierCreateNestedOneWithoutRestok_bahanInput
  }

  export type restok_bahanUncheckedCreateInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    supplier_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanUpdateInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daftar_bahan?: daftar_bahanUpdateOneRequiredWithoutRestok_bahanNestedInput
    supplier?: supplierUpdateOneRequiredWithoutRestok_bahanNestedInput
  }

  export type restok_bahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanCreateManyInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    supplier_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanUpdateManyMutationInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supplierCreateInput = {
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    restok_bahan?: restok_bahanCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    id?: number
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    restok_bahan?: restok_bahanUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restok_bahan?: restok_bahanUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restok_bahan?: restok_bahanUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateManyInput = {
    id?: number
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type supplierUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type produksiCreateInput = {
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutProduksiInput
    user: userCreateNestedOneWithoutProduksiInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    detail_model_produk_id: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiUpdateInput = {
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutProduksiNestedInput
    user?: userUpdateOneRequiredWithoutProduksiNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiCreateManyInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    detail_model_produk_id: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type produksiUpdateManyMutationInput = {
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type produksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiCreateInput = {
    waktu?: Date | string
    deskripsi: string
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutQcproduksiInput
    produksi: produksiCreateNestedOneWithoutQcproduksiInput
  }

  export type qcproduksiUncheckedCreateInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    user_id: number
    produksi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiUpdateInput = {
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQcproduksiNestedInput
    produksi?: produksiUpdateOneRequiredWithoutQcproduksiNestedInput
  }

  export type qcproduksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiCreateManyInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    user_id: number
    produksi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiUpdateManyMutationInput = {
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    produksi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkCreateInput = {
    sku: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutDaftar_produkInput
  }

  export type daftar_produkUncheckedCreateInput = {
    id?: number
    sku: string
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_produkUpdateInput = {
    sku?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutDaftar_produkNestedInput
  }

  export type daftar_produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkCreateManyInput = {
    id?: number
    sku: string
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_produkUpdateManyMutationInput = {
    sku?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type KaryawanRelationFilter = {
    is?: karyawanWhereInput
    isNot?: karyawanWhereInput
  }

  export type RoleRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type ProduksiListRelationFilter = {
    every?: produksiWhereInput
    some?: produksiWhereInput
    none?: produksiWhereInput
  }

  export type QcproduksiListRelationFilter = {
    every?: qcproduksiWhereInput
    some?: qcproduksiWhereInput
    none?: qcproduksiWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type produksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qcproduksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    karyawan_id?: SortOrder
    role_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type karyawanCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    tanggal_lahir?: SortOrder
    jenis_kelamin?: SortOrder
    no_rekening?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type karyawanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type karyawanMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    tanggal_lahir?: SortOrder
    jenis_kelamin?: SortOrder
    no_rekening?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type karyawanMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    tanggal_lahir?: SortOrder
    jenis_kelamin?: SortOrder
    no_rekening?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type karyawanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Hak_aksesListRelationFilter = {
    every?: hak_aksesWhereInput
    some?: hak_aksesWhereInput
    none?: hak_aksesWhereInput
  }

  export type hak_aksesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type aksesCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type aksesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type aksesMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type aksesMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type aksesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fungsiCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type fungsiAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fungsiMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type fungsiMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type fungsiSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FungsiRelationFilter = {
    is?: fungsiWhereInput
    isNot?: fungsiWhereInput
  }

  export type AksesRelationFilter = {
    is?: aksesWhereInput
    isNot?: aksesWhereInput
  }

  export type hak_aksesHakAksesConstraintCompoundUniqueInput = {
    role_id: number
    fungsi_id: number
    akses_id: number
  }

  export type hak_aksesCountOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type hak_aksesAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
  }

  export type hak_aksesMaxOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type hak_aksesMinOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type hak_aksesSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    fungsi_id?: SortOrder
    akses_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Kategori_produkRelationFilter = {
    is?: kategori_produkWhereInput
    isNot?: kategori_produkWhereInput
  }

  export type Foto_produkListRelationFilter = {
    every?: foto_produkWhereInput
    some?: foto_produkWhereInput
    none?: foto_produkWhereInput
  }

  export type Detail_model_produkListRelationFilter = {
    every?: detail_model_produkWhereInput
    some?: detail_model_produkWhereInput
    none?: detail_model_produkWhereInput
  }

  export type foto_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_model_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type model_produkCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    variasi?: SortOrder
    deskripsi?: SortOrder
    deleted_at?: SortOrder
    kategori_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type model_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    kategori_id?: SortOrder
  }

  export type model_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    variasi?: SortOrder
    deskripsi?: SortOrder
    deleted_at?: SortOrder
    kategori_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type model_produkMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    variasi?: SortOrder
    deskripsi?: SortOrder
    deleted_at?: SortOrder
    kategori_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type model_produkSumOrderByAggregateInput = {
    id?: SortOrder
    kategori_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Model_produkRelationFilter = {
    is?: model_produkWhereInput
    isNot?: model_produkWhereInput
  }

  export type foto_produkCountOrderByAggregateInput = {
    id?: SortOrder
    filepath?: SortOrder
    model_produk_id?: SortOrder
  }

  export type foto_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    model_produk_id?: SortOrder
  }

  export type foto_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    filepath?: SortOrder
    model_produk_id?: SortOrder
  }

  export type foto_produkMinOrderByAggregateInput = {
    id?: SortOrder
    filepath?: SortOrder
    model_produk_id?: SortOrder
  }

  export type foto_produkSumOrderByAggregateInput = {
    id?: SortOrder
    model_produk_id?: SortOrder
  }

  export type Model_produkListRelationFilter = {
    every?: model_produkWhereInput
    some?: model_produkWhereInput
    none?: model_produkWhereInput
  }

  export type model_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kategori_produkCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kategori_produkAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kategori_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kategori_produkMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kategori_produkSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Bahan_produkListRelationFilter = {
    every?: bahan_produkWhereInput
    some?: bahan_produkWhereInput
    none?: bahan_produkWhereInput
  }

  export type Daftar_produkListRelationFilter = {
    every?: daftar_produkWhereInput
    some?: daftar_produkWhereInput
    none?: daftar_produkWhereInput
  }

  export type bahan_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type daftar_produkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detail_model_produkCountOrderByAggregateInput = {
    id?: SortOrder
    ukuran?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    deleted_at?: SortOrder
    model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type detail_model_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    model_produk_id?: SortOrder
  }

  export type detail_model_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    ukuran?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    deleted_at?: SortOrder
    model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type detail_model_produkMinOrderByAggregateInput = {
    id?: SortOrder
    ukuran?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    deleted_at?: SortOrder
    model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type detail_model_produkSumOrderByAggregateInput = {
    id?: SortOrder
    biaya_jahit?: SortOrder
    hpp?: SortOrder
    harga_jual?: SortOrder
    model_produk_id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Detail_model_produkRelationFilter = {
    is?: detail_model_produkWhereInput
    isNot?: detail_model_produkWhereInput
  }

  export type Daftar_bahanRelationFilter = {
    is?: daftar_bahanWhereInput
    isNot?: daftar_bahanWhereInput
  }

  export type bahan_produkCountOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type bahan_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
  }

  export type bahan_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type bahan_produkMinOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type bahan_produkSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    daftar_bahan_id?: SortOrder
  }

  export type Restok_bahanListRelationFilter = {
    every?: restok_bahanWhereInput
    some?: restok_bahanWhereInput
    none?: restok_bahanWhereInput
  }

  export type restok_bahanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type daftar_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    stok?: SortOrder
    nama?: SortOrder
    satuan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    stok?: SortOrder
  }

  export type daftar_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    stok?: SortOrder
    nama?: SortOrder
    satuan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    stok?: SortOrder
    nama?: SortOrder
    satuan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    stok?: SortOrder
  }

  export type SupplierRelationFilter = {
    is?: supplierWhereInput
    isNot?: supplierWhereInput
  }

  export type restok_bahanCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type restok_bahanAvgOrderByAggregateInput = {
    id?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type restok_bahanMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type restok_bahanMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal_pesan?: SortOrder
    tanggal_terima?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type restok_bahanSumOrderByAggregateInput = {
    id?: SortOrder
    harga_satuan?: SortOrder
    jumlah?: SortOrder
    daftar_bahan_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    no_rek?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    no_rek?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    kontak?: SortOrder
    no_rek?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type produksiCountOrderByAggregateInput = {
    id?: SortOrder
    produksi?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type produksiAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
  }

  export type produksiMaxOrderByAggregateInput = {
    id?: SortOrder
    produksi?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type produksiMinOrderByAggregateInput = {
    id?: SortOrder
    produksi?: SortOrder
    tanggal_mulai?: SortOrder
    tanggal_selesai?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type produksiSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    detail_model_produk_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProduksiRelationFilter = {
    is?: produksiWhereInput
    isNot?: produksiWhereInput
  }

  export type qcproduksiCountOrderByAggregateInput = {
    id?: SortOrder
    waktu?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type qcproduksiAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
  }

  export type qcproduksiMaxOrderByAggregateInput = {
    id?: SortOrder
    waktu?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type qcproduksiMinOrderByAggregateInput = {
    id?: SortOrder
    waktu?: SortOrder
    deskripsi?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type qcproduksiSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    produksi_id?: SortOrder
  }

  export type daftar_produkCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    detail_model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_produkAvgOrderByAggregateInput = {
    id?: SortOrder
    detail_model_produk_id?: SortOrder
  }

  export type daftar_produkMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    detail_model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_produkMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    detail_model_produk_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type daftar_produkSumOrderByAggregateInput = {
    id?: SortOrder
    detail_model_produk_id?: SortOrder
  }

  export type karyawanCreateNestedOneWithoutUsersInput = {
    create?: XOR<karyawanCreateWithoutUsersInput, karyawanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: karyawanCreateOrConnectWithoutUsersInput
    connect?: karyawanWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutUsersInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    connect?: roleWhereUniqueInput
  }

  export type produksiCreateNestedManyWithoutUserInput = {
    create?: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput> | produksiCreateWithoutUserInput[] | produksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutUserInput | produksiCreateOrConnectWithoutUserInput[]
    createMany?: produksiCreateManyUserInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type qcproduksiCreateNestedManyWithoutUserInput = {
    create?: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput> | qcproduksiCreateWithoutUserInput[] | qcproduksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutUserInput | qcproduksiCreateOrConnectWithoutUserInput[]
    createMany?: qcproduksiCreateManyUserInputEnvelope
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
  }

  export type produksiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput> | produksiCreateWithoutUserInput[] | produksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutUserInput | produksiCreateOrConnectWithoutUserInput[]
    createMany?: produksiCreateManyUserInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type qcproduksiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput> | qcproduksiCreateWithoutUserInput[] | qcproduksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutUserInput | qcproduksiCreateOrConnectWithoutUserInput[]
    createMany?: qcproduksiCreateManyUserInputEnvelope
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type karyawanUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<karyawanCreateWithoutUsersInput, karyawanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: karyawanCreateOrConnectWithoutUsersInput
    upsert?: karyawanUpsertWithoutUsersInput
    connect?: karyawanWhereUniqueInput
    update?: XOR<XOR<karyawanUpdateToOneWithWhereWithoutUsersInput, karyawanUpdateWithoutUsersInput>, karyawanUncheckedUpdateWithoutUsersInput>
  }

  export type roleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    upsert?: roleUpsertWithoutUsersInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUsersInput, roleUpdateWithoutUsersInput>, roleUncheckedUpdateWithoutUsersInput>
  }

  export type produksiUpdateManyWithoutUserNestedInput = {
    create?: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput> | produksiCreateWithoutUserInput[] | produksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutUserInput | produksiCreateOrConnectWithoutUserInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutUserInput | produksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: produksiCreateManyUserInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutUserInput | produksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutUserInput | produksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type qcproduksiUpdateManyWithoutUserNestedInput = {
    create?: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput> | qcproduksiCreateWithoutUserInput[] | qcproduksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutUserInput | qcproduksiCreateOrConnectWithoutUserInput[]
    upsert?: qcproduksiUpsertWithWhereUniqueWithoutUserInput | qcproduksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: qcproduksiCreateManyUserInputEnvelope
    set?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    disconnect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    delete?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    update?: qcproduksiUpdateWithWhereUniqueWithoutUserInput | qcproduksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: qcproduksiUpdateManyWithWhereWithoutUserInput | qcproduksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type produksiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput> | produksiCreateWithoutUserInput[] | produksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutUserInput | produksiCreateOrConnectWithoutUserInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutUserInput | produksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: produksiCreateManyUserInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutUserInput | produksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutUserInput | produksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type qcproduksiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput> | qcproduksiCreateWithoutUserInput[] | qcproduksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutUserInput | qcproduksiCreateOrConnectWithoutUserInput[]
    upsert?: qcproduksiUpsertWithWhereUniqueWithoutUserInput | qcproduksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: qcproduksiCreateManyUserInputEnvelope
    set?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    disconnect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    delete?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    update?: qcproduksiUpdateWithWhereUniqueWithoutUserInput | qcproduksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: qcproduksiUpdateManyWithWhereWithoutUserInput | qcproduksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutKaryawanInput = {
    create?: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput> | userCreateWithoutKaryawanInput[] | userUncheckedCreateWithoutKaryawanInput[]
    connectOrCreate?: userCreateOrConnectWithoutKaryawanInput | userCreateOrConnectWithoutKaryawanInput[]
    createMany?: userCreateManyKaryawanInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutKaryawanInput = {
    create?: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput> | userCreateWithoutKaryawanInput[] | userUncheckedCreateWithoutKaryawanInput[]
    connectOrCreate?: userCreateOrConnectWithoutKaryawanInput | userCreateOrConnectWithoutKaryawanInput[]
    createMany?: userCreateManyKaryawanInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutKaryawanNestedInput = {
    create?: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput> | userCreateWithoutKaryawanInput[] | userUncheckedCreateWithoutKaryawanInput[]
    connectOrCreate?: userCreateOrConnectWithoutKaryawanInput | userCreateOrConnectWithoutKaryawanInput[]
    upsert?: userUpsertWithWhereUniqueWithoutKaryawanInput | userUpsertWithWhereUniqueWithoutKaryawanInput[]
    createMany?: userCreateManyKaryawanInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutKaryawanInput | userUpdateWithWhereUniqueWithoutKaryawanInput[]
    updateMany?: userUpdateManyWithWhereWithoutKaryawanInput | userUpdateManyWithWhereWithoutKaryawanInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutKaryawanNestedInput = {
    create?: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput> | userCreateWithoutKaryawanInput[] | userUncheckedCreateWithoutKaryawanInput[]
    connectOrCreate?: userCreateOrConnectWithoutKaryawanInput | userCreateOrConnectWithoutKaryawanInput[]
    upsert?: userUpsertWithWhereUniqueWithoutKaryawanInput | userUpsertWithWhereUniqueWithoutKaryawanInput[]
    createMany?: userCreateManyKaryawanInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutKaryawanInput | userUpdateWithWhereUniqueWithoutKaryawanInput[]
    updateMany?: userUpdateManyWithWhereWithoutKaryawanInput | userUpdateManyWithWhereWithoutKaryawanInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type hak_aksesCreateNestedManyWithoutRoleInput = {
    create?: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput> | hak_aksesCreateWithoutRoleInput[] | hak_aksesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutRoleInput | hak_aksesCreateOrConnectWithoutRoleInput[]
    createMany?: hak_aksesCreateManyRoleInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type hak_aksesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput> | hak_aksesCreateWithoutRoleInput[] | hak_aksesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutRoleInput | hak_aksesCreateOrConnectWithoutRoleInput[]
    createMany?: hak_aksesCreateManyRoleInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type userUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type hak_aksesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput> | hak_aksesCreateWithoutRoleInput[] | hak_aksesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutRoleInput | hak_aksesCreateOrConnectWithoutRoleInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutRoleInput | hak_aksesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: hak_aksesCreateManyRoleInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutRoleInput | hak_aksesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutRoleInput | hak_aksesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type hak_aksesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput> | hak_aksesCreateWithoutRoleInput[] | hak_aksesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutRoleInput | hak_aksesCreateOrConnectWithoutRoleInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutRoleInput | hak_aksesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: hak_aksesCreateManyRoleInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutRoleInput | hak_aksesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutRoleInput | hak_aksesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type hak_aksesCreateNestedManyWithoutAksesInput = {
    create?: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput> | hak_aksesCreateWithoutAksesInput[] | hak_aksesUncheckedCreateWithoutAksesInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutAksesInput | hak_aksesCreateOrConnectWithoutAksesInput[]
    createMany?: hak_aksesCreateManyAksesInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type hak_aksesUncheckedCreateNestedManyWithoutAksesInput = {
    create?: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput> | hak_aksesCreateWithoutAksesInput[] | hak_aksesUncheckedCreateWithoutAksesInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutAksesInput | hak_aksesCreateOrConnectWithoutAksesInput[]
    createMany?: hak_aksesCreateManyAksesInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type hak_aksesUpdateManyWithoutAksesNestedInput = {
    create?: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput> | hak_aksesCreateWithoutAksesInput[] | hak_aksesUncheckedCreateWithoutAksesInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutAksesInput | hak_aksesCreateOrConnectWithoutAksesInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutAksesInput | hak_aksesUpsertWithWhereUniqueWithoutAksesInput[]
    createMany?: hak_aksesCreateManyAksesInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutAksesInput | hak_aksesUpdateWithWhereUniqueWithoutAksesInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutAksesInput | hak_aksesUpdateManyWithWhereWithoutAksesInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type hak_aksesUncheckedUpdateManyWithoutAksesNestedInput = {
    create?: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput> | hak_aksesCreateWithoutAksesInput[] | hak_aksesUncheckedCreateWithoutAksesInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutAksesInput | hak_aksesCreateOrConnectWithoutAksesInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutAksesInput | hak_aksesUpsertWithWhereUniqueWithoutAksesInput[]
    createMany?: hak_aksesCreateManyAksesInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutAksesInput | hak_aksesUpdateWithWhereUniqueWithoutAksesInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutAksesInput | hak_aksesUpdateManyWithWhereWithoutAksesInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type hak_aksesCreateNestedManyWithoutFungsiInput = {
    create?: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput> | hak_aksesCreateWithoutFungsiInput[] | hak_aksesUncheckedCreateWithoutFungsiInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutFungsiInput | hak_aksesCreateOrConnectWithoutFungsiInput[]
    createMany?: hak_aksesCreateManyFungsiInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type hak_aksesUncheckedCreateNestedManyWithoutFungsiInput = {
    create?: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput> | hak_aksesCreateWithoutFungsiInput[] | hak_aksesUncheckedCreateWithoutFungsiInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutFungsiInput | hak_aksesCreateOrConnectWithoutFungsiInput[]
    createMany?: hak_aksesCreateManyFungsiInputEnvelope
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
  }

  export type hak_aksesUpdateManyWithoutFungsiNestedInput = {
    create?: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput> | hak_aksesCreateWithoutFungsiInput[] | hak_aksesUncheckedCreateWithoutFungsiInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutFungsiInput | hak_aksesCreateOrConnectWithoutFungsiInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutFungsiInput | hak_aksesUpsertWithWhereUniqueWithoutFungsiInput[]
    createMany?: hak_aksesCreateManyFungsiInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutFungsiInput | hak_aksesUpdateWithWhereUniqueWithoutFungsiInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutFungsiInput | hak_aksesUpdateManyWithWhereWithoutFungsiInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type hak_aksesUncheckedUpdateManyWithoutFungsiNestedInput = {
    create?: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput> | hak_aksesCreateWithoutFungsiInput[] | hak_aksesUncheckedCreateWithoutFungsiInput[]
    connectOrCreate?: hak_aksesCreateOrConnectWithoutFungsiInput | hak_aksesCreateOrConnectWithoutFungsiInput[]
    upsert?: hak_aksesUpsertWithWhereUniqueWithoutFungsiInput | hak_aksesUpsertWithWhereUniqueWithoutFungsiInput[]
    createMany?: hak_aksesCreateManyFungsiInputEnvelope
    set?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    disconnect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    delete?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    connect?: hak_aksesWhereUniqueInput | hak_aksesWhereUniqueInput[]
    update?: hak_aksesUpdateWithWhereUniqueWithoutFungsiInput | hak_aksesUpdateWithWhereUniqueWithoutFungsiInput[]
    updateMany?: hak_aksesUpdateManyWithWhereWithoutFungsiInput | hak_aksesUpdateManyWithWhereWithoutFungsiInput[]
    deleteMany?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
  }

  export type roleCreateNestedOneWithoutHak_aksesInput = {
    create?: XOR<roleCreateWithoutHak_aksesInput, roleUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: roleCreateOrConnectWithoutHak_aksesInput
    connect?: roleWhereUniqueInput
  }

  export type fungsiCreateNestedOneWithoutHak_aksesInput = {
    create?: XOR<fungsiCreateWithoutHak_aksesInput, fungsiUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: fungsiCreateOrConnectWithoutHak_aksesInput
    connect?: fungsiWhereUniqueInput
  }

  export type aksesCreateNestedOneWithoutHak_aksesInput = {
    create?: XOR<aksesCreateWithoutHak_aksesInput, aksesUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: aksesCreateOrConnectWithoutHak_aksesInput
    connect?: aksesWhereUniqueInput
  }

  export type roleUpdateOneRequiredWithoutHak_aksesNestedInput = {
    create?: XOR<roleCreateWithoutHak_aksesInput, roleUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: roleCreateOrConnectWithoutHak_aksesInput
    upsert?: roleUpsertWithoutHak_aksesInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutHak_aksesInput, roleUpdateWithoutHak_aksesInput>, roleUncheckedUpdateWithoutHak_aksesInput>
  }

  export type fungsiUpdateOneRequiredWithoutHak_aksesNestedInput = {
    create?: XOR<fungsiCreateWithoutHak_aksesInput, fungsiUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: fungsiCreateOrConnectWithoutHak_aksesInput
    upsert?: fungsiUpsertWithoutHak_aksesInput
    connect?: fungsiWhereUniqueInput
    update?: XOR<XOR<fungsiUpdateToOneWithWhereWithoutHak_aksesInput, fungsiUpdateWithoutHak_aksesInput>, fungsiUncheckedUpdateWithoutHak_aksesInput>
  }

  export type aksesUpdateOneRequiredWithoutHak_aksesNestedInput = {
    create?: XOR<aksesCreateWithoutHak_aksesInput, aksesUncheckedCreateWithoutHak_aksesInput>
    connectOrCreate?: aksesCreateOrConnectWithoutHak_aksesInput
    upsert?: aksesUpsertWithoutHak_aksesInput
    connect?: aksesWhereUniqueInput
    update?: XOR<XOR<aksesUpdateToOneWithWhereWithoutHak_aksesInput, aksesUpdateWithoutHak_aksesInput>, aksesUncheckedUpdateWithoutHak_aksesInput>
  }

  export type kategori_produkCreateNestedOneWithoutModel_produkInput = {
    create?: XOR<kategori_produkCreateWithoutModel_produkInput, kategori_produkUncheckedCreateWithoutModel_produkInput>
    connectOrCreate?: kategori_produkCreateOrConnectWithoutModel_produkInput
    connect?: kategori_produkWhereUniqueInput
  }

  export type foto_produkCreateNestedManyWithoutModel_produkInput = {
    create?: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput> | foto_produkCreateWithoutModel_produkInput[] | foto_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: foto_produkCreateOrConnectWithoutModel_produkInput | foto_produkCreateOrConnectWithoutModel_produkInput[]
    createMany?: foto_produkCreateManyModel_produkInputEnvelope
    connect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
  }

  export type detail_model_produkCreateNestedManyWithoutModel_produkInput = {
    create?: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput> | detail_model_produkCreateWithoutModel_produkInput[] | detail_model_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutModel_produkInput | detail_model_produkCreateOrConnectWithoutModel_produkInput[]
    createMany?: detail_model_produkCreateManyModel_produkInputEnvelope
    connect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
  }

  export type foto_produkUncheckedCreateNestedManyWithoutModel_produkInput = {
    create?: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput> | foto_produkCreateWithoutModel_produkInput[] | foto_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: foto_produkCreateOrConnectWithoutModel_produkInput | foto_produkCreateOrConnectWithoutModel_produkInput[]
    createMany?: foto_produkCreateManyModel_produkInputEnvelope
    connect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
  }

  export type detail_model_produkUncheckedCreateNestedManyWithoutModel_produkInput = {
    create?: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput> | detail_model_produkCreateWithoutModel_produkInput[] | detail_model_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutModel_produkInput | detail_model_produkCreateOrConnectWithoutModel_produkInput[]
    createMany?: detail_model_produkCreateManyModel_produkInputEnvelope
    connect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type kategori_produkUpdateOneRequiredWithoutModel_produkNestedInput = {
    create?: XOR<kategori_produkCreateWithoutModel_produkInput, kategori_produkUncheckedCreateWithoutModel_produkInput>
    connectOrCreate?: kategori_produkCreateOrConnectWithoutModel_produkInput
    upsert?: kategori_produkUpsertWithoutModel_produkInput
    connect?: kategori_produkWhereUniqueInput
    update?: XOR<XOR<kategori_produkUpdateToOneWithWhereWithoutModel_produkInput, kategori_produkUpdateWithoutModel_produkInput>, kategori_produkUncheckedUpdateWithoutModel_produkInput>
  }

  export type foto_produkUpdateManyWithoutModel_produkNestedInput = {
    create?: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput> | foto_produkCreateWithoutModel_produkInput[] | foto_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: foto_produkCreateOrConnectWithoutModel_produkInput | foto_produkCreateOrConnectWithoutModel_produkInput[]
    upsert?: foto_produkUpsertWithWhereUniqueWithoutModel_produkInput | foto_produkUpsertWithWhereUniqueWithoutModel_produkInput[]
    createMany?: foto_produkCreateManyModel_produkInputEnvelope
    set?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    disconnect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    delete?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    connect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    update?: foto_produkUpdateWithWhereUniqueWithoutModel_produkInput | foto_produkUpdateWithWhereUniqueWithoutModel_produkInput[]
    updateMany?: foto_produkUpdateManyWithWhereWithoutModel_produkInput | foto_produkUpdateManyWithWhereWithoutModel_produkInput[]
    deleteMany?: foto_produkScalarWhereInput | foto_produkScalarWhereInput[]
  }

  export type detail_model_produkUpdateManyWithoutModel_produkNestedInput = {
    create?: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput> | detail_model_produkCreateWithoutModel_produkInput[] | detail_model_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutModel_produkInput | detail_model_produkCreateOrConnectWithoutModel_produkInput[]
    upsert?: detail_model_produkUpsertWithWhereUniqueWithoutModel_produkInput | detail_model_produkUpsertWithWhereUniqueWithoutModel_produkInput[]
    createMany?: detail_model_produkCreateManyModel_produkInputEnvelope
    set?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    disconnect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    delete?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    connect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    update?: detail_model_produkUpdateWithWhereUniqueWithoutModel_produkInput | detail_model_produkUpdateWithWhereUniqueWithoutModel_produkInput[]
    updateMany?: detail_model_produkUpdateManyWithWhereWithoutModel_produkInput | detail_model_produkUpdateManyWithWhereWithoutModel_produkInput[]
    deleteMany?: detail_model_produkScalarWhereInput | detail_model_produkScalarWhereInput[]
  }

  export type foto_produkUncheckedUpdateManyWithoutModel_produkNestedInput = {
    create?: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput> | foto_produkCreateWithoutModel_produkInput[] | foto_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: foto_produkCreateOrConnectWithoutModel_produkInput | foto_produkCreateOrConnectWithoutModel_produkInput[]
    upsert?: foto_produkUpsertWithWhereUniqueWithoutModel_produkInput | foto_produkUpsertWithWhereUniqueWithoutModel_produkInput[]
    createMany?: foto_produkCreateManyModel_produkInputEnvelope
    set?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    disconnect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    delete?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    connect?: foto_produkWhereUniqueInput | foto_produkWhereUniqueInput[]
    update?: foto_produkUpdateWithWhereUniqueWithoutModel_produkInput | foto_produkUpdateWithWhereUniqueWithoutModel_produkInput[]
    updateMany?: foto_produkUpdateManyWithWhereWithoutModel_produkInput | foto_produkUpdateManyWithWhereWithoutModel_produkInput[]
    deleteMany?: foto_produkScalarWhereInput | foto_produkScalarWhereInput[]
  }

  export type detail_model_produkUncheckedUpdateManyWithoutModel_produkNestedInput = {
    create?: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput> | detail_model_produkCreateWithoutModel_produkInput[] | detail_model_produkUncheckedCreateWithoutModel_produkInput[]
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutModel_produkInput | detail_model_produkCreateOrConnectWithoutModel_produkInput[]
    upsert?: detail_model_produkUpsertWithWhereUniqueWithoutModel_produkInput | detail_model_produkUpsertWithWhereUniqueWithoutModel_produkInput[]
    createMany?: detail_model_produkCreateManyModel_produkInputEnvelope
    set?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    disconnect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    delete?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    connect?: detail_model_produkWhereUniqueInput | detail_model_produkWhereUniqueInput[]
    update?: detail_model_produkUpdateWithWhereUniqueWithoutModel_produkInput | detail_model_produkUpdateWithWhereUniqueWithoutModel_produkInput[]
    updateMany?: detail_model_produkUpdateManyWithWhereWithoutModel_produkInput | detail_model_produkUpdateManyWithWhereWithoutModel_produkInput[]
    deleteMany?: detail_model_produkScalarWhereInput | detail_model_produkScalarWhereInput[]
  }

  export type model_produkCreateNestedOneWithoutFoto_produkInput = {
    create?: XOR<model_produkCreateWithoutFoto_produkInput, model_produkUncheckedCreateWithoutFoto_produkInput>
    connectOrCreate?: model_produkCreateOrConnectWithoutFoto_produkInput
    connect?: model_produkWhereUniqueInput
  }

  export type model_produkUpdateOneRequiredWithoutFoto_produkNestedInput = {
    create?: XOR<model_produkCreateWithoutFoto_produkInput, model_produkUncheckedCreateWithoutFoto_produkInput>
    connectOrCreate?: model_produkCreateOrConnectWithoutFoto_produkInput
    upsert?: model_produkUpsertWithoutFoto_produkInput
    connect?: model_produkWhereUniqueInput
    update?: XOR<XOR<model_produkUpdateToOneWithWhereWithoutFoto_produkInput, model_produkUpdateWithoutFoto_produkInput>, model_produkUncheckedUpdateWithoutFoto_produkInput>
  }

  export type model_produkCreateNestedManyWithoutKategoriInput = {
    create?: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput> | model_produkCreateWithoutKategoriInput[] | model_produkUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: model_produkCreateOrConnectWithoutKategoriInput | model_produkCreateOrConnectWithoutKategoriInput[]
    createMany?: model_produkCreateManyKategoriInputEnvelope
    connect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
  }

  export type model_produkUncheckedCreateNestedManyWithoutKategoriInput = {
    create?: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput> | model_produkCreateWithoutKategoriInput[] | model_produkUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: model_produkCreateOrConnectWithoutKategoriInput | model_produkCreateOrConnectWithoutKategoriInput[]
    createMany?: model_produkCreateManyKategoriInputEnvelope
    connect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
  }

  export type model_produkUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput> | model_produkCreateWithoutKategoriInput[] | model_produkUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: model_produkCreateOrConnectWithoutKategoriInput | model_produkCreateOrConnectWithoutKategoriInput[]
    upsert?: model_produkUpsertWithWhereUniqueWithoutKategoriInput | model_produkUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: model_produkCreateManyKategoriInputEnvelope
    set?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    disconnect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    delete?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    connect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    update?: model_produkUpdateWithWhereUniqueWithoutKategoriInput | model_produkUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: model_produkUpdateManyWithWhereWithoutKategoriInput | model_produkUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: model_produkScalarWhereInput | model_produkScalarWhereInput[]
  }

  export type model_produkUncheckedUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput> | model_produkCreateWithoutKategoriInput[] | model_produkUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: model_produkCreateOrConnectWithoutKategoriInput | model_produkCreateOrConnectWithoutKategoriInput[]
    upsert?: model_produkUpsertWithWhereUniqueWithoutKategoriInput | model_produkUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: model_produkCreateManyKategoriInputEnvelope
    set?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    disconnect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    delete?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    connect?: model_produkWhereUniqueInput | model_produkWhereUniqueInput[]
    update?: model_produkUpdateWithWhereUniqueWithoutKategoriInput | model_produkUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: model_produkUpdateManyWithWhereWithoutKategoriInput | model_produkUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: model_produkScalarWhereInput | model_produkScalarWhereInput[]
  }

  export type model_produkCreateNestedOneWithoutDetail_model_produkInput = {
    create?: XOR<model_produkCreateWithoutDetail_model_produkInput, model_produkUncheckedCreateWithoutDetail_model_produkInput>
    connectOrCreate?: model_produkCreateOrConnectWithoutDetail_model_produkInput
    connect?: model_produkWhereUniqueInput
  }

  export type bahan_produkCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput> | bahan_produkCreateWithoutDetail_model_produkInput[] | bahan_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDetail_model_produkInput | bahan_produkCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: bahan_produkCreateManyDetail_model_produkInputEnvelope
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
  }

  export type daftar_produkCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput> | daftar_produkCreateWithoutDetail_model_produkInput[] | daftar_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: daftar_produkCreateOrConnectWithoutDetail_model_produkInput | daftar_produkCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: daftar_produkCreateManyDetail_model_produkInputEnvelope
    connect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
  }

  export type produksiCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput> | produksiCreateWithoutDetail_model_produkInput[] | produksiUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutDetail_model_produkInput | produksiCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: produksiCreateManyDetail_model_produkInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type bahan_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput> | bahan_produkCreateWithoutDetail_model_produkInput[] | bahan_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDetail_model_produkInput | bahan_produkCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: bahan_produkCreateManyDetail_model_produkInputEnvelope
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
  }

  export type daftar_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput> | daftar_produkCreateWithoutDetail_model_produkInput[] | daftar_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: daftar_produkCreateOrConnectWithoutDetail_model_produkInput | daftar_produkCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: daftar_produkCreateManyDetail_model_produkInputEnvelope
    connect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
  }

  export type produksiUncheckedCreateNestedManyWithoutDetail_model_produkInput = {
    create?: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput> | produksiCreateWithoutDetail_model_produkInput[] | produksiUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutDetail_model_produkInput | produksiCreateOrConnectWithoutDetail_model_produkInput[]
    createMany?: produksiCreateManyDetail_model_produkInputEnvelope
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type model_produkUpdateOneRequiredWithoutDetail_model_produkNestedInput = {
    create?: XOR<model_produkCreateWithoutDetail_model_produkInput, model_produkUncheckedCreateWithoutDetail_model_produkInput>
    connectOrCreate?: model_produkCreateOrConnectWithoutDetail_model_produkInput
    upsert?: model_produkUpsertWithoutDetail_model_produkInput
    connect?: model_produkWhereUniqueInput
    update?: XOR<XOR<model_produkUpdateToOneWithWhereWithoutDetail_model_produkInput, model_produkUpdateWithoutDetail_model_produkInput>, model_produkUncheckedUpdateWithoutDetail_model_produkInput>
  }

  export type bahan_produkUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput> | bahan_produkCreateWithoutDetail_model_produkInput[] | bahan_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDetail_model_produkInput | bahan_produkCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: bahan_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput | bahan_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: bahan_produkCreateManyDetail_model_produkInputEnvelope
    set?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    disconnect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    delete?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    update?: bahan_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput | bahan_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: bahan_produkUpdateManyWithWhereWithoutDetail_model_produkInput | bahan_produkUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
  }

  export type daftar_produkUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput> | daftar_produkCreateWithoutDetail_model_produkInput[] | daftar_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: daftar_produkCreateOrConnectWithoutDetail_model_produkInput | daftar_produkCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: daftar_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput | daftar_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: daftar_produkCreateManyDetail_model_produkInputEnvelope
    set?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    disconnect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    delete?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    connect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    update?: daftar_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput | daftar_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: daftar_produkUpdateManyWithWhereWithoutDetail_model_produkInput | daftar_produkUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: daftar_produkScalarWhereInput | daftar_produkScalarWhereInput[]
  }

  export type produksiUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput> | produksiCreateWithoutDetail_model_produkInput[] | produksiUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutDetail_model_produkInput | produksiCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutDetail_model_produkInput | produksiUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: produksiCreateManyDetail_model_produkInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutDetail_model_produkInput | produksiUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutDetail_model_produkInput | produksiUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type bahan_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput> | bahan_produkCreateWithoutDetail_model_produkInput[] | bahan_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDetail_model_produkInput | bahan_produkCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: bahan_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput | bahan_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: bahan_produkCreateManyDetail_model_produkInputEnvelope
    set?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    disconnect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    delete?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    update?: bahan_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput | bahan_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: bahan_produkUpdateManyWithWhereWithoutDetail_model_produkInput | bahan_produkUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
  }

  export type daftar_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput> | daftar_produkCreateWithoutDetail_model_produkInput[] | daftar_produkUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: daftar_produkCreateOrConnectWithoutDetail_model_produkInput | daftar_produkCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: daftar_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput | daftar_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: daftar_produkCreateManyDetail_model_produkInputEnvelope
    set?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    disconnect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    delete?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    connect?: daftar_produkWhereUniqueInput | daftar_produkWhereUniqueInput[]
    update?: daftar_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput | daftar_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: daftar_produkUpdateManyWithWhereWithoutDetail_model_produkInput | daftar_produkUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: daftar_produkScalarWhereInput | daftar_produkScalarWhereInput[]
  }

  export type produksiUncheckedUpdateManyWithoutDetail_model_produkNestedInput = {
    create?: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput> | produksiCreateWithoutDetail_model_produkInput[] | produksiUncheckedCreateWithoutDetail_model_produkInput[]
    connectOrCreate?: produksiCreateOrConnectWithoutDetail_model_produkInput | produksiCreateOrConnectWithoutDetail_model_produkInput[]
    upsert?: produksiUpsertWithWhereUniqueWithoutDetail_model_produkInput | produksiUpsertWithWhereUniqueWithoutDetail_model_produkInput[]
    createMany?: produksiCreateManyDetail_model_produkInputEnvelope
    set?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    disconnect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    delete?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    connect?: produksiWhereUniqueInput | produksiWhereUniqueInput[]
    update?: produksiUpdateWithWhereUniqueWithoutDetail_model_produkInput | produksiUpdateWithWhereUniqueWithoutDetail_model_produkInput[]
    updateMany?: produksiUpdateManyWithWhereWithoutDetail_model_produkInput | produksiUpdateManyWithWhereWithoutDetail_model_produkInput[]
    deleteMany?: produksiScalarWhereInput | produksiScalarWhereInput[]
  }

  export type detail_model_produkCreateNestedOneWithoutBahan_produkInput = {
    create?: XOR<detail_model_produkCreateWithoutBahan_produkInput, detail_model_produkUncheckedCreateWithoutBahan_produkInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutBahan_produkInput
    connect?: detail_model_produkWhereUniqueInput
  }

  export type daftar_bahanCreateNestedOneWithoutBahan_produkInput = {
    create?: XOR<daftar_bahanCreateWithoutBahan_produkInput, daftar_bahanUncheckedCreateWithoutBahan_produkInput>
    connectOrCreate?: daftar_bahanCreateOrConnectWithoutBahan_produkInput
    connect?: daftar_bahanWhereUniqueInput
  }

  export type detail_model_produkUpdateOneRequiredWithoutBahan_produkNestedInput = {
    create?: XOR<detail_model_produkCreateWithoutBahan_produkInput, detail_model_produkUncheckedCreateWithoutBahan_produkInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutBahan_produkInput
    upsert?: detail_model_produkUpsertWithoutBahan_produkInput
    connect?: detail_model_produkWhereUniqueInput
    update?: XOR<XOR<detail_model_produkUpdateToOneWithWhereWithoutBahan_produkInput, detail_model_produkUpdateWithoutBahan_produkInput>, detail_model_produkUncheckedUpdateWithoutBahan_produkInput>
  }

  export type daftar_bahanUpdateOneRequiredWithoutBahan_produkNestedInput = {
    create?: XOR<daftar_bahanCreateWithoutBahan_produkInput, daftar_bahanUncheckedCreateWithoutBahan_produkInput>
    connectOrCreate?: daftar_bahanCreateOrConnectWithoutBahan_produkInput
    upsert?: daftar_bahanUpsertWithoutBahan_produkInput
    connect?: daftar_bahanWhereUniqueInput
    update?: XOR<XOR<daftar_bahanUpdateToOneWithWhereWithoutBahan_produkInput, daftar_bahanUpdateWithoutBahan_produkInput>, daftar_bahanUncheckedUpdateWithoutBahan_produkInput>
  }

  export type bahan_produkCreateNestedManyWithoutDaftar_bahanInput = {
    create?: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput> | bahan_produkCreateWithoutDaftar_bahanInput[] | bahan_produkUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDaftar_bahanInput | bahan_produkCreateOrConnectWithoutDaftar_bahanInput[]
    createMany?: bahan_produkCreateManyDaftar_bahanInputEnvelope
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
  }

  export type restok_bahanCreateNestedManyWithoutDaftar_bahanInput = {
    create?: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput> | restok_bahanCreateWithoutDaftar_bahanInput[] | restok_bahanUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutDaftar_bahanInput | restok_bahanCreateOrConnectWithoutDaftar_bahanInput[]
    createMany?: restok_bahanCreateManyDaftar_bahanInputEnvelope
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
  }

  export type bahan_produkUncheckedCreateNestedManyWithoutDaftar_bahanInput = {
    create?: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput> | bahan_produkCreateWithoutDaftar_bahanInput[] | bahan_produkUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDaftar_bahanInput | bahan_produkCreateOrConnectWithoutDaftar_bahanInput[]
    createMany?: bahan_produkCreateManyDaftar_bahanInputEnvelope
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
  }

  export type restok_bahanUncheckedCreateNestedManyWithoutDaftar_bahanInput = {
    create?: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput> | restok_bahanCreateWithoutDaftar_bahanInput[] | restok_bahanUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutDaftar_bahanInput | restok_bahanCreateOrConnectWithoutDaftar_bahanInput[]
    createMany?: restok_bahanCreateManyDaftar_bahanInputEnvelope
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
  }

  export type bahan_produkUpdateManyWithoutDaftar_bahanNestedInput = {
    create?: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput> | bahan_produkCreateWithoutDaftar_bahanInput[] | bahan_produkUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDaftar_bahanInput | bahan_produkCreateOrConnectWithoutDaftar_bahanInput[]
    upsert?: bahan_produkUpsertWithWhereUniqueWithoutDaftar_bahanInput | bahan_produkUpsertWithWhereUniqueWithoutDaftar_bahanInput[]
    createMany?: bahan_produkCreateManyDaftar_bahanInputEnvelope
    set?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    disconnect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    delete?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    update?: bahan_produkUpdateWithWhereUniqueWithoutDaftar_bahanInput | bahan_produkUpdateWithWhereUniqueWithoutDaftar_bahanInput[]
    updateMany?: bahan_produkUpdateManyWithWhereWithoutDaftar_bahanInput | bahan_produkUpdateManyWithWhereWithoutDaftar_bahanInput[]
    deleteMany?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
  }

  export type restok_bahanUpdateManyWithoutDaftar_bahanNestedInput = {
    create?: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput> | restok_bahanCreateWithoutDaftar_bahanInput[] | restok_bahanUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutDaftar_bahanInput | restok_bahanCreateOrConnectWithoutDaftar_bahanInput[]
    upsert?: restok_bahanUpsertWithWhereUniqueWithoutDaftar_bahanInput | restok_bahanUpsertWithWhereUniqueWithoutDaftar_bahanInput[]
    createMany?: restok_bahanCreateManyDaftar_bahanInputEnvelope
    set?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    disconnect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    delete?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    update?: restok_bahanUpdateWithWhereUniqueWithoutDaftar_bahanInput | restok_bahanUpdateWithWhereUniqueWithoutDaftar_bahanInput[]
    updateMany?: restok_bahanUpdateManyWithWhereWithoutDaftar_bahanInput | restok_bahanUpdateManyWithWhereWithoutDaftar_bahanInput[]
    deleteMany?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
  }

  export type bahan_produkUncheckedUpdateManyWithoutDaftar_bahanNestedInput = {
    create?: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput> | bahan_produkCreateWithoutDaftar_bahanInput[] | bahan_produkUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: bahan_produkCreateOrConnectWithoutDaftar_bahanInput | bahan_produkCreateOrConnectWithoutDaftar_bahanInput[]
    upsert?: bahan_produkUpsertWithWhereUniqueWithoutDaftar_bahanInput | bahan_produkUpsertWithWhereUniqueWithoutDaftar_bahanInput[]
    createMany?: bahan_produkCreateManyDaftar_bahanInputEnvelope
    set?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    disconnect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    delete?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    connect?: bahan_produkWhereUniqueInput | bahan_produkWhereUniqueInput[]
    update?: bahan_produkUpdateWithWhereUniqueWithoutDaftar_bahanInput | bahan_produkUpdateWithWhereUniqueWithoutDaftar_bahanInput[]
    updateMany?: bahan_produkUpdateManyWithWhereWithoutDaftar_bahanInput | bahan_produkUpdateManyWithWhereWithoutDaftar_bahanInput[]
    deleteMany?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
  }

  export type restok_bahanUncheckedUpdateManyWithoutDaftar_bahanNestedInput = {
    create?: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput> | restok_bahanCreateWithoutDaftar_bahanInput[] | restok_bahanUncheckedCreateWithoutDaftar_bahanInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutDaftar_bahanInput | restok_bahanCreateOrConnectWithoutDaftar_bahanInput[]
    upsert?: restok_bahanUpsertWithWhereUniqueWithoutDaftar_bahanInput | restok_bahanUpsertWithWhereUniqueWithoutDaftar_bahanInput[]
    createMany?: restok_bahanCreateManyDaftar_bahanInputEnvelope
    set?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    disconnect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    delete?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    update?: restok_bahanUpdateWithWhereUniqueWithoutDaftar_bahanInput | restok_bahanUpdateWithWhereUniqueWithoutDaftar_bahanInput[]
    updateMany?: restok_bahanUpdateManyWithWhereWithoutDaftar_bahanInput | restok_bahanUpdateManyWithWhereWithoutDaftar_bahanInput[]
    deleteMany?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
  }

  export type daftar_bahanCreateNestedOneWithoutRestok_bahanInput = {
    create?: XOR<daftar_bahanCreateWithoutRestok_bahanInput, daftar_bahanUncheckedCreateWithoutRestok_bahanInput>
    connectOrCreate?: daftar_bahanCreateOrConnectWithoutRestok_bahanInput
    connect?: daftar_bahanWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutRestok_bahanInput = {
    create?: XOR<supplierCreateWithoutRestok_bahanInput, supplierUncheckedCreateWithoutRestok_bahanInput>
    connectOrCreate?: supplierCreateOrConnectWithoutRestok_bahanInput
    connect?: supplierWhereUniqueInput
  }

  export type daftar_bahanUpdateOneRequiredWithoutRestok_bahanNestedInput = {
    create?: XOR<daftar_bahanCreateWithoutRestok_bahanInput, daftar_bahanUncheckedCreateWithoutRestok_bahanInput>
    connectOrCreate?: daftar_bahanCreateOrConnectWithoutRestok_bahanInput
    upsert?: daftar_bahanUpsertWithoutRestok_bahanInput
    connect?: daftar_bahanWhereUniqueInput
    update?: XOR<XOR<daftar_bahanUpdateToOneWithWhereWithoutRestok_bahanInput, daftar_bahanUpdateWithoutRestok_bahanInput>, daftar_bahanUncheckedUpdateWithoutRestok_bahanInput>
  }

  export type supplierUpdateOneRequiredWithoutRestok_bahanNestedInput = {
    create?: XOR<supplierCreateWithoutRestok_bahanInput, supplierUncheckedCreateWithoutRestok_bahanInput>
    connectOrCreate?: supplierCreateOrConnectWithoutRestok_bahanInput
    upsert?: supplierUpsertWithoutRestok_bahanInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutRestok_bahanInput, supplierUpdateWithoutRestok_bahanInput>, supplierUncheckedUpdateWithoutRestok_bahanInput>
  }

  export type restok_bahanCreateNestedManyWithoutSupplierInput = {
    create?: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput> | restok_bahanCreateWithoutSupplierInput[] | restok_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutSupplierInput | restok_bahanCreateOrConnectWithoutSupplierInput[]
    createMany?: restok_bahanCreateManySupplierInputEnvelope
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
  }

  export type restok_bahanUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput> | restok_bahanCreateWithoutSupplierInput[] | restok_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutSupplierInput | restok_bahanCreateOrConnectWithoutSupplierInput[]
    createMany?: restok_bahanCreateManySupplierInputEnvelope
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
  }

  export type restok_bahanUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput> | restok_bahanCreateWithoutSupplierInput[] | restok_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutSupplierInput | restok_bahanCreateOrConnectWithoutSupplierInput[]
    upsert?: restok_bahanUpsertWithWhereUniqueWithoutSupplierInput | restok_bahanUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: restok_bahanCreateManySupplierInputEnvelope
    set?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    disconnect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    delete?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    update?: restok_bahanUpdateWithWhereUniqueWithoutSupplierInput | restok_bahanUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: restok_bahanUpdateManyWithWhereWithoutSupplierInput | restok_bahanUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
  }

  export type restok_bahanUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput> | restok_bahanCreateWithoutSupplierInput[] | restok_bahanUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: restok_bahanCreateOrConnectWithoutSupplierInput | restok_bahanCreateOrConnectWithoutSupplierInput[]
    upsert?: restok_bahanUpsertWithWhereUniqueWithoutSupplierInput | restok_bahanUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: restok_bahanCreateManySupplierInputEnvelope
    set?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    disconnect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    delete?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    connect?: restok_bahanWhereUniqueInput | restok_bahanWhereUniqueInput[]
    update?: restok_bahanUpdateWithWhereUniqueWithoutSupplierInput | restok_bahanUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: restok_bahanUpdateManyWithWhereWithoutSupplierInput | restok_bahanUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
  }

  export type detail_model_produkCreateNestedOneWithoutProduksiInput = {
    create?: XOR<detail_model_produkCreateWithoutProduksiInput, detail_model_produkUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutProduksiInput
    connect?: detail_model_produkWhereUniqueInput
  }

  export type userCreateNestedOneWithoutProduksiInput = {
    create?: XOR<userCreateWithoutProduksiInput, userUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: userCreateOrConnectWithoutProduksiInput
    connect?: userWhereUniqueInput
  }

  export type qcproduksiCreateNestedManyWithoutProduksiInput = {
    create?: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput> | qcproduksiCreateWithoutProduksiInput[] | qcproduksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutProduksiInput | qcproduksiCreateOrConnectWithoutProduksiInput[]
    createMany?: qcproduksiCreateManyProduksiInputEnvelope
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
  }

  export type qcproduksiUncheckedCreateNestedManyWithoutProduksiInput = {
    create?: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput> | qcproduksiCreateWithoutProduksiInput[] | qcproduksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutProduksiInput | qcproduksiCreateOrConnectWithoutProduksiInput[]
    createMany?: qcproduksiCreateManyProduksiInputEnvelope
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
  }

  export type detail_model_produkUpdateOneRequiredWithoutProduksiNestedInput = {
    create?: XOR<detail_model_produkCreateWithoutProduksiInput, detail_model_produkUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutProduksiInput
    upsert?: detail_model_produkUpsertWithoutProduksiInput
    connect?: detail_model_produkWhereUniqueInput
    update?: XOR<XOR<detail_model_produkUpdateToOneWithWhereWithoutProduksiInput, detail_model_produkUpdateWithoutProduksiInput>, detail_model_produkUncheckedUpdateWithoutProduksiInput>
  }

  export type userUpdateOneRequiredWithoutProduksiNestedInput = {
    create?: XOR<userCreateWithoutProduksiInput, userUncheckedCreateWithoutProduksiInput>
    connectOrCreate?: userCreateOrConnectWithoutProduksiInput
    upsert?: userUpsertWithoutProduksiInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProduksiInput, userUpdateWithoutProduksiInput>, userUncheckedUpdateWithoutProduksiInput>
  }

  export type qcproduksiUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput> | qcproduksiCreateWithoutProduksiInput[] | qcproduksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutProduksiInput | qcproduksiCreateOrConnectWithoutProduksiInput[]
    upsert?: qcproduksiUpsertWithWhereUniqueWithoutProduksiInput | qcproduksiUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: qcproduksiCreateManyProduksiInputEnvelope
    set?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    disconnect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    delete?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    update?: qcproduksiUpdateWithWhereUniqueWithoutProduksiInput | qcproduksiUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: qcproduksiUpdateManyWithWhereWithoutProduksiInput | qcproduksiUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
  }

  export type qcproduksiUncheckedUpdateManyWithoutProduksiNestedInput = {
    create?: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput> | qcproduksiCreateWithoutProduksiInput[] | qcproduksiUncheckedCreateWithoutProduksiInput[]
    connectOrCreate?: qcproduksiCreateOrConnectWithoutProduksiInput | qcproduksiCreateOrConnectWithoutProduksiInput[]
    upsert?: qcproduksiUpsertWithWhereUniqueWithoutProduksiInput | qcproduksiUpsertWithWhereUniqueWithoutProduksiInput[]
    createMany?: qcproduksiCreateManyProduksiInputEnvelope
    set?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    disconnect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    delete?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    connect?: qcproduksiWhereUniqueInput | qcproduksiWhereUniqueInput[]
    update?: qcproduksiUpdateWithWhereUniqueWithoutProduksiInput | qcproduksiUpdateWithWhereUniqueWithoutProduksiInput[]
    updateMany?: qcproduksiUpdateManyWithWhereWithoutProduksiInput | qcproduksiUpdateManyWithWhereWithoutProduksiInput[]
    deleteMany?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutQcproduksiInput = {
    create?: XOR<userCreateWithoutQcproduksiInput, userUncheckedCreateWithoutQcproduksiInput>
    connectOrCreate?: userCreateOrConnectWithoutQcproduksiInput
    connect?: userWhereUniqueInput
  }

  export type produksiCreateNestedOneWithoutQcproduksiInput = {
    create?: XOR<produksiCreateWithoutQcproduksiInput, produksiUncheckedCreateWithoutQcproduksiInput>
    connectOrCreate?: produksiCreateOrConnectWithoutQcproduksiInput
    connect?: produksiWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutQcproduksiNestedInput = {
    create?: XOR<userCreateWithoutQcproduksiInput, userUncheckedCreateWithoutQcproduksiInput>
    connectOrCreate?: userCreateOrConnectWithoutQcproduksiInput
    upsert?: userUpsertWithoutQcproduksiInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutQcproduksiInput, userUpdateWithoutQcproduksiInput>, userUncheckedUpdateWithoutQcproduksiInput>
  }

  export type produksiUpdateOneRequiredWithoutQcproduksiNestedInput = {
    create?: XOR<produksiCreateWithoutQcproduksiInput, produksiUncheckedCreateWithoutQcproduksiInput>
    connectOrCreate?: produksiCreateOrConnectWithoutQcproduksiInput
    upsert?: produksiUpsertWithoutQcproduksiInput
    connect?: produksiWhereUniqueInput
    update?: XOR<XOR<produksiUpdateToOneWithWhereWithoutQcproduksiInput, produksiUpdateWithoutQcproduksiInput>, produksiUncheckedUpdateWithoutQcproduksiInput>
  }

  export type detail_model_produkCreateNestedOneWithoutDaftar_produkInput = {
    create?: XOR<detail_model_produkCreateWithoutDaftar_produkInput, detail_model_produkUncheckedCreateWithoutDaftar_produkInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutDaftar_produkInput
    connect?: detail_model_produkWhereUniqueInput
  }

  export type detail_model_produkUpdateOneRequiredWithoutDaftar_produkNestedInput = {
    create?: XOR<detail_model_produkCreateWithoutDaftar_produkInput, detail_model_produkUncheckedCreateWithoutDaftar_produkInput>
    connectOrCreate?: detail_model_produkCreateOrConnectWithoutDaftar_produkInput
    upsert?: detail_model_produkUpsertWithoutDaftar_produkInput
    connect?: detail_model_produkWhereUniqueInput
    update?: XOR<XOR<detail_model_produkUpdateToOneWithWhereWithoutDaftar_produkInput, detail_model_produkUpdateWithoutDaftar_produkInput>, detail_model_produkUncheckedUpdateWithoutDaftar_produkInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type karyawanCreateWithoutUsersInput = {
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date | string
    jenis_kelamin: string
    no_rekening: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type karyawanUncheckedCreateWithoutUsersInput = {
    id?: number
    nama: string
    nik: string
    alamat: string
    kontak: string
    tanggal_lahir: Date | string
    jenis_kelamin: string
    no_rekening: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type karyawanCreateOrConnectWithoutUsersInput = {
    where: karyawanWhereUniqueInput
    create: XOR<karyawanCreateWithoutUsersInput, karyawanUncheckedCreateWithoutUsersInput>
  }

  export type roleCreateWithoutUsersInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUsersInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    hak_akses?: hak_aksesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUsersInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
  }

  export type produksiCreateWithoutUserInput = {
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutProduksiInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutUserInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutUserInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput>
  }

  export type produksiCreateManyUserInputEnvelope = {
    data: produksiCreateManyUserInput | produksiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type qcproduksiCreateWithoutUserInput = {
    waktu?: Date | string
    deskripsi: string
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    produksi: produksiCreateNestedOneWithoutQcproduksiInput
  }

  export type qcproduksiUncheckedCreateWithoutUserInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    produksi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiCreateOrConnectWithoutUserInput = {
    where: qcproduksiWhereUniqueInput
    create: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput>
  }

  export type qcproduksiCreateManyUserInputEnvelope = {
    data: qcproduksiCreateManyUserInput | qcproduksiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type karyawanUpsertWithoutUsersInput = {
    update: XOR<karyawanUpdateWithoutUsersInput, karyawanUncheckedUpdateWithoutUsersInput>
    create: XOR<karyawanCreateWithoutUsersInput, karyawanUncheckedCreateWithoutUsersInput>
    where?: karyawanWhereInput
  }

  export type karyawanUpdateToOneWithWhereWithoutUsersInput = {
    where?: karyawanWhereInput
    data: XOR<karyawanUpdateWithoutUsersInput, karyawanUncheckedUpdateWithoutUsersInput>
  }

  export type karyawanUpdateWithoutUsersInput = {
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type karyawanUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    tanggal_lahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis_kelamin?: StringFieldUpdateOperationsInput | string
    no_rekening?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleUpsertWithoutUsersInput = {
    update: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUsersInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
  }

  export type roleUpdateWithoutUsersInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hak_akses?: hak_aksesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type produksiUpsertWithWhereUniqueWithoutUserInput = {
    where: produksiWhereUniqueInput
    update: XOR<produksiUpdateWithoutUserInput, produksiUncheckedUpdateWithoutUserInput>
    create: XOR<produksiCreateWithoutUserInput, produksiUncheckedCreateWithoutUserInput>
  }

  export type produksiUpdateWithWhereUniqueWithoutUserInput = {
    where: produksiWhereUniqueInput
    data: XOR<produksiUpdateWithoutUserInput, produksiUncheckedUpdateWithoutUserInput>
  }

  export type produksiUpdateManyWithWhereWithoutUserInput = {
    where: produksiScalarWhereInput
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyWithoutUserInput>
  }

  export type produksiScalarWhereInput = {
    AND?: produksiScalarWhereInput | produksiScalarWhereInput[]
    OR?: produksiScalarWhereInput[]
    NOT?: produksiScalarWhereInput | produksiScalarWhereInput[]
    id?: IntFilter<"produksi"> | number
    produksi?: StringFilter<"produksi"> | string
    tanggal_mulai?: DateTimeFilter<"produksi"> | Date | string
    tanggal_selesai?: DateTimeNullableFilter<"produksi"> | Date | string | null
    jumlah?: IntFilter<"produksi"> | number
    detail_model_produk_id?: IntFilter<"produksi"> | number
    user_id?: IntFilter<"produksi"> | number
    created_at?: DateTimeFilter<"produksi"> | Date | string
    updated_at?: DateTimeFilter<"produksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"produksi"> | Date | string | null
  }

  export type qcproduksiUpsertWithWhereUniqueWithoutUserInput = {
    where: qcproduksiWhereUniqueInput
    update: XOR<qcproduksiUpdateWithoutUserInput, qcproduksiUncheckedUpdateWithoutUserInput>
    create: XOR<qcproduksiCreateWithoutUserInput, qcproduksiUncheckedCreateWithoutUserInput>
  }

  export type qcproduksiUpdateWithWhereUniqueWithoutUserInput = {
    where: qcproduksiWhereUniqueInput
    data: XOR<qcproduksiUpdateWithoutUserInput, qcproduksiUncheckedUpdateWithoutUserInput>
  }

  export type qcproduksiUpdateManyWithWhereWithoutUserInput = {
    where: qcproduksiScalarWhereInput
    data: XOR<qcproduksiUpdateManyMutationInput, qcproduksiUncheckedUpdateManyWithoutUserInput>
  }

  export type qcproduksiScalarWhereInput = {
    AND?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
    OR?: qcproduksiScalarWhereInput[]
    NOT?: qcproduksiScalarWhereInput | qcproduksiScalarWhereInput[]
    id?: IntFilter<"qcproduksi"> | number
    waktu?: DateTimeFilter<"qcproduksi"> | Date | string
    deskripsi?: StringFilter<"qcproduksi"> | string
    status?: StringFilter<"qcproduksi"> | string
    user_id?: IntFilter<"qcproduksi"> | number
    produksi_id?: IntFilter<"qcproduksi"> | number
    created_at?: DateTimeFilter<"qcproduksi"> | Date | string
    updated_at?: DateTimeFilter<"qcproduksi"> | Date | string
    deleted_at?: DateTimeNullableFilter<"qcproduksi"> | Date | string | null
  }

  export type userCreateWithoutKaryawanInput = {
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    role: roleCreateNestedOneWithoutUsersInput
    produksi?: produksiCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutKaryawanInput = {
    id?: number
    email: string
    password: string
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    produksi?: produksiUncheckedCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutKaryawanInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput>
  }

  export type userCreateManyKaryawanInputEnvelope = {
    data: userCreateManyKaryawanInput | userCreateManyKaryawanInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutKaryawanInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutKaryawanInput, userUncheckedUpdateWithoutKaryawanInput>
    create: XOR<userCreateWithoutKaryawanInput, userUncheckedCreateWithoutKaryawanInput>
  }

  export type userUpdateWithWhereUniqueWithoutKaryawanInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutKaryawanInput, userUncheckedUpdateWithoutKaryawanInput>
  }

  export type userUpdateManyWithWhereWithoutKaryawanInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutKaryawanInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    karyawan_id?: IntFilter<"user"> | number
    role_id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
  }

  export type userCreateWithoutRoleInput = {
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    karyawan: karyawanCreateNestedOneWithoutUsersInput
    produksi?: produksiCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRoleInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    produksi?: produksiUncheckedCreateNestedManyWithoutUserInput
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRoleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userCreateManyRoleInputEnvelope = {
    data: userCreateManyRoleInput | userCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type hak_aksesCreateWithoutRoleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    fungsi: fungsiCreateNestedOneWithoutHak_aksesInput
    akses: aksesCreateNestedOneWithoutHak_aksesInput
  }

  export type hak_aksesUncheckedCreateWithoutRoleInput = {
    id?: number
    fungsi_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesCreateOrConnectWithoutRoleInput = {
    where: hak_aksesWhereUniqueInput
    create: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput>
  }

  export type hak_aksesCreateManyRoleInputEnvelope = {
    data: hak_aksesCreateManyRoleInput | hak_aksesCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userUpdateWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
  }

  export type userUpdateManyWithWhereWithoutRoleInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutRoleInput>
  }

  export type hak_aksesUpsertWithWhereUniqueWithoutRoleInput = {
    where: hak_aksesWhereUniqueInput
    update: XOR<hak_aksesUpdateWithoutRoleInput, hak_aksesUncheckedUpdateWithoutRoleInput>
    create: XOR<hak_aksesCreateWithoutRoleInput, hak_aksesUncheckedCreateWithoutRoleInput>
  }

  export type hak_aksesUpdateWithWhereUniqueWithoutRoleInput = {
    where: hak_aksesWhereUniqueInput
    data: XOR<hak_aksesUpdateWithoutRoleInput, hak_aksesUncheckedUpdateWithoutRoleInput>
  }

  export type hak_aksesUpdateManyWithWhereWithoutRoleInput = {
    where: hak_aksesScalarWhereInput
    data: XOR<hak_aksesUpdateManyMutationInput, hak_aksesUncheckedUpdateManyWithoutRoleInput>
  }

  export type hak_aksesScalarWhereInput = {
    AND?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
    OR?: hak_aksesScalarWhereInput[]
    NOT?: hak_aksesScalarWhereInput | hak_aksesScalarWhereInput[]
    id?: IntFilter<"hak_akses"> | number
    role_id?: IntFilter<"hak_akses"> | number
    fungsi_id?: IntFilter<"hak_akses"> | number
    akses_id?: IntFilter<"hak_akses"> | number
    created_at?: DateTimeFilter<"hak_akses"> | Date | string
    updated_at?: DateTimeFilter<"hak_akses"> | Date | string
    deleted_at?: DateTimeNullableFilter<"hak_akses"> | Date | string | null
  }

  export type hak_aksesCreateWithoutAksesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    role: roleCreateNestedOneWithoutHak_aksesInput
    fungsi: fungsiCreateNestedOneWithoutHak_aksesInput
  }

  export type hak_aksesUncheckedCreateWithoutAksesInput = {
    id?: number
    role_id: number
    fungsi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesCreateOrConnectWithoutAksesInput = {
    where: hak_aksesWhereUniqueInput
    create: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput>
  }

  export type hak_aksesCreateManyAksesInputEnvelope = {
    data: hak_aksesCreateManyAksesInput | hak_aksesCreateManyAksesInput[]
    skipDuplicates?: boolean
  }

  export type hak_aksesUpsertWithWhereUniqueWithoutAksesInput = {
    where: hak_aksesWhereUniqueInput
    update: XOR<hak_aksesUpdateWithoutAksesInput, hak_aksesUncheckedUpdateWithoutAksesInput>
    create: XOR<hak_aksesCreateWithoutAksesInput, hak_aksesUncheckedCreateWithoutAksesInput>
  }

  export type hak_aksesUpdateWithWhereUniqueWithoutAksesInput = {
    where: hak_aksesWhereUniqueInput
    data: XOR<hak_aksesUpdateWithoutAksesInput, hak_aksesUncheckedUpdateWithoutAksesInput>
  }

  export type hak_aksesUpdateManyWithWhereWithoutAksesInput = {
    where: hak_aksesScalarWhereInput
    data: XOR<hak_aksesUpdateManyMutationInput, hak_aksesUncheckedUpdateManyWithoutAksesInput>
  }

  export type hak_aksesCreateWithoutFungsiInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    role: roleCreateNestedOneWithoutHak_aksesInput
    akses: aksesCreateNestedOneWithoutHak_aksesInput
  }

  export type hak_aksesUncheckedCreateWithoutFungsiInput = {
    id?: number
    role_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesCreateOrConnectWithoutFungsiInput = {
    where: hak_aksesWhereUniqueInput
    create: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput>
  }

  export type hak_aksesCreateManyFungsiInputEnvelope = {
    data: hak_aksesCreateManyFungsiInput | hak_aksesCreateManyFungsiInput[]
    skipDuplicates?: boolean
  }

  export type hak_aksesUpsertWithWhereUniqueWithoutFungsiInput = {
    where: hak_aksesWhereUniqueInput
    update: XOR<hak_aksesUpdateWithoutFungsiInput, hak_aksesUncheckedUpdateWithoutFungsiInput>
    create: XOR<hak_aksesCreateWithoutFungsiInput, hak_aksesUncheckedCreateWithoutFungsiInput>
  }

  export type hak_aksesUpdateWithWhereUniqueWithoutFungsiInput = {
    where: hak_aksesWhereUniqueInput
    data: XOR<hak_aksesUpdateWithoutFungsiInput, hak_aksesUncheckedUpdateWithoutFungsiInput>
  }

  export type hak_aksesUpdateManyWithWhereWithoutFungsiInput = {
    where: hak_aksesScalarWhereInput
    data: XOR<hak_aksesUpdateManyMutationInput, hak_aksesUncheckedUpdateManyWithoutFungsiInput>
  }

  export type roleCreateWithoutHak_aksesInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutHak_aksesInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    users?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutHak_aksesInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutHak_aksesInput, roleUncheckedCreateWithoutHak_aksesInput>
  }

  export type fungsiCreateWithoutHak_aksesInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type fungsiUncheckedCreateWithoutHak_aksesInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type fungsiCreateOrConnectWithoutHak_aksesInput = {
    where: fungsiWhereUniqueInput
    create: XOR<fungsiCreateWithoutHak_aksesInput, fungsiUncheckedCreateWithoutHak_aksesInput>
  }

  export type aksesCreateWithoutHak_aksesInput = {
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type aksesUncheckedCreateWithoutHak_aksesInput = {
    id?: number
    nama: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type aksesCreateOrConnectWithoutHak_aksesInput = {
    where: aksesWhereUniqueInput
    create: XOR<aksesCreateWithoutHak_aksesInput, aksesUncheckedCreateWithoutHak_aksesInput>
  }

  export type roleUpsertWithoutHak_aksesInput = {
    update: XOR<roleUpdateWithoutHak_aksesInput, roleUncheckedUpdateWithoutHak_aksesInput>
    create: XOR<roleCreateWithoutHak_aksesInput, roleUncheckedCreateWithoutHak_aksesInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutHak_aksesInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutHak_aksesInput, roleUncheckedUpdateWithoutHak_aksesInput>
  }

  export type roleUpdateWithoutHak_aksesInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutHak_aksesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type fungsiUpsertWithoutHak_aksesInput = {
    update: XOR<fungsiUpdateWithoutHak_aksesInput, fungsiUncheckedUpdateWithoutHak_aksesInput>
    create: XOR<fungsiCreateWithoutHak_aksesInput, fungsiUncheckedCreateWithoutHak_aksesInput>
    where?: fungsiWhereInput
  }

  export type fungsiUpdateToOneWithWhereWithoutHak_aksesInput = {
    where?: fungsiWhereInput
    data: XOR<fungsiUpdateWithoutHak_aksesInput, fungsiUncheckedUpdateWithoutHak_aksesInput>
  }

  export type fungsiUpdateWithoutHak_aksesInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fungsiUncheckedUpdateWithoutHak_aksesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aksesUpsertWithoutHak_aksesInput = {
    update: XOR<aksesUpdateWithoutHak_aksesInput, aksesUncheckedUpdateWithoutHak_aksesInput>
    create: XOR<aksesCreateWithoutHak_aksesInput, aksesUncheckedCreateWithoutHak_aksesInput>
    where?: aksesWhereInput
  }

  export type aksesUpdateToOneWithWhereWithoutHak_aksesInput = {
    where?: aksesWhereInput
    data: XOR<aksesUpdateWithoutHak_aksesInput, aksesUncheckedUpdateWithoutHak_aksesInput>
  }

  export type aksesUpdateWithoutHak_aksesInput = {
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aksesUncheckedUpdateWithoutHak_aksesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type kategori_produkCreateWithoutModel_produkInput = {
    nama: string
    tipe: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type kategori_produkUncheckedCreateWithoutModel_produkInput = {
    id?: number
    nama: string
    tipe: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type kategori_produkCreateOrConnectWithoutModel_produkInput = {
    where: kategori_produkWhereUniqueInput
    create: XOR<kategori_produkCreateWithoutModel_produkInput, kategori_produkUncheckedCreateWithoutModel_produkInput>
  }

  export type foto_produkCreateWithoutModel_produkInput = {
    filepath: string
  }

  export type foto_produkUncheckedCreateWithoutModel_produkInput = {
    id?: number
    filepath: string
  }

  export type foto_produkCreateOrConnectWithoutModel_produkInput = {
    where: foto_produkWhereUniqueInput
    create: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput>
  }

  export type foto_produkCreateManyModel_produkInputEnvelope = {
    data: foto_produkCreateManyModel_produkInput | foto_produkCreateManyModel_produkInput[]
    skipDuplicates?: boolean
  }

  export type detail_model_produkCreateWithoutModel_produkInput = {
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bahan_produk?: bahan_produkCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUncheckedCreateWithoutModel_produkInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiUncheckedCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkCreateOrConnectWithoutModel_produkInput = {
    where: detail_model_produkWhereUniqueInput
    create: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput>
  }

  export type detail_model_produkCreateManyModel_produkInputEnvelope = {
    data: detail_model_produkCreateManyModel_produkInput | detail_model_produkCreateManyModel_produkInput[]
    skipDuplicates?: boolean
  }

  export type kategori_produkUpsertWithoutModel_produkInput = {
    update: XOR<kategori_produkUpdateWithoutModel_produkInput, kategori_produkUncheckedUpdateWithoutModel_produkInput>
    create: XOR<kategori_produkCreateWithoutModel_produkInput, kategori_produkUncheckedCreateWithoutModel_produkInput>
    where?: kategori_produkWhereInput
  }

  export type kategori_produkUpdateToOneWithWhereWithoutModel_produkInput = {
    where?: kategori_produkWhereInput
    data: XOR<kategori_produkUpdateWithoutModel_produkInput, kategori_produkUncheckedUpdateWithoutModel_produkInput>
  }

  export type kategori_produkUpdateWithoutModel_produkInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kategori_produkUncheckedUpdateWithoutModel_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type foto_produkUpsertWithWhereUniqueWithoutModel_produkInput = {
    where: foto_produkWhereUniqueInput
    update: XOR<foto_produkUpdateWithoutModel_produkInput, foto_produkUncheckedUpdateWithoutModel_produkInput>
    create: XOR<foto_produkCreateWithoutModel_produkInput, foto_produkUncheckedCreateWithoutModel_produkInput>
  }

  export type foto_produkUpdateWithWhereUniqueWithoutModel_produkInput = {
    where: foto_produkWhereUniqueInput
    data: XOR<foto_produkUpdateWithoutModel_produkInput, foto_produkUncheckedUpdateWithoutModel_produkInput>
  }

  export type foto_produkUpdateManyWithWhereWithoutModel_produkInput = {
    where: foto_produkScalarWhereInput
    data: XOR<foto_produkUpdateManyMutationInput, foto_produkUncheckedUpdateManyWithoutModel_produkInput>
  }

  export type foto_produkScalarWhereInput = {
    AND?: foto_produkScalarWhereInput | foto_produkScalarWhereInput[]
    OR?: foto_produkScalarWhereInput[]
    NOT?: foto_produkScalarWhereInput | foto_produkScalarWhereInput[]
    id?: IntFilter<"foto_produk"> | number
    filepath?: StringFilter<"foto_produk"> | string
    model_produk_id?: IntFilter<"foto_produk"> | number
  }

  export type detail_model_produkUpsertWithWhereUniqueWithoutModel_produkInput = {
    where: detail_model_produkWhereUniqueInput
    update: XOR<detail_model_produkUpdateWithoutModel_produkInput, detail_model_produkUncheckedUpdateWithoutModel_produkInput>
    create: XOR<detail_model_produkCreateWithoutModel_produkInput, detail_model_produkUncheckedCreateWithoutModel_produkInput>
  }

  export type detail_model_produkUpdateWithWhereUniqueWithoutModel_produkInput = {
    where: detail_model_produkWhereUniqueInput
    data: XOR<detail_model_produkUpdateWithoutModel_produkInput, detail_model_produkUncheckedUpdateWithoutModel_produkInput>
  }

  export type detail_model_produkUpdateManyWithWhereWithoutModel_produkInput = {
    where: detail_model_produkScalarWhereInput
    data: XOR<detail_model_produkUpdateManyMutationInput, detail_model_produkUncheckedUpdateManyWithoutModel_produkInput>
  }

  export type detail_model_produkScalarWhereInput = {
    AND?: detail_model_produkScalarWhereInput | detail_model_produkScalarWhereInput[]
    OR?: detail_model_produkScalarWhereInput[]
    NOT?: detail_model_produkScalarWhereInput | detail_model_produkScalarWhereInput[]
    id?: IntFilter<"detail_model_produk"> | number
    ukuran?: StringFilter<"detail_model_produk"> | string
    biaya_jahit?: FloatFilter<"detail_model_produk"> | number
    hpp?: FloatFilter<"detail_model_produk"> | number
    harga_jual?: FloatFilter<"detail_model_produk"> | number
    deleted_at?: DateTimeNullableFilter<"detail_model_produk"> | Date | string | null
    model_produk_id?: IntFilter<"detail_model_produk"> | number
    created_at?: DateTimeFilter<"detail_model_produk"> | Date | string
    updated_at?: DateTimeFilter<"detail_model_produk"> | Date | string
  }

  export type model_produkCreateWithoutFoto_produkInput = {
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    kategori: kategori_produkCreateNestedOneWithoutModel_produkInput
    detail_model_produk?: detail_model_produkCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkUncheckedCreateWithoutFoto_produkInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    kategori_id: number
    created_at?: Date | string
    updated_at?: Date | string
    detail_model_produk?: detail_model_produkUncheckedCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkCreateOrConnectWithoutFoto_produkInput = {
    where: model_produkWhereUniqueInput
    create: XOR<model_produkCreateWithoutFoto_produkInput, model_produkUncheckedCreateWithoutFoto_produkInput>
  }

  export type model_produkUpsertWithoutFoto_produkInput = {
    update: XOR<model_produkUpdateWithoutFoto_produkInput, model_produkUncheckedUpdateWithoutFoto_produkInput>
    create: XOR<model_produkCreateWithoutFoto_produkInput, model_produkUncheckedCreateWithoutFoto_produkInput>
    where?: model_produkWhereInput
  }

  export type model_produkUpdateToOneWithWhereWithoutFoto_produkInput = {
    where?: model_produkWhereInput
    data: XOR<model_produkUpdateWithoutFoto_produkInput, model_produkUncheckedUpdateWithoutFoto_produkInput>
  }

  export type model_produkUpdateWithoutFoto_produkInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kategori?: kategori_produkUpdateOneRequiredWithoutModel_produkNestedInput
    detail_model_produk?: detail_model_produkUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkUncheckedUpdateWithoutFoto_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategori_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail_model_produk?: detail_model_produkUncheckedUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkCreateWithoutKategoriInput = {
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    foto_produk?: foto_produkCreateNestedManyWithoutModel_produkInput
    detail_model_produk?: detail_model_produkCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkUncheckedCreateWithoutKategoriInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    foto_produk?: foto_produkUncheckedCreateNestedManyWithoutModel_produkInput
    detail_model_produk?: detail_model_produkUncheckedCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkCreateOrConnectWithoutKategoriInput = {
    where: model_produkWhereUniqueInput
    create: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput>
  }

  export type model_produkCreateManyKategoriInputEnvelope = {
    data: model_produkCreateManyKategoriInput | model_produkCreateManyKategoriInput[]
    skipDuplicates?: boolean
  }

  export type model_produkUpsertWithWhereUniqueWithoutKategoriInput = {
    where: model_produkWhereUniqueInput
    update: XOR<model_produkUpdateWithoutKategoriInput, model_produkUncheckedUpdateWithoutKategoriInput>
    create: XOR<model_produkCreateWithoutKategoriInput, model_produkUncheckedCreateWithoutKategoriInput>
  }

  export type model_produkUpdateWithWhereUniqueWithoutKategoriInput = {
    where: model_produkWhereUniqueInput
    data: XOR<model_produkUpdateWithoutKategoriInput, model_produkUncheckedUpdateWithoutKategoriInput>
  }

  export type model_produkUpdateManyWithWhereWithoutKategoriInput = {
    where: model_produkScalarWhereInput
    data: XOR<model_produkUpdateManyMutationInput, model_produkUncheckedUpdateManyWithoutKategoriInput>
  }

  export type model_produkScalarWhereInput = {
    AND?: model_produkScalarWhereInput | model_produkScalarWhereInput[]
    OR?: model_produkScalarWhereInput[]
    NOT?: model_produkScalarWhereInput | model_produkScalarWhereInput[]
    id?: IntFilter<"model_produk"> | number
    kode?: StringFilter<"model_produk"> | string
    nama?: StringFilter<"model_produk"> | string
    variasi?: StringFilter<"model_produk"> | string
    deskripsi?: StringNullableFilter<"model_produk"> | string | null
    deleted_at?: DateTimeNullableFilter<"model_produk"> | Date | string | null
    kategori_id?: IntFilter<"model_produk"> | number
    created_at?: DateTimeFilter<"model_produk"> | Date | string
    updated_at?: DateTimeFilter<"model_produk"> | Date | string
  }

  export type model_produkCreateWithoutDetail_model_produkInput = {
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    kategori: kategori_produkCreateNestedOneWithoutModel_produkInput
    foto_produk?: foto_produkCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkUncheckedCreateWithoutDetail_model_produkInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    kategori_id: number
    created_at?: Date | string
    updated_at?: Date | string
    foto_produk?: foto_produkUncheckedCreateNestedManyWithoutModel_produkInput
  }

  export type model_produkCreateOrConnectWithoutDetail_model_produkInput = {
    where: model_produkWhereUniqueInput
    create: XOR<model_produkCreateWithoutDetail_model_produkInput, model_produkUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type bahan_produkCreateWithoutDetail_model_produkInput = {
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    daftar_bahan: daftar_bahanCreateNestedOneWithoutBahan_produkInput
  }

  export type bahan_produkUncheckedCreateWithoutDetail_model_produkInput = {
    id?: number
    jumlah: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkCreateOrConnectWithoutDetail_model_produkInput = {
    where: bahan_produkWhereUniqueInput
    create: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type bahan_produkCreateManyDetail_model_produkInputEnvelope = {
    data: bahan_produkCreateManyDetail_model_produkInput | bahan_produkCreateManyDetail_model_produkInput[]
    skipDuplicates?: boolean
  }

  export type daftar_produkCreateWithoutDetail_model_produkInput = {
    sku: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_produkUncheckedCreateWithoutDetail_model_produkInput = {
    id?: number
    sku: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_produkCreateOrConnectWithoutDetail_model_produkInput = {
    where: daftar_produkWhereUniqueInput
    create: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type daftar_produkCreateManyDetail_model_produkInputEnvelope = {
    data: daftar_produkCreateManyDetail_model_produkInput | daftar_produkCreateManyDetail_model_produkInput[]
    skipDuplicates?: boolean
  }

  export type produksiCreateWithoutDetail_model_produkInput = {
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProduksiInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutDetail_model_produkInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutProduksiInput
  }

  export type produksiCreateOrConnectWithoutDetail_model_produkInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type produksiCreateManyDetail_model_produkInputEnvelope = {
    data: produksiCreateManyDetail_model_produkInput | produksiCreateManyDetail_model_produkInput[]
    skipDuplicates?: boolean
  }

  export type model_produkUpsertWithoutDetail_model_produkInput = {
    update: XOR<model_produkUpdateWithoutDetail_model_produkInput, model_produkUncheckedUpdateWithoutDetail_model_produkInput>
    create: XOR<model_produkCreateWithoutDetail_model_produkInput, model_produkUncheckedCreateWithoutDetail_model_produkInput>
    where?: model_produkWhereInput
  }

  export type model_produkUpdateToOneWithWhereWithoutDetail_model_produkInput = {
    where?: model_produkWhereInput
    data: XOR<model_produkUpdateWithoutDetail_model_produkInput, model_produkUncheckedUpdateWithoutDetail_model_produkInput>
  }

  export type model_produkUpdateWithoutDetail_model_produkInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kategori?: kategori_produkUpdateOneRequiredWithoutModel_produkNestedInput
    foto_produk?: foto_produkUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkUncheckedUpdateWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategori_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    foto_produk?: foto_produkUncheckedUpdateManyWithoutModel_produkNestedInput
  }

  export type bahan_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput = {
    where: bahan_produkWhereUniqueInput
    update: XOR<bahan_produkUpdateWithoutDetail_model_produkInput, bahan_produkUncheckedUpdateWithoutDetail_model_produkInput>
    create: XOR<bahan_produkCreateWithoutDetail_model_produkInput, bahan_produkUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type bahan_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput = {
    where: bahan_produkWhereUniqueInput
    data: XOR<bahan_produkUpdateWithoutDetail_model_produkInput, bahan_produkUncheckedUpdateWithoutDetail_model_produkInput>
  }

  export type bahan_produkUpdateManyWithWhereWithoutDetail_model_produkInput = {
    where: bahan_produkScalarWhereInput
    data: XOR<bahan_produkUpdateManyMutationInput, bahan_produkUncheckedUpdateManyWithoutDetail_model_produkInput>
  }

  export type bahan_produkScalarWhereInput = {
    AND?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
    OR?: bahan_produkScalarWhereInput[]
    NOT?: bahan_produkScalarWhereInput | bahan_produkScalarWhereInput[]
    id?: IntFilter<"bahan_produk"> | number
    jumlah?: FloatFilter<"bahan_produk"> | number
    detail_model_produk_id?: IntFilter<"bahan_produk"> | number
    daftar_bahan_id?: IntFilter<"bahan_produk"> | number
    created_at?: DateTimeFilter<"bahan_produk"> | Date | string
    updated_at?: DateTimeFilter<"bahan_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"bahan_produk"> | Date | string | null
  }

  export type daftar_produkUpsertWithWhereUniqueWithoutDetail_model_produkInput = {
    where: daftar_produkWhereUniqueInput
    update: XOR<daftar_produkUpdateWithoutDetail_model_produkInput, daftar_produkUncheckedUpdateWithoutDetail_model_produkInput>
    create: XOR<daftar_produkCreateWithoutDetail_model_produkInput, daftar_produkUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type daftar_produkUpdateWithWhereUniqueWithoutDetail_model_produkInput = {
    where: daftar_produkWhereUniqueInput
    data: XOR<daftar_produkUpdateWithoutDetail_model_produkInput, daftar_produkUncheckedUpdateWithoutDetail_model_produkInput>
  }

  export type daftar_produkUpdateManyWithWhereWithoutDetail_model_produkInput = {
    where: daftar_produkScalarWhereInput
    data: XOR<daftar_produkUpdateManyMutationInput, daftar_produkUncheckedUpdateManyWithoutDetail_model_produkInput>
  }

  export type daftar_produkScalarWhereInput = {
    AND?: daftar_produkScalarWhereInput | daftar_produkScalarWhereInput[]
    OR?: daftar_produkScalarWhereInput[]
    NOT?: daftar_produkScalarWhereInput | daftar_produkScalarWhereInput[]
    id?: IntFilter<"daftar_produk"> | number
    sku?: StringFilter<"daftar_produk"> | string
    detail_model_produk_id?: IntFilter<"daftar_produk"> | number
    created_at?: DateTimeFilter<"daftar_produk"> | Date | string
    updated_at?: DateTimeFilter<"daftar_produk"> | Date | string
    deleted_at?: DateTimeNullableFilter<"daftar_produk"> | Date | string | null
  }

  export type produksiUpsertWithWhereUniqueWithoutDetail_model_produkInput = {
    where: produksiWhereUniqueInput
    update: XOR<produksiUpdateWithoutDetail_model_produkInput, produksiUncheckedUpdateWithoutDetail_model_produkInput>
    create: XOR<produksiCreateWithoutDetail_model_produkInput, produksiUncheckedCreateWithoutDetail_model_produkInput>
  }

  export type produksiUpdateWithWhereUniqueWithoutDetail_model_produkInput = {
    where: produksiWhereUniqueInput
    data: XOR<produksiUpdateWithoutDetail_model_produkInput, produksiUncheckedUpdateWithoutDetail_model_produkInput>
  }

  export type produksiUpdateManyWithWhereWithoutDetail_model_produkInput = {
    where: produksiScalarWhereInput
    data: XOR<produksiUpdateManyMutationInput, produksiUncheckedUpdateManyWithoutDetail_model_produkInput>
  }

  export type detail_model_produkCreateWithoutBahan_produkInput = {
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk: model_produkCreateNestedOneWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUncheckedCreateWithoutBahan_produkInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    daftar_produk?: daftar_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiUncheckedCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkCreateOrConnectWithoutBahan_produkInput = {
    where: detail_model_produkWhereUniqueInput
    create: XOR<detail_model_produkCreateWithoutBahan_produkInput, detail_model_produkUncheckedCreateWithoutBahan_produkInput>
  }

  export type daftar_bahanCreateWithoutBahan_produkInput = {
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    restok_bahan?: restok_bahanCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanUncheckedCreateWithoutBahan_produkInput = {
    id?: number
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    restok_bahan?: restok_bahanUncheckedCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanCreateOrConnectWithoutBahan_produkInput = {
    where: daftar_bahanWhereUniqueInput
    create: XOR<daftar_bahanCreateWithoutBahan_produkInput, daftar_bahanUncheckedCreateWithoutBahan_produkInput>
  }

  export type detail_model_produkUpsertWithoutBahan_produkInput = {
    update: XOR<detail_model_produkUpdateWithoutBahan_produkInput, detail_model_produkUncheckedUpdateWithoutBahan_produkInput>
    create: XOR<detail_model_produkCreateWithoutBahan_produkInput, detail_model_produkUncheckedCreateWithoutBahan_produkInput>
    where?: detail_model_produkWhereInput
  }

  export type detail_model_produkUpdateToOneWithWhereWithoutBahan_produkInput = {
    where?: detail_model_produkWhereInput
    data: XOR<detail_model_produkUpdateWithoutBahan_produkInput, detail_model_produkUncheckedUpdateWithoutBahan_produkInput>
  }

  export type detail_model_produkUpdateWithoutBahan_produkInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUpdateOneRequiredWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateWithoutBahan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    daftar_produk?: daftar_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUncheckedUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type daftar_bahanUpsertWithoutBahan_produkInput = {
    update: XOR<daftar_bahanUpdateWithoutBahan_produkInput, daftar_bahanUncheckedUpdateWithoutBahan_produkInput>
    create: XOR<daftar_bahanCreateWithoutBahan_produkInput, daftar_bahanUncheckedCreateWithoutBahan_produkInput>
    where?: daftar_bahanWhereInput
  }

  export type daftar_bahanUpdateToOneWithWhereWithoutBahan_produkInput = {
    where?: daftar_bahanWhereInput
    data: XOR<daftar_bahanUpdateWithoutBahan_produkInput, daftar_bahanUncheckedUpdateWithoutBahan_produkInput>
  }

  export type daftar_bahanUpdateWithoutBahan_produkInput = {
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restok_bahan?: restok_bahanUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type daftar_bahanUncheckedUpdateWithoutBahan_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restok_bahan?: restok_bahanUncheckedUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type bahan_produkCreateWithoutDaftar_bahanInput = {
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutBahan_produkInput
  }

  export type bahan_produkUncheckedCreateWithoutDaftar_bahanInput = {
    id?: number
    jumlah: number
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkCreateOrConnectWithoutDaftar_bahanInput = {
    where: bahan_produkWhereUniqueInput
    create: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput>
  }

  export type bahan_produkCreateManyDaftar_bahanInputEnvelope = {
    data: bahan_produkCreateManyDaftar_bahanInput | bahan_produkCreateManyDaftar_bahanInput[]
    skipDuplicates?: boolean
  }

  export type restok_bahanCreateWithoutDaftar_bahanInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    supplier: supplierCreateNestedOneWithoutRestok_bahanInput
  }

  export type restok_bahanUncheckedCreateWithoutDaftar_bahanInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    supplier_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanCreateOrConnectWithoutDaftar_bahanInput = {
    where: restok_bahanWhereUniqueInput
    create: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput>
  }

  export type restok_bahanCreateManyDaftar_bahanInputEnvelope = {
    data: restok_bahanCreateManyDaftar_bahanInput | restok_bahanCreateManyDaftar_bahanInput[]
    skipDuplicates?: boolean
  }

  export type bahan_produkUpsertWithWhereUniqueWithoutDaftar_bahanInput = {
    where: bahan_produkWhereUniqueInput
    update: XOR<bahan_produkUpdateWithoutDaftar_bahanInput, bahan_produkUncheckedUpdateWithoutDaftar_bahanInput>
    create: XOR<bahan_produkCreateWithoutDaftar_bahanInput, bahan_produkUncheckedCreateWithoutDaftar_bahanInput>
  }

  export type bahan_produkUpdateWithWhereUniqueWithoutDaftar_bahanInput = {
    where: bahan_produkWhereUniqueInput
    data: XOR<bahan_produkUpdateWithoutDaftar_bahanInput, bahan_produkUncheckedUpdateWithoutDaftar_bahanInput>
  }

  export type bahan_produkUpdateManyWithWhereWithoutDaftar_bahanInput = {
    where: bahan_produkScalarWhereInput
    data: XOR<bahan_produkUpdateManyMutationInput, bahan_produkUncheckedUpdateManyWithoutDaftar_bahanInput>
  }

  export type restok_bahanUpsertWithWhereUniqueWithoutDaftar_bahanInput = {
    where: restok_bahanWhereUniqueInput
    update: XOR<restok_bahanUpdateWithoutDaftar_bahanInput, restok_bahanUncheckedUpdateWithoutDaftar_bahanInput>
    create: XOR<restok_bahanCreateWithoutDaftar_bahanInput, restok_bahanUncheckedCreateWithoutDaftar_bahanInput>
  }

  export type restok_bahanUpdateWithWhereUniqueWithoutDaftar_bahanInput = {
    where: restok_bahanWhereUniqueInput
    data: XOR<restok_bahanUpdateWithoutDaftar_bahanInput, restok_bahanUncheckedUpdateWithoutDaftar_bahanInput>
  }

  export type restok_bahanUpdateManyWithWhereWithoutDaftar_bahanInput = {
    where: restok_bahanScalarWhereInput
    data: XOR<restok_bahanUpdateManyMutationInput, restok_bahanUncheckedUpdateManyWithoutDaftar_bahanInput>
  }

  export type restok_bahanScalarWhereInput = {
    AND?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
    OR?: restok_bahanScalarWhereInput[]
    NOT?: restok_bahanScalarWhereInput | restok_bahanScalarWhereInput[]
    id?: IntFilter<"restok_bahan"> | number
    tanggal_pesan?: DateTimeFilter<"restok_bahan"> | Date | string
    tanggal_terima?: DateTimeFilter<"restok_bahan"> | Date | string
    harga_satuan?: FloatFilter<"restok_bahan"> | number
    jumlah?: FloatFilter<"restok_bahan"> | number
    daftar_bahan_id?: IntFilter<"restok_bahan"> | number
    supplier_id?: IntFilter<"restok_bahan"> | number
    created_at?: DateTimeFilter<"restok_bahan"> | Date | string
    updated_at?: DateTimeFilter<"restok_bahan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"restok_bahan"> | Date | string | null
  }

  export type daftar_bahanCreateWithoutRestok_bahanInput = {
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    bahan_produk?: bahan_produkCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanUncheckedCreateWithoutRestok_bahanInput = {
    id?: number
    kode: string
    stok: number
    nama: string
    satuan: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDaftar_bahanInput
  }

  export type daftar_bahanCreateOrConnectWithoutRestok_bahanInput = {
    where: daftar_bahanWhereUniqueInput
    create: XOR<daftar_bahanCreateWithoutRestok_bahanInput, daftar_bahanUncheckedCreateWithoutRestok_bahanInput>
  }

  export type supplierCreateWithoutRestok_bahanInput = {
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type supplierUncheckedCreateWithoutRestok_bahanInput = {
    id?: number
    kode: string
    nama: string
    alamat: string
    kontak: string
    no_rek: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type supplierCreateOrConnectWithoutRestok_bahanInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutRestok_bahanInput, supplierUncheckedCreateWithoutRestok_bahanInput>
  }

  export type daftar_bahanUpsertWithoutRestok_bahanInput = {
    update: XOR<daftar_bahanUpdateWithoutRestok_bahanInput, daftar_bahanUncheckedUpdateWithoutRestok_bahanInput>
    create: XOR<daftar_bahanCreateWithoutRestok_bahanInput, daftar_bahanUncheckedCreateWithoutRestok_bahanInput>
    where?: daftar_bahanWhereInput
  }

  export type daftar_bahanUpdateToOneWithWhereWithoutRestok_bahanInput = {
    where?: daftar_bahanWhereInput
    data: XOR<daftar_bahanUpdateWithoutRestok_bahanInput, daftar_bahanUncheckedUpdateWithoutRestok_bahanInput>
  }

  export type daftar_bahanUpdateWithoutRestok_bahanInput = {
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bahan_produk?: bahan_produkUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type daftar_bahanUncheckedUpdateWithoutRestok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    stok?: FloatFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    satuan?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDaftar_bahanNestedInput
  }

  export type supplierUpsertWithoutRestok_bahanInput = {
    update: XOR<supplierUpdateWithoutRestok_bahanInput, supplierUncheckedUpdateWithoutRestok_bahanInput>
    create: XOR<supplierCreateWithoutRestok_bahanInput, supplierUncheckedCreateWithoutRestok_bahanInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutRestok_bahanInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutRestok_bahanInput, supplierUncheckedUpdateWithoutRestok_bahanInput>
  }

  export type supplierUpdateWithoutRestok_bahanInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supplierUncheckedUpdateWithoutRestok_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    no_rek?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanCreateWithoutSupplierInput = {
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    daftar_bahan: daftar_bahanCreateNestedOneWithoutRestok_bahanInput
  }

  export type restok_bahanUncheckedCreateWithoutSupplierInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanCreateOrConnectWithoutSupplierInput = {
    where: restok_bahanWhereUniqueInput
    create: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput>
  }

  export type restok_bahanCreateManySupplierInputEnvelope = {
    data: restok_bahanCreateManySupplierInput | restok_bahanCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type restok_bahanUpsertWithWhereUniqueWithoutSupplierInput = {
    where: restok_bahanWhereUniqueInput
    update: XOR<restok_bahanUpdateWithoutSupplierInput, restok_bahanUncheckedUpdateWithoutSupplierInput>
    create: XOR<restok_bahanCreateWithoutSupplierInput, restok_bahanUncheckedCreateWithoutSupplierInput>
  }

  export type restok_bahanUpdateWithWhereUniqueWithoutSupplierInput = {
    where: restok_bahanWhereUniqueInput
    data: XOR<restok_bahanUpdateWithoutSupplierInput, restok_bahanUncheckedUpdateWithoutSupplierInput>
  }

  export type restok_bahanUpdateManyWithWhereWithoutSupplierInput = {
    where: restok_bahanScalarWhereInput
    data: XOR<restok_bahanUpdateManyMutationInput, restok_bahanUncheckedUpdateManyWithoutSupplierInput>
  }

  export type detail_model_produkCreateWithoutProduksiInput = {
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk: model_produkCreateNestedOneWithoutDetail_model_produkInput
    bahan_produk?: bahan_produkCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUncheckedCreateWithoutProduksiInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    daftar_produk?: daftar_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkCreateOrConnectWithoutProduksiInput = {
    where: detail_model_produkWhereUniqueInput
    create: XOR<detail_model_produkCreateWithoutProduksiInput, detail_model_produkUncheckedCreateWithoutProduksiInput>
  }

  export type userCreateWithoutProduksiInput = {
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    karyawan: karyawanCreateNestedOneWithoutUsersInput
    role: roleCreateNestedOneWithoutUsersInput
    qcproduksi?: qcproduksiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProduksiInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    qcproduksi?: qcproduksiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProduksiInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProduksiInput, userUncheckedCreateWithoutProduksiInput>
  }

  export type qcproduksiCreateWithoutProduksiInput = {
    waktu?: Date | string
    deskripsi: string
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutQcproduksiInput
  }

  export type qcproduksiUncheckedCreateWithoutProduksiInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiCreateOrConnectWithoutProduksiInput = {
    where: qcproduksiWhereUniqueInput
    create: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput>
  }

  export type qcproduksiCreateManyProduksiInputEnvelope = {
    data: qcproduksiCreateManyProduksiInput | qcproduksiCreateManyProduksiInput[]
    skipDuplicates?: boolean
  }

  export type detail_model_produkUpsertWithoutProduksiInput = {
    update: XOR<detail_model_produkUpdateWithoutProduksiInput, detail_model_produkUncheckedUpdateWithoutProduksiInput>
    create: XOR<detail_model_produkCreateWithoutProduksiInput, detail_model_produkUncheckedCreateWithoutProduksiInput>
    where?: detail_model_produkWhereInput
  }

  export type detail_model_produkUpdateToOneWithWhereWithoutProduksiInput = {
    where?: detail_model_produkWhereInput
    data: XOR<detail_model_produkUpdateWithoutProduksiInput, detail_model_produkUncheckedUpdateWithoutProduksiInput>
  }

  export type detail_model_produkUpdateWithoutProduksiInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUpdateOneRequiredWithoutDetail_model_produkNestedInput
    bahan_produk?: bahan_produkUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type userUpsertWithoutProduksiInput = {
    update: XOR<userUpdateWithoutProduksiInput, userUncheckedUpdateWithoutProduksiInput>
    create: XOR<userCreateWithoutProduksiInput, userUncheckedCreateWithoutProduksiInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProduksiInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProduksiInput, userUncheckedUpdateWithoutProduksiInput>
  }

  export type userUpdateWithoutProduksiInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    karyawan?: karyawanUpdateOneRequiredWithoutUsersNestedInput
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type qcproduksiUpsertWithWhereUniqueWithoutProduksiInput = {
    where: qcproduksiWhereUniqueInput
    update: XOR<qcproduksiUpdateWithoutProduksiInput, qcproduksiUncheckedUpdateWithoutProduksiInput>
    create: XOR<qcproduksiCreateWithoutProduksiInput, qcproduksiUncheckedCreateWithoutProduksiInput>
  }

  export type qcproduksiUpdateWithWhereUniqueWithoutProduksiInput = {
    where: qcproduksiWhereUniqueInput
    data: XOR<qcproduksiUpdateWithoutProduksiInput, qcproduksiUncheckedUpdateWithoutProduksiInput>
  }

  export type qcproduksiUpdateManyWithWhereWithoutProduksiInput = {
    where: qcproduksiScalarWhereInput
    data: XOR<qcproduksiUpdateManyMutationInput, qcproduksiUncheckedUpdateManyWithoutProduksiInput>
  }

  export type userCreateWithoutQcproduksiInput = {
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    karyawan: karyawanCreateNestedOneWithoutUsersInput
    role: roleCreateNestedOneWithoutUsersInput
    produksi?: produksiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutQcproduksiInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    produksi?: produksiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutQcproduksiInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutQcproduksiInput, userUncheckedCreateWithoutQcproduksiInput>
  }

  export type produksiCreateWithoutQcproduksiInput = {
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    detail_model_produk: detail_model_produkCreateNestedOneWithoutProduksiInput
    user: userCreateNestedOneWithoutProduksiInput
  }

  export type produksiUncheckedCreateWithoutQcproduksiInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    detail_model_produk_id: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type produksiCreateOrConnectWithoutQcproduksiInput = {
    where: produksiWhereUniqueInput
    create: XOR<produksiCreateWithoutQcproduksiInput, produksiUncheckedCreateWithoutQcproduksiInput>
  }

  export type userUpsertWithoutQcproduksiInput = {
    update: XOR<userUpdateWithoutQcproduksiInput, userUncheckedUpdateWithoutQcproduksiInput>
    create: XOR<userCreateWithoutQcproduksiInput, userUncheckedCreateWithoutQcproduksiInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutQcproduksiInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutQcproduksiInput, userUncheckedUpdateWithoutQcproduksiInput>
  }

  export type userUpdateWithoutQcproduksiInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    karyawan?: karyawanUpdateOneRequiredWithoutUsersNestedInput
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
    produksi?: produksiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutQcproduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produksi?: produksiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type produksiUpsertWithoutQcproduksiInput = {
    update: XOR<produksiUpdateWithoutQcproduksiInput, produksiUncheckedUpdateWithoutQcproduksiInput>
    create: XOR<produksiCreateWithoutQcproduksiInput, produksiUncheckedCreateWithoutQcproduksiInput>
    where?: produksiWhereInput
  }

  export type produksiUpdateToOneWithWhereWithoutQcproduksiInput = {
    where?: produksiWhereInput
    data: XOR<produksiUpdateWithoutQcproduksiInput, produksiUncheckedUpdateWithoutQcproduksiInput>
  }

  export type produksiUpdateWithoutQcproduksiInput = {
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutProduksiNestedInput
    user?: userUpdateOneRequiredWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutQcproduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detail_model_produkCreateWithoutDaftar_produkInput = {
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    model_produk: model_produkCreateNestedOneWithoutDetail_model_produkInput
    bahan_produk?: bahan_produkCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkUncheckedCreateWithoutDaftar_produkInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    bahan_produk?: bahan_produkUncheckedCreateNestedManyWithoutDetail_model_produkInput
    produksi?: produksiUncheckedCreateNestedManyWithoutDetail_model_produkInput
  }

  export type detail_model_produkCreateOrConnectWithoutDaftar_produkInput = {
    where: detail_model_produkWhereUniqueInput
    create: XOR<detail_model_produkCreateWithoutDaftar_produkInput, detail_model_produkUncheckedCreateWithoutDaftar_produkInput>
  }

  export type detail_model_produkUpsertWithoutDaftar_produkInput = {
    update: XOR<detail_model_produkUpdateWithoutDaftar_produkInput, detail_model_produkUncheckedUpdateWithoutDaftar_produkInput>
    create: XOR<detail_model_produkCreateWithoutDaftar_produkInput, detail_model_produkUncheckedCreateWithoutDaftar_produkInput>
    where?: detail_model_produkWhereInput
  }

  export type detail_model_produkUpdateToOneWithWhereWithoutDaftar_produkInput = {
    where?: detail_model_produkWhereInput
    data: XOR<detail_model_produkUpdateWithoutDaftar_produkInput, detail_model_produkUncheckedUpdateWithoutDaftar_produkInput>
  }

  export type detail_model_produkUpdateWithoutDaftar_produkInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    model_produk?: model_produkUpdateOneRequiredWithoutDetail_model_produkNestedInput
    bahan_produk?: bahan_produkUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateWithoutDaftar_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUncheckedUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type produksiCreateManyUserInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiCreateManyUserInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    produksi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type produksiUpdateWithoutUserInput = {
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutProduksiNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiUpdateWithoutUserInput = {
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produksi?: produksiUpdateOneRequiredWithoutQcproduksiNestedInput
  }

  export type qcproduksiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    produksi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    produksi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateManyKaryawanInput = {
    id?: number
    email: string
    password: string
    role_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type userUpdateWithoutKaryawanInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
    produksi?: produksiUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutKaryawanInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produksi?: produksiUncheckedUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutKaryawanInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateManyRoleInput = {
    id?: number
    email: string
    password: string
    karyawan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesCreateManyRoleInput = {
    id?: number
    fungsi_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type userUpdateWithoutRoleInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    karyawan?: karyawanUpdateOneRequiredWithoutUsersNestedInput
    produksi?: produksiUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produksi?: produksiUncheckedUpdateManyWithoutUserNestedInput
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    karyawan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesUpdateWithoutRoleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fungsi?: fungsiUpdateOneRequiredWithoutHak_aksesNestedInput
    akses?: aksesUpdateOneRequiredWithoutHak_aksesNestedInput
  }

  export type hak_aksesUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesCreateManyAksesInput = {
    id?: number
    role_id: number
    fungsi_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesUpdateWithoutAksesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutHak_aksesNestedInput
    fungsi?: fungsiUpdateOneRequiredWithoutHak_aksesNestedInput
  }

  export type hak_aksesUncheckedUpdateWithoutAksesInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesUncheckedUpdateManyWithoutAksesInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    fungsi_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesCreateManyFungsiInput = {
    id?: number
    role_id: number
    akses_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type hak_aksesUpdateWithoutFungsiInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutHak_aksesNestedInput
    akses?: aksesUpdateOneRequiredWithoutHak_aksesNestedInput
  }

  export type hak_aksesUncheckedUpdateWithoutFungsiInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hak_aksesUncheckedUpdateManyWithoutFungsiInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    akses_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type foto_produkCreateManyModel_produkInput = {
    id?: number
    filepath: string
  }

  export type detail_model_produkCreateManyModel_produkInput = {
    id?: number
    ukuran: string
    biaya_jahit: number
    hpp: number
    harga_jual: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type foto_produkUpdateWithoutModel_produkInput = {
    filepath?: StringFieldUpdateOperationsInput | string
  }

  export type foto_produkUncheckedUpdateWithoutModel_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    filepath?: StringFieldUpdateOperationsInput | string
  }

  export type foto_produkUncheckedUpdateManyWithoutModel_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    filepath?: StringFieldUpdateOperationsInput | string
  }

  export type detail_model_produkUpdateWithoutModel_produkInput = {
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bahan_produk?: bahan_produkUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateWithoutModel_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bahan_produk?: bahan_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    daftar_produk?: daftar_produkUncheckedUpdateManyWithoutDetail_model_produkNestedInput
    produksi?: produksiUncheckedUpdateManyWithoutDetail_model_produkNestedInput
  }

  export type detail_model_produkUncheckedUpdateManyWithoutModel_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    ukuran?: StringFieldUpdateOperationsInput | string
    biaya_jahit?: FloatFieldUpdateOperationsInput | number
    hpp?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type model_produkCreateManyKategoriInput = {
    id?: number
    kode: string
    nama: string
    variasi: string
    deskripsi?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type model_produkUpdateWithoutKategoriInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    foto_produk?: foto_produkUpdateManyWithoutModel_produkNestedInput
    detail_model_produk?: detail_model_produkUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkUncheckedUpdateWithoutKategoriInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    foto_produk?: foto_produkUncheckedUpdateManyWithoutModel_produkNestedInput
    detail_model_produk?: detail_model_produkUncheckedUpdateManyWithoutModel_produkNestedInput
  }

  export type model_produkUncheckedUpdateManyWithoutKategoriInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    variasi?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bahan_produkCreateManyDetail_model_produkInput = {
    id?: number
    jumlah: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type daftar_produkCreateManyDetail_model_produkInput = {
    id?: number
    sku: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type produksiCreateManyDetail_model_produkInput = {
    id?: number
    produksi: string
    tanggal_mulai?: Date | string
    tanggal_selesai?: Date | string | null
    jumlah: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkUpdateWithoutDetail_model_produkInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daftar_bahan?: daftar_bahanUpdateOneRequiredWithoutBahan_produkNestedInput
  }

  export type bahan_produkUncheckedUpdateWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bahan_produkUncheckedUpdateManyWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkUpdateWithoutDetail_model_produkInput = {
    sku?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkUncheckedUpdateWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daftar_produkUncheckedUpdateManyWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type produksiUpdateWithoutDetail_model_produkInput = {
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProduksiNestedInput
    qcproduksi?: qcproduksiUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcproduksi?: qcproduksiUncheckedUpdateManyWithoutProduksiNestedInput
  }

  export type produksiUncheckedUpdateManyWithoutDetail_model_produkInput = {
    id?: IntFieldUpdateOperationsInput | number
    produksi?: StringFieldUpdateOperationsInput | string
    tanggal_mulai?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_selesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bahan_produkCreateManyDaftar_bahanInput = {
    id?: number
    jumlah: number
    detail_model_produk_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanCreateManyDaftar_bahanInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    supplier_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bahan_produkUpdateWithoutDaftar_bahanInput = {
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detail_model_produk?: detail_model_produkUpdateOneRequiredWithoutBahan_produkNestedInput
  }

  export type bahan_produkUncheckedUpdateWithoutDaftar_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bahan_produkUncheckedUpdateManyWithoutDaftar_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    detail_model_produk_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanUpdateWithoutDaftar_bahanInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: supplierUpdateOneRequiredWithoutRestok_bahanNestedInput
  }

  export type restok_bahanUncheckedUpdateWithoutDaftar_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanUncheckedUpdateManyWithoutDaftar_bahanInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanCreateManySupplierInput = {
    id?: number
    tanggal_pesan: Date | string
    tanggal_terima: Date | string
    harga_satuan: number
    jumlah: number
    daftar_bahan_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type restok_bahanUpdateWithoutSupplierInput = {
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daftar_bahan?: daftar_bahanUpdateOneRequiredWithoutRestok_bahanNestedInput
  }

  export type restok_bahanUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type restok_bahanUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal_pesan?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggal_terima?: DateTimeFieldUpdateOperationsInput | Date | string
    harga_satuan?: FloatFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    daftar_bahan_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiCreateManyProduksiInput = {
    id?: number
    waktu?: Date | string
    deskripsi: string
    status: string
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type qcproduksiUpdateWithoutProduksiInput = {
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQcproduksiNestedInput
  }

  export type qcproduksiUncheckedUpdateWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcproduksiUncheckedUpdateManyWithoutProduksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KaryawanCountOutputTypeDefaultArgs instead
     */
    export type KaryawanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KaryawanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AksesCountOutputTypeDefaultArgs instead
     */
    export type AksesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AksesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FungsiCountOutputTypeDefaultArgs instead
     */
    export type FungsiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FungsiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Model_produkCountOutputTypeDefaultArgs instead
     */
    export type Model_produkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Model_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Kategori_produkCountOutputTypeDefaultArgs instead
     */
    export type Kategori_produkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Kategori_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Detail_model_produkCountOutputTypeDefaultArgs instead
     */
    export type Detail_model_produkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Detail_model_produkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Daftar_bahanCountOutputTypeDefaultArgs instead
     */
    export type Daftar_bahanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Daftar_bahanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProduksiCountOutputTypeDefaultArgs instead
     */
    export type ProduksiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProduksiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use karyawanDefaultArgs instead
     */
    export type karyawanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = karyawanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roleDefaultArgs instead
     */
    export type roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use aksesDefaultArgs instead
     */
    export type aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = aksesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fungsiDefaultArgs instead
     */
    export type fungsiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fungsiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hak_aksesDefaultArgs instead
     */
    export type hak_aksesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hak_aksesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use model_produkDefaultArgs instead
     */
    export type model_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = model_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use foto_produkDefaultArgs instead
     */
    export type foto_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = foto_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kategori_produkDefaultArgs instead
     */
    export type kategori_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kategori_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detail_model_produkDefaultArgs instead
     */
    export type detail_model_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detail_model_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bahan_produkDefaultArgs instead
     */
    export type bahan_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bahan_produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use daftar_bahanDefaultArgs instead
     */
    export type daftar_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = daftar_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use restok_bahanDefaultArgs instead
     */
    export type restok_bahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = restok_bahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplierDefaultArgs instead
     */
    export type supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use produksiDefaultArgs instead
     */
    export type produksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = produksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use qcproduksiDefaultArgs instead
     */
    export type qcproduksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = qcproduksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use daftar_produkDefaultArgs instead
     */
    export type daftar_produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = daftar_produkDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}